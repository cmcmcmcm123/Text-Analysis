An Iterative Hierarchical Key Exchange Scheme for  Secure Scheduling of Big Data Applications in

Abstract ? As the new-generation distributed computing platform, cloud computing environments offer high efficiency and low cost for data-intensive computation in big data applications. Cloud resources and services are available in pay- as-you-go mode, which brings extraordinary flexibility and cost- effectiveness as well as zero investment in their own computing infrastructure. However, these advantages come at a price - people no longer have direct control over their own data. Based on this view, data security becomes a major concern in the adoption of cloud computing. Authenticated Key Exchange (AKE) is essential to a security system that is based on high efficiency symmetric-key encryption. With virtualization technology being applied, existing key exchange schemes such as Internet Key Exchange (IKE) becomes time-consuming when directly deployed into cloud computing environment. In this paper we propose a novel hierarchical key exchange scheme, namely Cloud Background Hierarchical Key Exchange (CBHKE). Based on our previous work, CBHKE aims at providing secure and efficient scheduling for cloud computing environment. In our new scheme, we design a two-phase layer-by-layer iterative key exchange strategy to achieve more efficient AKE without sacrificing the level of data security. Both theoretical analysis and experimental results demonstrate that when deployed in cloud computing environment, efficiency of the proposed scheme is dramatically superior to its predecessors CCBKE and IKE schemes.

Keywords - cloud computing; big data; key exchange; efficient security-aware scheduling; virtualisation security

I. INTRODUCTION As the new generation computing paradigm, cloud  computing has been attracting extensive interest from IT industry and academia in recent years. One of its core concepts is ?X as a Service? (XaaS), including Infrastructure- as-a-Service (IaaS), Platform-as-a-Service (PaaS), and Software-as-a-Service (SaaS), which means that both individual and enterprise users can use IT services in pay-as- you-go fashion. Compared to traditional distributed systems, this new concept in cloud computing brings outstanding advantages. First, a considerable amount of investment is  saved, for there is no need for users to purchase and maintain their own IT facilities. Second, it brings exceptional elasticity, scalability and efficiency for task executions, especially in big data applications [6, 9]. Therefore, utilising cloud to run data- intensive applications, such as applications in scientific research or social networks, becomes a cost-effective choice.

For example, the Swiss physics research lab CERN [14] utilised cloud computing to help execute the computation tasks for their particle accelerator which generates 22PB data every year. Until now, there have been several cloud computing projects that provide public cloud computing services for scientific users, for example Nimbus [19]. By utilising cloud computing services, the numerous capital investments in building and maintaining a supercomputing or grid computing environment for big data applications can be effectively reduced.

Despite these advantages, data security concern is still one major obstacle in migrating big data applications to cloud computing environments. For example, data in online social systems are highly privacy-sensitive; data used for scientific research often contain private information and/or unpublished results, which make them valuable intellectual properties.

When submitting tasks to the cloud, people also surrendered control over their valuable data at the same time. The convenience of cloud computing is always accompanied by the risk of data exposure, which is not the case in traditional distributed computing systems where data are stored locally.

In order to ensure data security against a malicious third party, encryption is a common choice. Fully-homomorphic encryption can save all the trouble of key management, in that it renders the encrypted dataset to be still decrypt-able with the key used for encryption even after any kind of operation has been performed on it. Unfortunately, to the best of our knowledge, developing a fully-homomorphic encryption algorithm with practically feasible time-complexity still remains an open research problem [12]. Asymmetric-key encryption does not require key exchange, but it is way too   DOI 10.1109/TrustCom.2013.65     time-consuming when employed over large datasets. In order to utilise the much faster symmetric-key encryption, Authenticated Key Exchange (AKE) scheme is a mandatory requirement -- not only for negotiating session keys used in encryption, but also for mutual authentication to deny fake-ID attacks / Man-in-the-Middle (MITM) attacks. Reducing time consumption of AKE schemes has hardly been an attractive research problem in the past. However, in cloud computing, at least thousands of virtualised server instances, i.e., virtual machines (VMs), are participating in the execution of almost every task, where the most widely-used Diffie-Hellman (DH) based AKE schemes can become very time consuming. When deploying IKE along with the execution of large-scale tasks in cloud environment, it can even take up to 76% of the total time consumed by the security system [22].

In this paper, we propose a hierarchical AKE scheme ? Cloud Background Hierarchical Key Exchange (CBHKE), in the aim of secure and efficient scheduling in cloud computing for large-scale computing tasks such as scientific applications.

Our work is based on our previously proposed scheme named Cloud Computing Background Key Exchange (CCBKE) and its predecessor, the standardised Internet Key Exchange (IKE) scheme. All these schemes belong to the DH-AKE family.

The rest of this paper is organised as follows. Section II discusses related work. Section III provides a motivating example as well as detailed analysis to our research problem.

Section IV gives the description of our CBHKE scheme in detail based on a series of notations, followed by the analysis of security and efficiency. Section V evaluates the efficiency of our scheme through experimental results. Section VI concludes our work and discusses future work.



II. RELATED WORK Nowadays, because of its outstanding cost-effectiveness  [10], cloud computing is being widely utilised for large-scale computation tasks in big data processing [6, 9] such as scientific research applications [14, 19]. Great efforts have been placed on cost-efficient scheduling for distributed computing systems including cloud computing [11, 25, 27, 28].

The work of Garg et.al [11] and Lee et.al [27] focused on efficient scheduling with low energy consumption in cloud computing and distributed systems; Yuan et.al [28] investigated the trade-off between the cost of storage and computing in cloud scheduling. However, none of their work has taken into account the additional cost in enhancing data security which is another important metric of QoS. Tang et.al [25] proposed a cost-effective security-aware scheduling algorithm for distributed systems. Although their approach achieved high efficiency by grading data security into several levels, their scheme in fact compromised security for higher efficiency, and it still suffered from the inherent cost- inefficiency of existing KE schemes. The security-aware scheduling scheme for distributed computing systems proposed by Xie et.al [26] suffered from similar problems.

Key exchange (KE) over untrusted communication environment has always been an active research topic in public-key cryptography. In [21, 29], extended security  standards were formalised and researched for key exchange schemes for the basic 2-party scenario. For efficiency, some of the most recent research on authenticated key exchange schemes focused on password-based key exchange [13, 15], which allows two parties to share a session key through exchanging a low-entropy password. Many existing key exchange schemes were trying to optimise the multi-party- same-key scenario as we do. For example, some of them focused on the scenario with users join and leave dynamically, such as [16, 30]. Kurosawa [20] and then Bellare et.al [7] studied the problem of asymmetric-key encryption in multi- user-different-data scenario with randomness reuse strategy.

This problem is essentially the same as KE in the background of cloud. Due to the low efficiency of asymmetric-key encryption over large datasets, their schemes cannot be directly applied into cloud computing environments. However, the ideas from these schemes inspired our work directly.

Internet Key Exchange (IKE) [17], as the standardised key exchange solution, has been widely adopted along with IPSec to ensure data confidentiality, integrity and authenticity while data is transferred via Internet. Its security has been formally proven [8]. In the past, we developed a key exchange scheme named CCBKE for security-aware scheduling in cloud computing [22]. When deployed in cloud, CCBKE invokes significantly lower time consumption compared to IKE, but it still takes a considerable amount of time. We observed that in CCBKE, the central cloud controller needs to generate keying materials and compute all session keys (to be used to communicate with ALL virtualised instances later on) by itself, and the computational power of intermediate control nodes are not effectively utilised. This is the main motivation of our research in this paper.



III. MOTIVATING EXAMPLE AND PROBLEM ANALYSIS  A. Motivating Example and Research Problem Big data applications such as scientific applications are  always data-intensive and time-critical. Take astrophysics research for example, Australian astrophysics researchers operate a gigantic 64-metre Parkes telescope [1] which generates a large amount of data through constant observation.

In pulsar searching workflow [28] the raw observation data are generated at a 1GB-per-second ratio. The beam file is generated for later pulsar searching through a local real-time compression operation on the raw data file. During this process, about 1 to 20GB beam file is generated from 4 to 60 minute observation. Scientists usually need to access the results as early as possible, as a late-coming result may cause an enormous waste of resources and loss of scientific discovery. Example in astrophysics is gravitational wave detection [18] which is especially time-critical. Due to its nature of real-time and streaming, delay in returning a result of a task may cause missed detection of an incoming gravitational wave. This will lead to loss of scientific discovery as the next wave would come after years. Moreover, thousands of hours of data-intensive computation was in vain, which is a terrible waste both economically and environmentally. Online web service is another example,     where user requests normally demand servers? response in a few seconds. Hence, efficiency is of extreme importance in cloud scheduling for many big data applications.

Cloud computing's unique characteristics of virtualisation, consolidation and multi-tenancy bring unpredictable challenges to data security. For example, a malicious party can easily be another legitimate user who is using the same cloud and has even more advantage for successful malicious behaviours [24]. As discussed in Section I, Data in scientific research are valuable intellectual property which can either be people?s privacy-sensitive information or directly related to scientific discovery. Therefore, we suggest that all user data always stay encrypted in cloud. Decryptions may only be applied right before data are used for task execution.

In big data applications, each interaction between users and cloud servers requires key exchange because of encryption.

As a result, a large percentage of time overall is devoted into the security system. As demonstrated in [22], the standardised IKE key exchange scheme can take up to 76% of the total time consumption in the security system (depending on the actual parameters) when the size of user datasets and the number of instances involved are large, which is why we need to improve the efficiency of key exchange schemes.

B. Problem Analysis In every KE session, a distinct session key is needed for  every virtual machine. This is because the risk of additional information being exposed against malicious users needs to be minimised. The existence of virtual machine hijacks [24] further intensifies this risk. For example, if a single session key is utilised for data encryption on 100 virtualised instances, the information on all 100 nodes will all be exposed when only one of the instances is hijacked and the key is revealed. If we use different keys for different instances, the total information leakage will be reduced by 99%. For this reason, the computation cost and time consumption of key exchange  operations in cloud are more significant than in other distributed computing systems.

Computations on server instances in key exchange processes can be completed almost instantly. Data communications in KE schemes via networking take almost no time as well because only kilobytes of data need to be transferred between the cloud controller and server instances in order to complete key exchange. Digital signatures are always necessary in key exchange schemes for identity authentication. In key exchange schemes, messages to be signed are usually of a short fixed length (typically 128 bits which is the output size of a HMAC function). In this regard, time consumption in signing and verification of messages is negligible when compared to modular exponentiations over 1024-bit keying materials related to key exchanges. Based on this view, we know that the modular exponentiations in KE operations are acting as the predominant factor in the efficiency for a distributed KE scheme.

For scheduling purposes, a large-scale cloud computing infrastructure often employs a hierarchical control structure.

Following the acronyms defined in the early Eucalyptus cloud system [23], a typical cloud computing structure may employ a CLC (cloud controller) as the interface between user and cloud, several CC (cluster controllers) for cluster control, a bunch of NC (node controllers) for virtualisation, and then virtualised instances for actual task execution. These are at least three layers for control, and the number of control layers could increase further with the scaling of the cloud environment (see Figure 1 for an example of a hybrid cloud which is consisted of multiple clouds with multiple control layers). In CCBKE[22], CLC needs to perform all the KE operations for exchanging a distinct key for each instance, while the intermediate layers are required to do nothing other than passing the messages. In this regard, the efficiency of KE will be further improved by re-designing the scheme to distribute the modular exponentiations to other control nodes.

Fig.1 An example of a hybrid cloud structure used for scientific applications

IV. CBHKE ? CLOUD BACKGROUND HIERARCHICAL KEY EXCHANGE  Before showing how the CBHKE scheme works, we first define the symbolised notations to be used for the formalised description.

A. Notations ??,? : The ? th control node (or node, for  simplicity) on layer ? . ?1,1 is the cloud controller (CLC)  ???? : Header, contains security parameter indexes  ? ??	?: Certificate request ? ??:   Certificate of node N ??	:   One-time nonce for message freshness ??:   Security associations, used in negotiating cryptographic algorithms ???:   Identity information of node N Sig?: Node ??s signature, which can be verified  using algorithms negotiated in SA and public key in ? ?  prf():   Pseudorandom function {?}? :   Encrypt message ? with session key ? ???? (?): Decrypt message ? with session key ? ?: Total number of control layers ?:    Number of nodes on the ? th layer ??,? :   Number of sub-nodes for node ? on the ?th layer ????:     Node N?s public key for KE ??? :  N?s sub-nodes (children nodes), where  ? = 1, ? , ? ??:  N?s parent node ???_???: Temporary key used by node ? to encrypt  the communications with its parent node ???_?? ??,? : Temporary key used by node N to encrypt  the communications with its ?th sub-node  B. System Setup The system chooses a large prime integer ! and select a  generator " of group #!$ . Normally ! is a Sophie Germain prime where (! % 1)/2 is also prime, so that the group &!$ has maximum resilience against square root attack. A certificate authority (CA) is needed in our security system so that communicating parties can identify each other through exchanging verifiable certificates  ? ??, although we will skip further details regarding these straightforward CA-involved operations in detailed scheme description.

C. Key Exchange This is a generalised description for a cloud  infrastructure that has ? control layers, from CLC to end NC.

Layer ? has ? nodes, namely ??,? , ? = 1, ? , ?,  ? = 1, ? , ? .

CLC is on layer 1, where 1 = 1. Let ??,? be the numbers of sub-nodes for nodes ? = 1, ? , ? on layer ?.

Overview: The scheme can be divided into two phases.

The aim of Phase 1 is for the CLC to securely deliver its secret keying material to NCs, while Phase 2 is for the actual key exchange. In Phase 2, CLC deliver to NCs interact with virtualised instances on CLC?s behalf and send back the results of KE to the CLC.

Phase 1: This phase is for KE between all control nodes from CLC (layer *1) to the ?th control layer (layer *? , i.e., NC layer). This exchanged session key will be used for encrypting the real keying material in Phase 2.

All control nodes picks their own private key +?,? and one-time nonce ??	?,? . They compute their public key for KE as follows:  ?????,? =  " +?,?  Then CLC broadcasts the very first message ??-_11,1:  ??-_11,1: ??. , ???1,1 , ?? , ????1,1  , ??	1,1  to all nodes in layer 2. ??. is a flag for message identification, indicating the request for keying material.

For the nodes ??,?   (? = 1, ? , ?) in layer *? , upon receiving message ??-_1(?%1),? from their parent-node in *?%1   (? = 2, ? , ? ), they send messages ??-_1?,? to their sub-nodes in the next layer *?+1:  ??-_1?,? : ??. , ????,?  , ?? , ?????,? , ??	?,?  Meanwhile, they respond ??-_2 to their parent node:  ??-_2?,? : ??. , ????,?  , ?? , ?????,?  , ? ??	? , ??	?,?  After receiving  ??-_1, every node in layers *2, ? , *? will know its parent node ???s public key ????? , and compute the session key for communicating with its parent:  ???_????,? = (?????) +?,? ,  where ? = 2, ? , ?; ? = 1, ? , ?; ? = 1, ? , ??,? For nodes in layer *?%1, upon receiving ??-_2 from their sub-nodes, they?ll know the public keys of their sub-nodes, namely "+?+1,? . We denote the public key of node ??,? ?s sub- nodes ??? as ??????  , ? = 1, ? , ??,? . ??,? compute the following session keys for communicating with their sub- nodes:  ???_?? ???,? ,? = 4?????? 5 +?,? ,  where ? = 1, ? , ? % 1; ? = 1, ? , ?; ? = 1, ? , ??,? For authentication, all nodes in *? (? = 1, ? , ? % 1)  broadcast ??-_3 to its sub-nodes ??? :  ??-_3?,? : ????,?  , 7????,?  , ??, ? ???,? , ? ??	???1 , Sig??,? 8???_?? ???,? ,1     || ?  || 7????,?  , ??, ? ???,? , ? ??	???? , Sig??,? 8???_?? ???,? ,?   ( ? = 1, ? , ? % 1; ? = 1, ? , ?; ? = 1, ? , ??,? ) where the structure of message for signatures is also an output of prf(), similar to IKE. All nodes on *? , (? = 2, ? , ? ) will receive this message, and respond with ??-_4?,? if signature verification is successful:  ??-_4?,? : ????,? , 7????,?  , ?? , ? ???,?  , Sig??,? 8???_????,?    ( ? = 2, ? , ?; ? = 1, ? , ?) The reason that only the receiver of ??-_3 and ??-_4  can decrypt them is that, for every parent-child node pair ?PARENT and ?CHILD , we already have:  ???_?? ??PARENT = ???_???CHILD which concludes phase 1.

Phase 2: This phase is for the eventual goal of our scheme ? KE between CLC and virtualised instances. The outcome of Phase 1 will play a vital role here.

CLC picks its secret value < as its keying material for KE with those virtualised instances. CLC encrypts < with the session key negotiated in phase 1 and broadcast the following message to the next layer:  ??-_11,1: {<||???1,1 }???_?? ??1,1,1 || ? ||{<||???1,1 }???_?? ??1,1,? 1,1  Upon receiving message ??-_1(?%1),? from their parent- nodes in *?%1   ( ? = 2, ? , ? ), the nodes in *? broadcast similar ??-_1?,? to their sub-nodes in *?+1:  ??-_1?,? : {<||????,? }???_?? ???,? ,1 || ? ||{<||????,? }???_?? ???,? ,? ?,? because the recipients can obtain  < by decrypting the received ??-_1 using its ????? ??,? ,? . For security reasons, all nodes in *2, ? , *?%1 should destroy < after sending ??-_1 in Phase 2 where they re-encrypt  < with ????? ? and send to their sub-nodes.

After these operations, once nodes on layer *? , i.e., NCs, get to know the < value. They now use this secret value to perform a 4-round CCBKE to finish the final KE:  NC-VM: ????? , ???? , "< , ??	? VM-NC: ???>?? , ??>?? , "  ?? , ??	?? , ? ??	? NC-VM: ????? ,  {???? , ???? , ? ??? , ? ??	? , Sig??}"< ?1 || ? ||{???? , ???? , ? ??? , ? ??	? , Sig??}"< ??

VM-NC: ???>?? , @??>??  , ??>??  , ? ?>??  , Sig>?? B"< ??  The final session key for data encryption is "<?? where ? = 1, ? , ? . After this step, not only ? but all ??,? virtualised instances will have the desired session key for data encryption/decryption.

Now all virtualised instances have exchanged a key with their control nodes. For each NC, i.e. ??,? (? = 1, ? , ? ), they combine and encrypt the final session keys in this format:  ??-_2?,? :{"<?1 || ? ||" <?? ?,? }???_????,?  and send it to its upper level. Then, nodes in every level from *? , ? = 2, ? , ? % 1 compute and send the following message to their parent nodes, after receiving from their sub-nodes:  ??-_2?,? : {??????_?? ??i,? ,1 (??-_2??+1,1 )|| ?  ||??????_?? ??i,? ,? ?,? F??-_2??+1,? ?,? G}???_????,? After this layer-by-layer action, CLC, i.e., ?1,1, will know the session keys "<?? that has been negotiated with all virtualised instances, thereby concludes the KE scheme. The task data stored at CLC can now be split, encrypted and distributed to the virtualised instances for execution. After the execution, the server instances may follow an inversed procedure to exchange session keys with CLC and send back the encrypted results.

D. Security Analysis: The security of our scheme is analysed in Dolev-Yao?s  threat model with a bit extension. As we are dealing with communication security only, all the data stored on CLC and intermediate control nodes are assumed safe against the adversary in this model. This is a practical assumption because usually the control nodes are not directly exposed to users and the open network environment, which renders them less vulnerable than the processing servers and virtualised instances. The abilities of the adversaries, or attackers, are defined as follows: Definition 1 (attackers): A cloud outside attacker ?? aims to retrieve the session keys in exchange. ?? can access, intercept or modify any data in transmission, but cannot decrypt any cipher text without the corresponding key or secret keying material; a cloud inside attacker ?? not only has the same ability as ?? , but also can be authenticated by the cloud as a legitimate server instance. However, ?? has no access to other instances or controllers or any of their secret keys. ?? aims to steal data of other users of the same cloud.

We gave a security proof to CCBKE in [22], and had the following theorems: Theorem 1: A cloud outside attacker ?? cannot retrieve any exchanged session key "+J? in CCBKE in polynomial time.

Theorem 2: Assume ? = "+J? is the session key negotiated between a cloud inside attacker ?? and CLC. ?? cannot retrieve in polynomial time any session key "+J? other than ?, unless a negligible probability in CCBKE.

Proofs: See [22].

Derived from these theorems, we now have the following lemma: Lemma 1: The adversaries defined above have negligible chance of breaking the CBHKE scheme. Specifically, a cloud outside attacker ?? cannot retrieve any session key, while a cloud inside attacker ?? cannot retrieve any session key other than her/his own.

Proof: The key exchange procedures for each node and its sub-nodes in both CBHKE Phase 1 and Phase 2 are actually minimised and iterative CCBKE processes. As CCBKE is secure against cloud inside and outside attackers according to Theorems 1 and 2, all the KE operations in CBHKE scheme are secure against these attackers. Therefore, all the encrypted messages in our CBHKE scheme are securely encrypted. Hence, we can say that our new CBHKE scheme is secure against attackers from either outside or inside the cloud, defined in Definition 1.

In addition, if we use different parameters and keying materials for every execution and re-keying in CBHKE scheme, it will also hold perfect forward security just the same as in CCBKE and IKE.

E. Efficiency Analysis: As analysed in section II, the majority of time  consumption is from modular exponentiations, e.g., "+ mod! . Compared to them, the symmetric-key encryptions and decryptions in phase 2 take virtually no time because those concatenated keying materials to be encrypted are only several KBs long. Hence, we will analyse the efficiency advantage of our new CBHKE scheme by calculating the total number of modular exponentiations.

Let ?? = max1K? K?  @??,? B  be the maximum number of sub-nodes for each node on level ?.  Starting from  ?1 = 2 , we have  ? = M ??%1,?  ?%1  ? =1  K ?%1??%1 , ? = 2, ? , ?  then the total number of VM instances is O ??,? ? ? =1 , with at  most ?? VMs controlled by one NC. Assume the maximum time consumption of one modular exponentiations on one node is ??Q+ , then the total time consumption of CCBKE is close to FO ??,?  ? ? =1 G??Q+ given that VM hold similar  computational ability. In CBHKE, the upper bound of the total time consumption in KE modular exponentiations in one round should be 4O ????=1 5??Q+ . Given the fact that each NC can launch and control plenty of VMs (much more  than the number of control nodes controlled by a higher- level control node), the following inequality will hold:  ?? > M ??  ?%1  ?=1 which is the case of both of our experimental environments.

Besides, because we have ? V 2 (otherwise CBHKE will have the exact same efficiency as CCBKE), we will have  M ??,?  ?  ? =1  V 2??  if the NCs have similar computational capability that can launch similar amount of VMs. Therefore:  M ??,?  ?  ? =1  V 2?? > ?? + WM ??  ?%1  ?=1  X = M ??  ?  ?=1 then we have  YM ??,?  ?  ? =1  Z ??Q+ > WM ??  ?  ?=1  X ??Q+  which means in practical cloud settings, CBHKE always has increased efficiency compared with CCBKE. In fact, in most cases we have:  ?? >> M ??  ?%1  ?=1 then  M ??,?  ?  ? =1  [ ? M ??  ?  ?=1 In this case, the time consumption of CBHKE is even only a fraction of CCBKE. Although IKE, CBHKE and CCBKE are all of linear time complexity to the scale of the task, the efficiency advantage of CBHKE is nonetheless tremendous.



V. EXPERIMENT AND EVALUATION  A. Experiment Environment We conducted our experiments on U-Cloud (see Fig 2) -  - a cloud computing environment located in University  Fig. 2 U-Cloud structure     of Technology, Sydney (UTS). The computing facilities of this system are located in several labs in the Faculty of Engineering and IT, UTS. On top of hardware and Linux OS, We installed KVM Hypervisor [3] which virtualises the infrastructure and allows it to provide unified computing and storage resources. Upon virtualised data centres, Hadoop [2] is installed to facilitate the MapReduce programming model and distributed file system. Moreover, we installed OpenStack open source cloud platform [5] which is responsible for global management, resource scheduling, task distribution and interaction with users.

B. Experiment Process We tested our scheme under two differently structured  cloud instantiations of U-Cloud. The first one have 3 control layers and 4 NCs in total, while the second one have 4 control layers and 6 NCs in total. The layouts of the two experimental cloud scenarios are shown in Figure 3.

We implemented CBHKE, CCBKE and IKE schemes using C++ with MIRACL[4] cryptography library, and ran on our U-Cloud environment. The numbers of instances launched by each NC are 5, 10, 15, ? , 50. On each of the cloud scenario, we repeatedly ran each of the key exchange scheme 20 times to simulate a big computation task with 20 CLC-VM interactions.

U-Cloud scenario A  U-Cloud scenario B  Fig.3 Structures of two cloud scenarios on U-Cloud for experiments  C. Experiment Results Our experimental results (average for 20 runs) are  shown in Figure 4. The results match the analysis in section IV - E. Through these results we can see that compared to IKE in U-Cloud, the total time consumption of CBHKE in KE is decreased by an average of 85.9% and 89.8% in scenarios A and B, respectively. This efficiency advantage of CBHKE when compared to CCBKE in the two scenarios is 70.96% (max: 75.9%; min: 58.9%) and 77.85% (max: 82.4%; min: 61.3%), respectively. This is a significant improvement in efficiency without compromising the level of security. Also, the results match our efficiency analysis in section IV.E.



VI. CONCLUSION AND FUTURE WORK In this paper we have proposed a novel hierarchical key  exchange scheme, namely Cloud Background Hierarchical Key Exchange (CBHKE). Based on our previous work, CBHKE aimed at providing secure and more efficient scheduling for cloud computing environment. In our new scheme, we have designed a two-phase layer-by-layer iterative strategy to reduce the overall time consumption in authenticated key exchange (AKE) without sacrificing the level of data security. Both theoretical analysis and experimental results have demonstrated that when deployed in cloud computing environment, the proposed scheme was significantly much more efficient than its predecessors CCBKE and IKE.

Results in scenario A  Results in scenario B  Fig.4 Efficiency comparison of CBHKE, CCBKE and IKE in the two cloud scenarios     Although the efficiency of security-aware scheduling in cloud computing can greatly benefit from an efficient key exchange (KE) scheme such as CBHKE, current encryption algorithms (even the fastest symmetric-key encryptions) are still not fast enough when encrypting large datasets, which is why currently another large research community is focusing on another way around -- to reduce encryption usage. Research on an efficient and secure encryption algorithm for cloud and other large-scale distributed computing systems is still an open research problem.

