

Proceedings of the 8th  World Congress on Intelligent Control and Automation July 6-9 2010, Jinan, China                                                           Share-Inherit: A novel approach for mining frequent patterns*    Xiaoyong Lin and Qunxiong Zhu College of information Science and Technology  Beijing University of Chemical Technology Beijing 100029, P.R. China  {linxy & zhuqx }@mail.buct.edu.cn    * This work is partially supported by the Fundamental Research Funds for the Central Universities #QN0906.

Abstract - Mining frequent patterns has attracted considerable attention in the data mining field. Most of the current studies adopt the pattern growth approach of divide-and- conquer. However, as the mining process is completely split into parts, all relevant algorithms still encounter some performance bottlenecks. In this study, we propose a new data structure, Share-struct, which is derived but obviously different from FP- tree. Then we developed an efficient algorithm, Share-Inherit, for mining all frequent patterns. Based on the Share-struct, Share- Inherit provides a way to share most of the results from the previous mining process instead of separating them distinctively, thereby dramatically reducing the cost of traversing FP-tree and significantly improving the performance of algorithms based on pattern growth. Furthermore, various optimization techniques used in Share-Inherit sufficiently improve the algorithm. The experimental results show that Share-Inherit algorithm not only performs better than the existing algorithms using pattern growth, but also improves them by incorporating Share-Inherit strategy.

Index Terms - data mining, association rules mining, frequent patterns mining, pattern growth, share-inherit.



I.  INTRODUCTION  Recently, data mining has received a great amount of attention in database research. The attention is motivated by the large amount of data generated by business in their day to day operation. For instance, supermarkets store electronic records of millions of receipts, banks and credit card companies maintain extensive transaction records, and many factories collect a lot of flow parameters. The goal in data mining is to analyze these large amounts of data and discover patterns, rules, and trends that are useful for decision support.

Mining association rules, an important subfield of data mining, was firstly introduced by Agrawal et al [1]. So far, most of the research has been focused on designing fast algorithms for it [2-16, 19-29]. The problem of mining all association rules can be decomposed into two sub problems.

First, frequent patterns, all patterns that have support above a minimum support threshold defined by the user, are mined.

Second, rules are generated based on the frequent patterns already mined. Compared to the first problem, the solution for the second one is rather straightforward [2].

According to many studies on mining association rules, the algorithms for mining frequent patterns from databases can  be separated into two classes, candidate set generation-and- test and pattern growth.

Some of the previous studies, such as Apriori [1], Partition [25], Sampling [26], DIC [27], DHP [28], Apriori- Brave [29], adopt the candidate set generation-and-test approach, which is based on an anti-monotone Apriori property [1]: if any pattern of length k is not frequent in the database, its super-pattern of length (k+1) can never be frequent. All algorithms using this property achieve good performance by reducing the size of candidate sets. However, candidate set generation is still costly, especially when there are a large number of frequent patterns or long frequent patterns. On the other hand, it is expensive to repeatedly scan the database and check a large set of candidates through pattern matching, and this is especially true for mining long patterns [2].

In contrast to a large amount of candidate set generation techniques, the pattern growth algorithms, such as FP-Growth [2], OP [4], TD- FP-Growth [5], CT-ITL [7], H-Mine [8], do not need to generate candidates due to their complex hyper structures (data storage structures used in pattern growth algorithms)  [17]. At the same time, the pattern growth method is based on a divide-and-conquer method. It recursively splits the database into sub-databases according to the frequent patterns found and searches for local frequent patterns to assemble longer global ones (i.e. the mining task is decomposed into a set of smaller tasks.). Almost all algorithms that adopt pattern growth achieve better performance than candidate set generation ones by rejecting candidate set generation, reducing the number of scanned original database and decomposing the whole mining process into smaller ones.

However, all such methods still encounter some performance bottlenecks, as the exclusive division of mining process will cause repeated traversal and computation.

The main contribution of this paper is to present a novel data mining approach for mining frequent patterns in large databases. First, we propose a new data structure, Share-struct, which is derived but obviously different from FP-tree. A Share-table is built instead of a Header table. Moreover, in Share-struct, a FP-tree is more condensed and stable. Second, Share-tables are created dynamically in the mining process.

They are recycled to maintain the useful things from previous steps so that the following steps can share most of the results from previous computation. This is more significant than     exclusive divide-and-conquer pattern growth method. Third, several optimization techniques incorporated with Share- Inherit speed up the algorithm and save a lot of space. Finally, share technique can be combined with the pattern growth approach, greatly improving performance efficiency.

The experimental results show that the Share-Inherit algorithm not only outperforms previously algorithms but also improves them by incorporating Share-Inherit strategy.

The rest of the paper is organized as follows. Section 2 introduces the background which formally states the problem and reviews the related work. Section 3 proposes the new data structure and algorithm. Examples and analysis are given at the same time. Section 4 presents the performance study and discussion. Finally, Section 5 lists the conclusion and the future work.



II.  BACKGROUND  A. Problem statement In this subsection, we introduce the definition of frequent pattern mining and show two typical approaches for this task.

1)  Frequent patterns mining Let I={x1, x2, x3 ? xn} be a set of items. An itemset X, also called a pattern, is a subset of I and is denoted by X ? I.

A transaction TX = (TID, X) is a pair, where X is a pattern and TID is its unique identifier. A transaction TX is said to contain TY if and only if Y ? X. A transaction database, named DB, is a set of transactions. The number of transactions in DB that contain X is called the support of X. A pattern X is a frequent pattern, if and only if its support is larger than or equal to s, where s is a threshold called minimum support. The problem of frequent patterns mining is to find the complete set of frequent patterns in a given transaction database with respect to a certain support threshold s.

2)  Candidate set generation approach This approach is based on the anti-monotone Apriori property: if any pattern of length k is not frequent in the database, its super-pattern of length (k+1) can never be frequent. Namely, all subsets of a frequent pattern must be frequent. The essential idea is to iteratively generate the set of candidate patterns of length (k+1) from the set of frequent patterns of length k (k ? 1) and then scan the database once to check their corresponding occurrence frequencies [2].

3) Pattern growth approach In contrast to the candidate set generation technique, pattern growth approach eliminates the need for candidate set generation according to the frequent patterns found and searches for local frequent patterns to assemble longer global ones. By projecting the database into a more compressed hyper structure that fits within the memory, it does not need to scan a database multiple times.



III.  SHARE-INHERIT ALGORITHM FOR MINING FREQUENT PATTERNS  In this section, we first present the definition of Share- struct, upon which Share-Inherit is based. At the same time, we give an example of constructing a Share-struct. Then, we  will propose the Share-Inherit algorithm for mining the complete set of frequent patterns and give the analysis.

A. Share-struct: Design and construction 1). It consists of a FP-tree and Share-tables.

2). For each node in the FP-tree of Share-struct, the link fields for parent and next are redundant, so they are removed to save space, and once the tree is built, it will never be changed during the whole mining process, making the FP-tree more compressed and stable.

3). Each entry in a Share-table consists of four fields: item-name, local-count, new, and old, where item-name represents an item, local-count records the local support of an item in a given prefix, new field links the nodes not considered in the tree, and old field points to the nodes traversed or a Share-table constructed.

Based on the definition mentioned above, we have the following Share-struct construction algorithm.

Algorithm 1 Share-struct-Construction Input: a database, DB, and a minimum support threshold, ? Output: a Share-struct, S?  Method: Call Share-struct-Construction (DB, ?, S?) Procedure Share-struct-Construction (DB,?, S? ) { 1) L1={The set of all frequent items}; 2) sort items in L1 in support descending order; 3) create a FP-tree, T;  //parent and next fields are removed 4) call Initialize (S?, T, ?); } The procedure Initialize is shown in the following.

Procedure Initialize (S , new, old) { 1) f or each child ci of new/old do begin 2)  add ci to the relevant new field in S ; 3)  ci.local-count= ci.local-count + ci.count ; 4) end } Example 1. Table I shows the example transaction database  [2]. Let the minimum support threshold be 2.

As only the frequent items will play a role in the frequent pattern mining, it is necessary to scan the DB once to identify the set of frequent items (L1). In order to obtain high compactness, we order L1 in support descending order (L1={f:4, c:4, a:3, b:3, m:3, p:3, l:2, o:2}). Then, we scan the DB for a second time to construct the FP-tree. The construction algorithm of a FP-tree is proposed in FP-Growth [2]. Readers are referred to the cited paper for details.

TABLE I A TRANSACTION DATABASE AS RUNNING EXAMPLE, DB  TID Items Bought (Ordered) Frequent Items 100 f, a, c, d, g, i, m, p f, c, a, m, p 200 a, b, c, f, l, m, o f, c, a, b, m, l, o 300 b, f, h, j, o f, b, o 400 b, c, k, s, p c, b, p 500 a, f, c, e, l, p, m, n f, c, a, m, p, l  The FP-tree in a Share-struct is almost the same as the one in FP-Growth [2] except for each note?s parent and next fields. They are redundant in Share-struct, so they are     removed. Afterwards, we create the first Share-table S? according to L1. First, |S?| = |L1| and all fields except item- name are set to 0 or null, then we initialize it by adding root?s children (?,?) to the new fields of f and c entries in S? and modifying the relevant local-count fields to 4 and 1 respectively. Fig.1(a) shows the original Share-struct (The FP- tree with Share-table S?) after S? is initialized. For the convenience of later discussion, the number before each node in the FP-tree represents its address in memory and all blank grids in S? indicate 0 or null.

B. Share-Inherit algorithm In this subsection, we will develop an efficient algorithm for mining all frequent patterns and study how to mine the complete information stored in a Share-struct using an example.

Algorithm 2 Share-Inherit Input:  S?, the Share-struct constructed based on Algorithm  1, and s, the minimum support threshold Output:  The complete set of frequent patterns Method: Call Share-Inherit (S?,?, s) Procedure Share-Inherit (S? ,?, s) { 1 for each entry si in S? 2   if (si.local-count<s and si->new!=NULL) 3     add all si ->new?s children to the new fields of relevant entries in S?; 4   else  =??si; -SD = ?-SD; 5     if (si ->new != NULL) 6       if si is the only active entry 7         ?-SD=?-SD?si; 8         add all children of si to relevant entries in S?; 9         si ->old= S?; 10      else ?-Postfix = ?-Postfix ?si; 11        if (si ->old == S?) 12          call Inherit(si, S ); 13        else call Initialize (S , si->new, si->old); 14        if (si ->old == NULL) 15          flag_upload =TRUE; 16        si->old = S ; 17        call Share-Inherit (S , , s); 18        if (flag_upload ==TRUE) 19          call Upload (S?, S );` 20    else if (si ->old ? S?) 21      -SD= -SD?the items that appear after  in ?-SD 22      -Postfix=the items that appear after  in ?-Postfix 23      for each pi in -Postfix 24         = ?pi; 25        -SD = the items that appear before pi in -SD 26        call Share-Inherit (pi->old, , s); 27      call Generate-FP ( , -SD, -Postfix); 28 call Generate-FP (?,?-SD, ?-Postfix); } //the end of Share-Inherit   (a) The original Share-struct   Fig.1. the original Share-struct and the steps of S??s change  The procedures Inherit, Upload and Generate-FP are shown in the following.

Procedure Inherit (s, S ) { if s->old can be released then //memory management S  = s->old; else create a new Share-table S  by inheriting s->old; call Initialize (S , s->new, ?); } Procedure Upload (S?, S ) { f or each entry si in S upload all new and old fields in S  to old fields in S?; add si.local-count in S  to si.local-count in S?; } Procedure Generate-FP (?,?-SD, ?-Postfix) { for each nonempty combination  of the items in ?-SD generate pattern ??  with support = minimum support of items in it.

for each item pi in ?-Postfix for each combination  of the items (which appear before pi) in ?-SD generate pattern ??  ? pi with support = minimum support of items in it.

}  C. Analysis Line (1)-(26) consider each entry si in S?. if si.local-count in S? is less than the minimum support threshold,  Share-Inherit does not create a Share-table for it and only contributes the children of its mew field to its little siblings for the following mining process. Thus we have Line (2)-(3). Otherwise there is a new frequent prefix ? (Line (4)). There are two possible results according to the status of si->new (Line (5) and (19)).

Line (6)-(9). Line (10) collects the postfix of ?. Line (11)-(12) and procedure Inherit guarantee that the inheriting approach can improve the performance sufficiently. The Line (13) deals     with a local frequent entry which has nodes not considered in new and old fields. Suppose there is a local frequent entry si with empty old field, we have Line (14), (17) (18) and procedure Upload to save the computation results. Line (15)- (16) recursively call algorithm. When ? perfectly shares S?, line (20)-(26) can get all frequent patterns with prefix ? by sharing S?. Finally, property 6 shows a way to exponentially generate frequent patterns, line (27), (28) and procedure Generate-FP get the complete result.



IV.  PERFORMANCE STUDY  To evaluate the efficiency and effectiveness of our algorithm Share-Inherit (SI for short), we have done extensive experiments on various kinds of datasets with different features. We compare SI with some previous known algorithms, such as FP-Growth [2], OP [4], and CT-ITL [7].

The experiments are based on a 2.4GMHz Pentium IV PC with 512MB main memory and 60 GB hard driver, running on Microsoft Windows 2000 Server. All the programs are written in Microsoft/Visual C++6.0.

A. Datasets and characteristics The basic characteristics of datasets used in our experiments are listed in Table II. The Chess dataset is derived from the steps of chess games. Each transaction in Connect contains legal 8-ply positions in the connect game where no player wins and the next move is not forced. All of them are derived from Irvine Machine Learning Database Repository.

Pumsb* contains census data PUMS (Public Use Microdata Samples). Each transaction represents the results of a census questionnaire, including the age, tax-filing status, marital status, income, gender, veteran status, and location of respondent?s residence. In Pumsb* all items with 80% or more support in the original PUMS dataset are deleted.

B. Experimental results In this subsection, we compare the performance of Share- Inherit with FP-Growth, OP, and CT-ITL. The measured performance is algorithms? execution time on the datasets with different minimum support threshold. The execution time only includes the disk reading time (scan datasets) and CPU time, not disk writing time (output frequent patterns). It is enough to reduce the influence of different speed of disk writing.

Figure 2 through 5 show the performance curves of the four algorithms on three datasets respectively. We can see that the Share-Inherit algorithm outperforms the other three algorithms on all datasets.

On Chess, SI is superior to other three algorithms. When the support threshold decreases less than 60%, there is tremendous gap of the performance. When the support threshold is as low as 35%, SI requires only 11 seconds, whereas OP, FP-Growth, CT-ITL require 67, 97 and 145 seconds respectively. Fig. 2 shows that the ranking of algorithms on Chess is SI > OP > FP-Growth > CT-ITL.

As shown in Fig. 3, on Connect, the algorithms? ranking is also SI > OP > FP-Growth > CT-ITL. The execution time of OP and FP-Growth are basically the same, but shorter than CT-ITL. SI is much better than the other three algorithms, and the performance gap becomes significant when the minimum  support threshold drops below 60%. For example, SI uses 70 seconds at the support level of 35%, while OP, FP-Growth and CT-ITL finish in 193, 233 and 373 seconds respectively.

For the Pumsb*, Fig. 4 shows that the execution time of CT-ITL and FP-Growth are in the same order. SI and OP have almost the same execution time, but less than CT-ITL and FP- Growth. When the support threshold is over 22.5%, SI outperforms other three algorithms. However, SI is inferior to OP if the support threshold is less than or equal to 22.5%. The reason is as follows: SI is not good at dealing with many global frequent items. When the support threshold is 22.5% on Pumsb*, there are 81 global frequent items. They result in a lot of long Share-tables which are shared by few frequent patterns.

To improve the performance, we take the hybrid strategy for SI and other algorithms. For example, we improve the OP by incorporating SI in. Fig. 5 shows the execution time of SI, OP and SI&OP with the support threshold between 20% and 21%. We can see that SI improves the OP by incorporating Share-Inherit strategy in it.

TABLE II THE CHARACTERISTICS OF TEST DATASETS  20 30 40 50 60 70 80         SI OP FP-Growth CT-ITL  Ti m  e (S  ec on  ds )  Support threshod (%)   Fig. 2. Comparison on Chess  20 30 40 50 60 70 80            SI OP FP-Growth CT-ITL  Ti m  e (S  ec on  ds )  Support threshold (%)   Fig. 3. Comparison on Connect  Dataset Number of Transaction  Number of Items  Average Trans Size  Chess 3,196 75 37 Connect 67,557 129 43 Pumsb* 49,046 2,087 50     20 22 24 26 28 30           SI OP FP-Growth CT-ITL  Ti m  e (S  ec on  ds )  Support threshold (%)   Fig. 4. Comparison on Pumsb*  20.0 20.2 20.4 20.6 20.8 21.0            SI OP SI&OP  Ti m  e (S  ec on  ds )  Support threshold   Fig. 5. Comparison among SI, OP, and SI&OP on Pumsb*  C. Discussion As shown in figure 2 through 5, on several typical datasets and support levels, Share and Inherit approach makes Share-Inherit algorithm outperform other algorithms which adopts an absolute divide-and-rule pattern growth approach.

The Share-tables maintain the useful information for the following mining processes, which dramatically reduce the need for traversing FP-tree. Although Share-Inherit algorithm is not good when the number of global frequent items is significantly higher, hybrid techniques can be easily incorporated.



V.  CONCLUSION AND FUTURE WORK  We have proposed a new data structure, Share-struct, which is derived but obviously different from FP-tree. It is used for storing compressed information about frequent patterns. Then we developed an algorithm, Share-Inherit, for efficiently mining frequent patterns.

There are several advantages of Share-Inherit over other algorithms: (1) It uses Share-Inherit strategy to maintain useful information for the following mining processes, so repeated traversals on FP-tree are largely reduced. (2) It exponentially generates frequent patterns, which also avoids costly candidate set generation and test. (3) It gives a way to improve all algorithms which adopt the pattern growth approach.

We have implemented the Share-Inherit algorithm, studied its performance in comparison with several well- known algorithms in several databases. The experimental  results show that Share-Inherit algorithm performs better than the existing algorithms.

Recently, there have been some interesting studies about mining frequent patterns in databases which allow adding new data or deleting old data. The extension of the Share-Inherit technique, for maintenance of the already mined frequent patterns when updating databases, is an interesting topic for future research.

