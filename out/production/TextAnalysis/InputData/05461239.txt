

Abstract: Efficiency is quite important for an algorithm to find frequent patterns from a large database. A new algorithm called LogECLAT algorithm which is enlightened by ECLAT algorithm uses special candidates to find frequent patterns from a continually updating database containing essential information about frequent patterns.  LogECLAT algorithm can find several k-itemsets in one time of scanning database and thus the times of establishing new databases is reduced. For Apriori algorithm is widely applied to many fields, the comparison of performance is between LogECLAT algorithm and Apriori algorithm. This paper proves that LogECLAT algorithm can find frequent patterns correctly and performs better than Apriori algorithm theoretically and practically. The good performance of LogECLAT algorithm indicates that by using the special candidates can reduce the times of producing new database, and in this way efficiency of finding frequent patterns improves.

Key Words: Data mining, association rules, ECLAT algorithm, Apriori algorithm

I. INTRODUCTION Online shopping is quite popular nowadays, for the commodities sold online are usually cheaper than those sold by stores, and online markets also provide a wider variety of products for customers to choose from. Although shop keepers always provide customers with some detailed information about a product such as photos shot by cameras from most angles, it is still difficult for customers to make a decision on purchasing products. And the database of an online market is so huge that customers may lose patient in searching appropriate goods from thousands of similar products. So it is very important for a customer to get recommendations from other customers.

Traditionally goods which sell well in the recent quarter are recommended to customers. Such a recommendation does not always satisfy customers? need exactly, for people who do the same kind of job or live in the same town always have a similar purchasing preference, and in this way a best sold product is not always the most suitable product to be recommended for a certain customer. Data mining can find the highest possibility product for a customer to purchase by making full use of the customer?s purchasing preference.

The first algorithm mining association rule was proposed by Agrawal, Imielinski, and Swami ]1[ in 1993. Apriori algorithm, which is accepted as the fundamental algorithm of finding frequent patterns was presented by Agrawal and Srikant ]2[ .

Then Paul W.Purdom, Dirk Van Gucht and Dennis P.Groth ]3[ analyze the performance of Apriori algorithm by using mathematical and experimental method. ECLAT (Equivalence CLASS Transformation) algorithm which is an algorithm derived from Apriori algorithm was developed by Zaki ]4[ .

Another frequent itemset mining method called FP-growth algorithm was raised as an alternative in contrast to the Apriori-based approach. FP-growth algorithm, a pattern-growth approach for mining frequent itemsets without candidate generation, was presented by Han, Pei, and Yin ]5[ .

Most algorithms raised in the field of association rule are enlightened by either Apriori algorithm or FP-growth algorithm.

LogECLAT algorithm proposed in this paper is enlightened by ECLAT algorithm and the algorithm shares the similar theoretical base with Apriori algorithm.

ECLAT algorithm and its problems will be introduced in chapter 2. And in chapter 3, the correctness of LogECLAT algorithm will be proved, the implementation of the algorithm is presented, and the result of the comparison between Apriori algorithm and LogECLAT algorithm will also be revealed. And the final conclusion is drawn in chapter 4.



II. ECLAT ALGORITHM AND ITS DEFECTS ECLAT algorithm uses candidates to explore frequent patterns from a continually updating database. ECLAT algorithm derives from Apriori algorithm, so both two algorithms share the same theoretical base? a subset of a frequent pattern can be a frequent pattern. And the only difference between two algorithms is that Apriori scan the original database, while ECLAT algorithm scans a continually updating database and then updates the database.

The detailed procedure of ECLAT algorithm is as follows: ECLAT algorithm employs an iterative approach known as level-wise search, where k-itemsets are used to explore (k+1)-itemsets. Firstly, the set of frequent 1-itemsets is found by scanning the database to accumulate the count for each item, and collecting those items which satisfy minimum support, denoted 1L .And then update the database as following principle: for every itemset in 1L , if an itemset can be found in a certain TID, then denote the TID to the itemset. Secondly, produce candidates from 1L , and then use candidates to search updated database to find 2L . And update the database according to 2L  .Continue the procedure for 2L  to find 3L  until no more frequent patterns can be found. The detailed procedure of ECLAT algorithm is encoded as pseudocode in a book named Data Mining, Concepts and Techniques ]6[ .

Although ECLAT algorithm solves the problem that Apriori algorithm has done too much unnecessary scanning, updating the database is also a huge project. In the worst situation, updating the database consumes no less time than scanning the original database. However, updating the database in most time is not quite unnecessary, if a candidate is split in a proper manner. For example, to accumulate the count of 4-itemset {I1, I2, I4, I6}, ECLAT algorithm may count the number of TIDs which both exist in 3-itemsets {I1, I2, I4} and {I2, I4, I6}.

However, there is another way to determine whether 4-itemsets {I1, I2, I4, I6} is a frequent pattern. 4-itemset {I1, I2, I4, I6} can also be split in two 2-itemsets {I1, I2} and {I4, I6}. In this way, it is not necessary to update database for 3-itemset. Although some TIDs can be excluded by updating the database of 3-itemset, updating a database always cost more time than avoiding unnecessary scanning. Therefore if proper split manner is used, the performance of finding frequent patterns can be improved.



III. LOGECLAT ALGORITHM  A. Theoretical support for LogECLAT algorithm  In order to find frequent patterns ranging from 1+kL to kL2 , LogECLAT algorithm uses candidates selected from combinations which are produced by every two different itemsets in kL to scan database kD .The following part is to explain why LogECLAT algorithm can find all the frequent patterns ranging from 1+kL to kL2 .

To prove the fact that LogECLAT algorithm can find frequent patterns correctly, two statements as follows should be true: The first fact is that the combinations used by LogECLAT algorithm to scan database can be one of i-itemset iL ( kik 21 ??+ ). For two itemsets are different and one itemset is composed of k items, therefore in one itemset there are j ( kj ??1 ) items which is different from the other itemset and the combination of two different k-itemsets is composed of i ( kik 21 ??+ ) items. And Frequent patterns have a property, that is? ? if an itemset is a frequent pattern, its subset must be frequent patterns. In this way, this fact is well proved.

The second fact is that any combinations of items which are not produced by LogECLAT algorithm can not be frequent patterns.

For a combination of items which is not a frequent pattern, its subset can not be frequent patterns. Apparently, those unqualified combinations of items are the subset of combinations of items which are not frequent patterns, and none of frequent patterns will be missed.

From two facts above, it is easy to get the conclusion that LogECLAT algorithm can find all the frequent patterns correctly.

B. The implementation of LogECLAT algorithm  The procedure to implement LogECLAT algorithm is as follows: (a) Create a new database denoted 1D  to store TIDs for each item in database of transactions denoted D. Scan database D, for every item in database D, records corresponding TID for the item to 1D  and increments the count for the item. Collect those items which satisfy minimum support, denoted 1L , and get rid of all the recordings of TIDs not related to item in 1L  from 1D .

(b) Scan database iD to get frequent patterns from 1+iL to iL2 : Combine every different two i-itemset iL , and find which combinations should be used to scan database iD , and denote those combinations as candidates. For a combination 3I produced by two i-itemsets each denoted  1I and 2I  , and 3I  is composed of n ( nni 21 ??+ ) items, only two requirements are met, 3I  would be used to scan database iD . The two requirements are if numbers are applied to stand for every item, then every item which belongs to the set of the smallest in ? items in 1I   is smaller than any item in 2I , and every item which belongs to the largest ni ?2  items in 1I can also be found in the set of the smallest ni ?2 items in 2I .And in this way, redundant combinations can be avoided to scan database iD .

(c) Create a new database denoted iD2  to hold TIDs for 2k-itemset. Scan database iD  by using candidates which are produced by step (b). If Itemset 3I above is one of such combinations, then different actions should be done according to the number of items which compose 3I . If 3I is made up of i2  different items, records corresponding TIDs to iD2 and  accumulates the count of 3I from iD . If 3I  does not satisfy minimum support, eliminate all the recordings of 3I in iD2 .While if 3I  is made up of j ( nji 21 <?+ ) items, just accumulates the count of 3I . And for every candidate which satisfies minimum support, add the combination to corresponding frequent patterns which are made up of the same number of items with the candidate, thus frequent patterns from  1+iL to iL2 are found.

(d) If there are no itemsets in iL2 , that means all frequent patterns have found, so terminate the algorithm. Or back to do step b and c recursively, until the requirement of terminating the algorithm in step d is met.

C. Pseudocode of LogECLAT algorithm  Input: D, a database of transactions Min_sup, the minimum support count threshold Output: L, frequent itemsets in D Method: Allocate memory for database 1D ;  1L = find_frequent_1-itemsets (D);  1D = Recording_of_TID ( 1L , D);  i=1; //i denoted to be the times of scanning database  While ( iL ) {  iLI ?1 ;  iLI ?2 ;  213 IIitemI ??= ;  Length=number_of_item ( 3I );  Scan_flag=continue_to_scan ( 1I , 2I ,length,i); If (Scan_flag) { If (Length=2*i) {  iD2 += Recording_of_TID ( 3I , iD );  If ( sup_ __  ),( 3 Min nstransactioofnumber  DIcount i ? ) iL2 += 3I ;  Else iD2 -= Recording_of_TID ( 3I , iD ); }  Else If ( sup_ __  ),( 3 Min nstransactioofnumber  DIcount i ? ) lengthL += 3I ;  } i=i*2; }  Program continue_to_scan: For (j=0; j<length-i; ++j) If ( ]0[][ 21 IjI ? ) return false; For (k=0; k<i-j; ++k) If ( ][]![ 21 kIjkI =+ ) return false; Return true;  D. Example of LogECLAT algorithm  TID is denoted to be the serial number of transactions. There are four transactions and they are denoted T100, T200, T300 and  T400.ITEM is the name of commodities. Seven items which are A, B, C, D, E, F and H exist in the database. And the value of min_sup (minimum support? is 0.75, so only if an itemset appears at least three times in the database D (table ? ), minimum support is satisfied.

TABLE ? DATABASE D TID ITEM T100 A,B,D,F,H T200 A,C,D,E,F T300 B,D,E,F,H T400 B,D,E,F  In the first time of scanning database D, LogECLAT algorithm collects the count of items (table ?) and adds corresponding recordings for every item in database D to a new database 1D .

TABLE ? COUNT FOR EACH ITEM  ITEM count A 2 B 3 C 1 D 4 E 3 F 4 H 2  Compare the count of each item (table ? ) with minimum support, and1-itemset 1L  (table ?) is produced. According to the item in 1L , database 1D  removes unnecessary recordings, and in this way database 1D is formed (table ?).

TABLE ? RESULT OF THE FIRST SCAN  1L  count B 3 D 4 E 3 F 4  TABLE ?  NEW DATABASE 1D  ITEM recording B T100,T300,T400 D T100,T200,T300,T400 E T200,T300,T400 F T100,T200,T300,T400  Before the second time of scanning database, LogECLAT algorithm uses a program to select which combination (table ?) should be used to scan database 1D .

TABLE ? PRODUCING THE COMBINATION  1I  2I  3I B D BD       B E BE B F BF D E DE D F DF E F EF  LogECLAT algorithm gets 2-itemset 2L  (table ?) by using candidates to scan database 1D .And all the recordings of itemsets which belong to 2L add to a new database 2D (table ?).

TABLE ? RESULT OF THE SECOND SCAN  2L  count BD 3 BF 3 DE 3 DF 4 EF 3  TABLE? NEW DATABASE 2D  itemset recording BD T100,T300,T400 BF T100,T300,T400 DE T200,T300,T400 DF T100,T200,T300,T400 EF T200,T300,T400  Before the third time of scanning database, LogECLAT algorithm uses a program to select which combination (table ?) should be used to scan database 2D .

TABLE ? PRODUCING THE COMBINATION  1I  2I  3I BD DE BDE BD DF BDF BD EF BDEF DE EF DEF  LogECLAT algorithm gets 3-itemset 3L and 4-itemset 4L  (table ?) by using candidates to scan database 2D .For 4L is NULL, no recording should be added to database 3D , so there are no recording in database 3D . LogECLAT algorithm also should be terminated for there is no itemset in 4L . In this way, all the frequent patterns are found.

TABLE ? RESULT OF THE THIRD SCAN  3L count  4L count  BDF 3 DEF 3  E. Comparison between LogECLAT algorithm and Apriori algorithm  Although LogECLAT algorithm is enlightened by ECLAT algorithm, Apriori algorithm is more commonly used by software to mine associations. So comparing the efficiency of LogECLAT algorithm with Apriori algorithm is more meaningful than comparing with ECLAT algorithm.

Apriori algorithm uses candidates 1+kC  which is produced by k-itemset kL  to explore (k+1)-itemsets 1+kL from database, while LogECLAT algorithm uses combinations produced by two k-itemsets kL  to find frequent patterns ranging from (k+1)-itemset 1+kL  to 2k-itemset kL2  by scanning a continually updated database. In the real environment, database is usually very large, so the comparison of two algorithms is performed on a large database environment.

A large database means that there are a lot of items in one transaction and the number of transactions is huge. For the average number of items in one transaction is large, it is quite possible to produce an itemset which is composed of a lot of items. A 10-itemset means to produce almost 102 frequent patterns, so the database of frequent patterns is also composed of large number of data.

The comparison of two algorithms focused on the procedure of scanning two databases (the database of transactions, the database of frequent patterns) or other databases directly related to the two databases such as the database of candidates, for those procedure consumes most time for the algorithm. And the principles of the comparison are as follows: (a) Although the initial time consumption of two algorithms is not known, when it is sure that the increase of time consumption for A algorithm is less than B algorithm?s, A algorithm is more efficient than B algorithm.

(b) Different kind of actions done to the same size of memory space one time consumes the equal time for a computer, and denotes the time as one unit time.

(c) To simplify the procedure of comparing LogECLAT algorithm with Apriori algorithm, assume that all the candidates in Apriori algorithm is composed of the same number of itemsets and equal number of frequent patterns exist in every two different i-itemset iL .

(d) The comparison between LogECLAT algorithm and Apriori algorithm chooses one section which is usually happened in LogECLAT, that is frequent patterns exist in 2k-itemset kL2 .That means Apriori algorithm should be used k times of scanning database to reach the effect of one time of scanning database for LogECLAT algorithm.

Symbols used to compare the time consumption between Apriori algorithm and LogECLAT algorithm are listed as follows:  )( kLNum ? ? the number of itemsets in kL .

0.2  0.4  0.6  0.8   1.2  1.4  1.6  1.8   100 200 300 400 500 600  Number of transactions  R u n t i m e ( s e c o n d s )  Apriori  Fp-growth  LogECLAT  )( kCNum ? ? the number of itemsets in kC .

)( ntransactioNum ? ? the number of transactions in the  database.

Min_sup ? ?  the minimum support of itemsets to be frequent patterns.

? ? ? a positive number and its concrete number is unknown.

In one time of scanning database for Apriori algorithm, the combinations of every two different itemset in k-itemset kL is used to produce candidates 1+kC , thus consumes  )(*))((*  1 kk LNumCNum  k ++  + ?  (1)  time unit. And then Apriori algorithm uses candidates 1+kC  to scan database consuming  )(*)(*  1 ntransactioNumCNum  k k+  ++  (2)  time unit. However, Apriori algorithm should find frequent patterns ranging from 1+kL to kL2  , so all the time consumption above for Apriori algorithm should be multiplied by k.

While LogECLAT algorithm selects candidates from combinations which are combined by every two different k-itemsets kL and it consumes  )1)((*  )(*  ?  + k  k LnumLNumk  (3)  time unit. And then LogECLAT algorithm uses those candidates to scan database kD to get frequent patterns.

Candidates in LogECLAT are composed of three parts: all the candidates ranging from 1+kC to kC2 in Apriori algorithm, combinations mistakenly produced by the way of selecting candidates in LogECLAT algorithm and combinations falsely caused for lacking of enough information of other frequent patterns. Combination 3I  is combined by two k-itemsets each denoted 1I and 2I , and combination 3I is composed of i different items. In the situation, the possibility that combination 3I  can not be a frequent pattern and combination 3I  is produced by using the method to select  candidates in LogECLAT algorithm to scan database is i iA  1 .

The possibility that combination 3I can be a frequent pattern according to k-itemset kL and combination 3I can not be a frequent pattern according to (i-1)-itemset 1?iL ( ki >?1 ) is decided according the concrete value in the database. So time consumption of scanning database is  )(*  sup_3*))(*( 1 ntransactioNum MinCNumk k ?++ (4).

Situation 1: increasing the database of transactions. Compare (2) in Apriori algorithm with (4) in LogECLAT algorithm, if the value of Min_sup is less than 0.67, then LogECLAT algorithm performs better than Apriori algorithm. And for such a large value of Min_sup, it is quite impossible for common database to produce a large database of candidates. So the value of Min_sup is much smaller than 0.67, and the time consumption of LogECLAT algorithm goes up slower than that of Apriori algorithm when the database of transaction increases.

Situation 2: increasing the database of frequent patterns. (1) in Apriori algorithm is certainly lager than (2) in LogECLAT algorithm. So Apriori consumes more time than LogECLAT algorithm when the database of frequent patterns increases.

So the performance of LogECLAT algorithm is indeed better than Apriori algorithm in a large database environment.

F. Comparisons in real environment  Experiments are undertaken to test the performance of LogECLAT algorithm under the environment of diversity number of transactions and support threshold.

All the experiments are performed on a AMD Athlon 64*2 Dual core processor 3800+ PC machine with 1G main memory, running on Microsoft Windows XP. All the programs are written in Microsoft Visual C++6.0. Experimental data is generated by software which produces random data to simulate the database existing in the real environment, and in this way the experiment can well reflects the performance commonly happened in all kinds of database. One database is generated to test the performance of Apriori algorithm, FP-growth algorithm and LogECLAT algorithm, and the number of items which compose the database is 39.

The first experiment is done under the environment that the count of transactions is different but with the same support  Figure ? Relationship Of The Number Of Transactions With Time Consumption  threshold 20% (show in Figure ?).From Figure ?, it is easy to get the conclusion that although the performance of LogECLAT algorithm is affected by the number of transactions, but the influence from the number of transaction is not seriously in comparison with Apriori algorithm and FP-tree algorithm.

Another experiment tests how time consumption is influenced by different support thresholds (Figure ?). The  number of transaction is 500. According to Figure ? ,  LogECLAT algorithm performs well in aspect of time consumption and is not easily influenced by the change of support threshold.

0.5   1.5   2.5  0.18 0.19 0.2 0.21 0.22  Support threshold  Ru nt  im e(  se co  nd s)  Apriori  Fp-growth  LogECLAT   FIGURE ? RELATIONSHIP OF SUPPORT THRESHOLD WITH TIME  CONSUMPTION

IV. CONCLUSION LogECLAT algorithm combines ECLAT algorithm and a method that uses special candidates to find frequent patterns from database. In this way, LogECLAT algorithm can extract necessary information from the database with fewer times of creating a new database. LogECLAT  algorithm also performs  well with the change of number of transactions and support thresholds in experiment. So LogECLAT can find frequent patterns efficiently from a large database.

