A Mechanism of Information-Centric Networking based on Data Centers

Abstract?Information-centric networking (ICN) aims to make the Internet more data-oriented or content-centric, thus name- based routing and universal caching are used to change the way users requesting and fetching content, as well as to improve network performance. However, current implementation mechanisms define some kinds of "clean-slate" architecture and certain brand new technologies need to be designed and implemented. In this paper, some requisites reflecting ICN?s essential ingredients are generalized, and based on the OpenFlow and the data center technologies, a mechanism called odICN, which can satisfy those aforementioned requisites, is proposed together with its algorithmic framework. Finally, a prototype of odICN is built to verify its feasibility.

Keywords-ICN; OpenFlow; data centers; measurement; deployment

I.  INTRODUCTION The surge of Internet traffic makes the traditional  network architecture exhausted. Many recent papers and research efforts have claimed that the Internet should be shifted away from a point-to-point paradigm to a more data- oriented one. The idea of information-centric networking (ICN) has been around for over a decade [1] However, it is rather tepid until mechanisms such as data-oriented network architecture  (DONA) [2] and content-centric networking (CCN) [3] are proposed, which are followed closely by several ICN projects and solutions [4-7]. Despite that each proposal has its own distinctive terminology, their fundamental principles are common: basic primitives, universal caching and content-oriented security model [8].

From another perspective, users can fetch the content regardless of which host holds it and where the host holds such content. Compared to the traditional network technologies, ICN could provide several typical benefits as follows: lower response time via pervasive caching and nearest-replica routing; intrinsic content integrity without external network-level indicators; simplified traffic engineering; and better support for mobility and security.

Although ICN is assured that it could promote the performance of many specific network applications, its implementation is based on considerable cost and some technologies really difficult to realize. For example, in CCN, routers need to support content caching and name- based routing, which may result in unavoidable increases of the processing, storing and implementing complexity and cost. Fortunately, line-speed forwarding has been  demonstrated for CCN/NDN in a Sigcomm'13 demo by Cisco, but there are still many problems to be solved in the future. On the other hand, the performance improvement achieved by pervasive caching and nearest replica routing is analyzed in [9], and they also outlines a "dirty-slate", incrementally deployable design called idICN, which uses edge caching to gain most of the caching benefits of ICN.

Experimental results show that in order to gain the benefits of ICN, there is no need to design such a "clean-slate" architecture. Therefore, several questions may be asked:  ? What requisites should an ICN design have?

? How to use the existing technologies to establish a  deployable ICN system?

By exploring these problems, we firstly generalize the  requisites that an ICN mechanism should satisfy so as to help understand the essential ingredients of ICN. Secondly, based on the OpenFlow and the data center technologies, a novel mechanism (called odICN) and its algorithmic framework are designed and a prototype is built to verify its feasibility. This mechanism gives us a de facto alternative to construct a low-complicated and deployable ICN system with the existing technologies.

The rest of this paper is organized as follows. Section 2 presents related work. Section 3 discusses and defines the requisites that should be satisfied in an ICN design. Section 4 introduces the design of the odICN mechanism. Section 5 discusses the implementation of the prototype and the process of experiments. Finally, section 6 presents the conclusion of our work.



II. RELATED WORK ICN adopts name-based routing mainly to optimize the  transmission of the content in networks [1]. Typical designs of ICN include CCN [2], DONA [3], etc. All the nodes in ICN maintain a data caching space, and the data requests of users could be served by any node that caches the data. In addition, ICN introduces nearest-replica routing to lower response time. Fayazbakhsh found that pervasive caching and nearest-replica routing are not fundamentally necessary, and most of the performance benefits can be achieved with a simpler caching architecture. A kind of architecture named idICN is proposed in [9], which notes that it is enough to cache data just at the edge of the network and incremental deployment can be achieved easily based on current architecture. However, the details about how to design and implement an idICN supported router is not mentioned.

DOI 10.1109/CBD.2013.4     In recent years, software defined networking (SDN), which controls network behaviors in a programming way, provides a new idea for network innovation [10]. The combination of SDN and ICN can help make better use of the network as well as control it. A new SDN based ICN architecture is proposed in [11]. The data is cached at the edge nodes of the network and the requests are processed by the content-aware controller. This proposal focuses attention on traffic engineering. Another solution combining ICN and SDN called CONET is put forward in [12]. Problems that may exist during its implementation are discussed, but how to implement it with the existing technologies are not further mentioned.

While SDN based ICN is trying to make the Internet itself more data-oriented or content-centric, which can be regarded as a network layer solution, content distribution network (CDN) is a popular application layer solution that can reduce the download traffic effectively in current Internet architecture [13]. In CDN, content will be pushed close to users, but users need to mark the requested content together with its location. In the meantime, it can?t achieve link-level load balance.



III. THE REQUISITES FOR ICN From the view of the network users, ICN should provide  a lower delay to achieve a better QoE. From the view of ISPs, ICN should lower the cost of the services and support various kinds of applications. Therefore, ICN should contain the following requisites.

Requisite 1: Users simply send the identifier of the content to a network and can fetch the content they want as soon as possible.

Requisite 2: A network can optimize the deployment of the content automatically so as to reduce global traffic.

Specifically, Requisite 1 implies that ICN should have 3 characteristics:  ? A user just submits a certain content identifier to a network and the network can deliver the content to the user quickly.

? A user can fetch the content with lower delay either from the optimum server or on the basis of the load balance of links.

? The identifier and the location of the content are decoupled so as to support the mobility of the users.

Requisite 2 then demands that a network should have a certain intelligence. That is to say, the network should be able to optimize the deployment of the content based on those prearranged rules. As a result, the entire transmission traffic of the same content across the network can be reduced and both the response time and the cost of ISP can be lower at the same time.

Obviously, these two requisites have contained most characteristics and advantages that the ICN architecture owns. Although they are still abstract and far away from the implementation, the ICN requisites can actually be used as the guide line to judge and implement ICN. There is no doubt that the Internet architecture now does not satisfy the requisites mentioned above much. When Internet users want  to get some content, they must send a request which contains the URL of the content to a known server instead of the network. The routers locating in the core of Internet know little about not only the syntax of packets but also the unit called content. The Internet itself thus certainly cannot optimize the deployment of the content without upper design.

Is it possible to use the network technologies such as OpenFlow to implement ICN? First, when a user requires a certain content from the network, the OpenFlow switch can forward the request to the controller. The controller can locate the content wanted in the network. If the content is found on a host, then related flow entries will be installed in the switches between the user and the server. Thus, Requisite 1 is satisfied. Secondly, the application in the controller can figure out the content optimized deployment by analyzing the distribution of the content and the potential users, the optional location for the copy of the content as well as the optimization principles. Requisite 2 then can be satisfied too.

Can the content be cached in the core or edge routers of the network? It is difficult and costly to implement such routers with huge storage and the liner-speed processing ability based on mature technologies right now. Meanwhile, the data center supporting cloud computing and storage already has these abilities on the whole. It may be an alternative to let several data centers in the edge of the network afford huge storage and intelligent delivery of the content. So, based on the OpenFlow and the data center technologies, a deployable ICN mechanism called odICN is supposed to be designed and implemented.



IV. DESIGN OF ODICN MECHANISM  A. Basic Idea of odICN   Figure. 1. The architecture of odICN  The architecture of odICN is shown as Fig. 1. There are users, data centers and OpenFlow switches in the data plane, and the controller together with the controlling programs in the control plane. These custom-tailored controlling programs can handle users? requests, locate content and optimize deployment. In the data plane, users can download the expected content from the optimum data center and some content can be transmitted from one data center to     another. In the control plane, content deployment can be optimized to minimize download traffic in the entire network. The functions of odICN predicate that it can satisfy the two Requisites for ICN. In addition, when the content is transmitted in the data plane, load balance can be performed in both spatial and temporal dimensions to optimize the distribution of network traffic.

Specifically, the components of odICN include: User u is a client who submits a content request to the  network.

Data center d is a data pool supporting mass data  storage. It is usually located near a densely populated region. In general, a data center should supply functions such as content retrieval, query, download and update.

When the information about content is modified, the data center will inform the controller.

OpenFlow switch s is a sort of switch conforming to the OpenFlow standard, which provides functions to configure and query the flow entries in the data plane.

Controller C is a logic center to control the entire network operating, which provides odICN control intelligence based on the global network topology and resource view. The algorithmic framework of its control components mainly includes three algorithms. Content locating (CL) algorithm can redirect users? requests to the data center containing specific content and costing least.

Content optimal deployment (COD) algorithm can automatically deploy the selected content to the other data centers according to the given principles, which will optimize the overall performance of ICN. Path optimizing (PO) algorithm can balance the network traffic in both spatial and temporal dimensions.

B. Formal Description of odICN Suppose that a graph ,G V E=< >  is a set V of the  nodes and a collection E of the edges, where each edge is a pair of the nodes from V . V  includes the controller C , the OpenFlow switch set { | [1, ]}i SS s i N= ? , the user set  { | [1, ]}i UU u i N= ?  and the data center set { | [1, ]}i DD d i N= ? . SN , UN  and DN  represent the  number of the OpenFlow switches, the users and the data centers respectively. {( , ) | , }E p q p V q V? ? ?  conserves the connection relationship between the entities. ( )R d  is defined as the content resource set owned by the data center d D? .

Assume that ( )x xContentReq r ,u  is the request primitive which stands for user xu  willing to acquire content xr  from the network, x xRegistPkt "Add",r ,d  is the registration primitive used by data center xd  to inform the controller that content xr  is added, and ( , )x xDeployTsk r d  is the deployment primitive with which the controller informs the data center deploy the content xr  to data center xd . The three core algorithms in the controller can be described as follows.

1) CL algorithm: CL has such functions as locating the best data center providing the content, determining the alternatives, evaluating their costs and so on (see Fig. 2).

When searching for the available paths in step 2, filter conditions can be set on demand. For example, setting the limitation of maximum hops to filter unnecessary alternatives. In step 3-6, i 1 2 kpath = s ,s ..,s , for i = 1 ~ k -1 ,  is S? , 1( , )i is s E+ ?  and 1( , )id s E? . icost  indicates the cost of delivering content xr  from data center id  to user xu along ipath , and its value is the weighted sum of multiple decision attributes 1 2 n< X ,X ,...,X > . The decision attributes  1 2 n< X ,X ,...,X >  are defined based on multiple performance metrics, which include the hop number of a path, the transmission bandwidth and the resource use of the data centers and so on. Finally, the proposal ,x xd path< > with the least cost is selected. The controller subsequently establishes the forwarding path xpath  and forwards  x xContentReq r ,u  to the data center xd .

Algorithm 1: Content Locating  Inputs: x xContentReq r ,u  Outputs: content provider xd  and forwarding xpath from xd to xu  Func: ContentLoc( x xContentReq r ,u( ) )  1:  { | , ( )}x xD = d d D r R d? ? ;    // compute the data center set having xr 2:  FindPath( )x x xPathSet = u ,r ,D ;  // scan the topology and find the available paths from each d in xD to  3:  for ,i id path< >  in PathSet do    // compute the cost of each path  4:     1 2, ,..., = GetAttrs( , )i i in i iX X X d path< > < > ; // get the value of attributes numbered from 1 to n, // which suggests the cost of the candidate proposal ,i id path< > // to serve the request in different metrics  5: n  i j ij j=1  cost = X?? ;                        // calculate the total cost 6:  end for 7:  MinCost 1 2 mx = (< cost ,cost ,...,cost >) ;  // get the index of the proposal which costs least, // m is the number of proposals  8:  return x x< d , path > ;  Figure. 2. Content locating algorithm  2) COD algorithm: A perfect COD algorithm will deal with lots of complex problems. The key problem is how to execute content optimal deployment. For example, what content will be copied, where the copies of this content should be put, when to trigger to do so and how the different principles or strategies are compromised. Some simple and typical conditions are considered here. For example, one passive PULL method is to learn the hot level from the users? requests regionally, shown as step 2 in Fig. 3. When the hot level exceeds the threshold, COD algorithm actively copies the content to the data center closest to those users.

Another active PUSH method is based on apriori knowledge, shown as step 8. When a certain famous open- source operating system releases its new version, for instance, COD may push copies to all these data centers.

The core of COD is the function DoCtnOpt , which can be overloaded and shown as step 6 and step 12. According to the source and destination information _ , _d src d dst< > , this function let the controller send ( , _ )xDeployTsk r d dst to data center _d src  and thus a copy of content xr  is transmitted from _d src  to _d dst .

Algorithm 2: Content Optimal Deployment  Inputs: ( )x xContentReq r ,u , ( )x xRegistPkt "Add",r ,d  or other defined triggers Outputs: data center pairs { _ , _ }d src d dst< >  for 'xr s optimal deployment Func: ContentOpt( )input 1:  switch(input)                                   // there are different conditions 2:     case ( )x xContentReq r ,u :             // get a user?s request  3:        = GetRegion( )x xRegion u ;      // get 'xu s  region  4:        = UpdateReqInfo( )x x xCurReqInfo r ,Region ;  // update 'xr s  requesting statistical information for xRegion  5:        if xCurReqInfo  > threshold then  6:           { _ , _ } = DoCtnOpt( )x xd src d dst r ,Region< > ;  // optimization deployment for xr in xRegion 7:        end if 8:     case ( )x xRegistPkt "Add",r ,d :     // inform a data center registration  9:        if xr  not in d D  R(d) ? ?  then         // if xr  is totally new for the netwo  10:          = GetApri( )x xApriJudge r ;   // find out 'xr s  apriori knowledge  11:           if xApriJudge  not NULL then  // if 'xr s apriori knowledge exist  12:               { _ , _ } = DoCtnOpt( , )x xd src d dst r ApriJudge< > ;  // optimization deployment for xr based on xApriJudge 13:          end if 14:       end if 15:    case ??:                                    // other conditions 16:       ??                                          // other actions 17: return { _ , _ }d src d dst< > ;  Figure. 3. Content optimal deployment algorithm  3) PO algorithm: PO can balance the network traffic in either spatial dimension or temporal dimension, illustrated in Fig. 4. In temporal dimension, the moment that the content optimal deployment is executed may be optimized, and the strategy "deployment when idle" can be used, shown as step 2-6 in Fig. 4. The function SetTime sets the startup moment of the deployment, and the moment can be defined in terms of a specific startup time, a startup interval or startup conditions etc. What?s more, a timer may be set to wake up the waiting deployment task, which is ignored in Fig. 4. In spatial dimension, link load states are monitored when the transmitting content, and the forwarding path can be adjusted flexibly to balance the network traffic load,  shown as step 7-14. In fact, the temporal and spatial methods can be combined to achieve better results.

Algorithm3: Path Optimizing Inputs: policy for path optimizing Outputs: forwarding path?s modification Func: PathOpt( )input 1:  switch(input)                             // there are different policies 2:     case OptInTime:                     // temporal optimization 3:        while true do 4:           = GetContentOpt()CtnOptProp ; // wait until there is a proposal of content optimal deployment 5:           SetTime( )CtnOptProp ;  // set the execute time for the proposal 6:        end while 7:     case OptInSpace:                   // spatial optimization 8:        while true do 9:           = GetLinkState( )CurLinkSt E ;   // get the link states 10:          if CurLinkSt > threshold then     // if some links are overloaded 11:              AdjustPath( )CurLinkSt ; // adjust some flows forwarding paths to achieve balance 12:          end if 13:          sleep(MonitorInterval) ;             // wait for next interval 14:       end while 15:    case ??:                                         // other policies 16:       ??                                               // other actions  Figure. 4. Path optimizing algorithm

V. PROTOTYPE OF ODICN AND ITS EXPERIMENTS  A. Composition of Prototype  OpenFlow Switch  OpenFlow Switch  OpenFlow Switch  OpenFlow Switch   Figure. 5. Environment of the odICN prototype  TABLE I.  RELATED CONFIGURATIONS OF THE ODICN PROTOTYPE  Device Profiles  Data center The data center proxy written in Python, 120 lines.

Controller odICN control components written in Python, running on NOX-0.9.1 controller, 300 lines.

OpenFlow switch OpenFlow-1.0.0 software switch supporting local log function written in C.

OpenTrace server The OpenTrace control program used for performance measurement written in Python, 280 lines.

User PC The user proxy written in Python, 80 lines.

To verify the feasibility of odICN, a prototype system is built in the environment shown in Fig. 5. The prototype includes 4 OpenFlow switches, 1 NOX controller, 1 OpenTrace server, 3 data centers and a set of users (Only user A and B are shown in Fig. 5). All the devices are PCs having the Core Duo dual-core CPU 2.5GHz, 2GB memory and 1Gbps network adapter, and equipped with CentOS 6.0 operating system in Linux kernel 2.6.32. Other related configurations are shown in TABLE I. .

In our experiments, the odICN control component maintains the core logic of the odICN mechanism. The topology view is updated when the controller deals with such events as join, exit or port state change of the OpenFlow switches. Meanwhile, the global resource view is updated when the controller deals with the registration messages sent by the data centers. CL here takes the minimum hops as the optimizing metric and locates the optimum data center supplying the content service. In other words, the data center with the minimum hops away from the user among all the data centers having the content is selected as the content service provider. COD is started when specific content requests from a certain user region exceed the threshold, copies of the content will be distributed and deployed from a proper data center to the data center close to the user region. By monitoring the traffic from the relevant ports of the OpenFlow switches, PO carries out path optimization when some link loads exceed the scheduled value. In a sense, PO can be regarded as the further optimization based on CL and COD.

OpenTrace is a distributed network measurement tool designed and implemented by us. It can be used for quantificational analysis of the performance of applications or mechanisms in an OpenFlow network. In the experimental network, an OpenFlow switch or the controller is upgraded to be an OpenFlow measurement entity able to generate a local log. These local logs can be merged into a timestamp sorted aggregate log, which includes the information of both the control flows and the data flows. By analyzing the aggregate log, interactions in the control plane, in the data plane and between the two planes can recur precisely.

B. Experimental Processes Assume that before the experiments, data center A stores  Content1 (1200 MB) and Content3 (1200 MB), data center B stores Content2 (800 MB), while data center C which is closer to user A and user B doesn?t contain them. The experiment verifying odICN prototype is composed of the following 3 processes and the timing relationships among the entities are illustrated in Fig. 6.

Process 1: User A and B respectively submit the requests of Content1 and Content2 to the network. Using the CL algorithm in the controller, user A and B are able to respectively get the content from data center A and data center B, which hold the corresponding content and is the closest one.

The upper half part of Fig. 6 demonstrates this process.

The experiment shows that odICN can guarantee the user requests to execute, although the requests are submitted to  the network instead of to a server. Also CL indeed enables the users to get the content from the optimum data center.

Process 2: When the requests for Content1 from the region in which user A and B reside are more than a threshold, COD inside the controller will be triggered and automatically carry out the optimal deployment of Content1.

This results in the copy of Content1 being pushed to data center C.

The lower half part of Fig. 6 indicates such a process.

The experiment shows that COD can automatically achieve the content optimal deployment on principle. After that, it will obtain the content from the closest data center C if user B requests Content1 again.

Figure. 6. Timing relationships of odICN prototype experiments  OpenTrace system is used to record the experimental process, and the timing relationships are obtained (see Fig.

6). By filtering and analyzing the aggregate log, the control processes of the main system entities are illustrated in Fig.

7. Where the horizontal axis represents the relative experimental time, the vertical axis shows the control flow information logged by associated OpenFlow switches, the symbol "+" stands for the process 1, and the symbol "?" stands for the process 2.

0s 10s 20s ... ... 250s 260s 270s 280s 290s 300s 310s 320s  OFS 1 - NoxToDCC  OFS 1 - NoxToDCB  OFS 1 - NoxToDCA  OFS 4 - UsersToNox  OFS 4 - DCCToNox        Process 1 Process 2   Figure. 7. Control process of odICN prototype redisplayed by OpenTrace  Process 3: User A requests Content2 located in data center B while user B requests Content3 located in data center A. These two data flows are simultaneously transmitted over the same link OFS3 - OFS4  that results in the overload of this link. Once the controller detects this, the forwarding path of transmitting Content3 will be automatically changed to OFS2 OFS1 OFS4? ?  in order to achieve load balance.

0 5 10 15 20 25 30 350       time(s)  M bp  s      Content3 for UserB in link OFS3-OFS4 Content3 for UserB in link OFS1-OFS4 Content2 for UserA in link OFS3-OFS4  Forwarding path of Content3 for UserB is changed.

Figure. 8. Data flows of odICN prototype redisplayed by OpenTrace  Using the OpenTrace system again, the analysis results of the data flows are illustrated in Fig. 8, where the horizontal axis stands for the relative experimental time, and the vertical axis stands for transmission rates of the data flows on the links.

Experimental results show that odICN mechanism can automatically achieve network load balance by using PO algorithm. To sum up, the odICN prototype reflects that the odICN mechanism can satisfy the two Requisites for ICN and it is feasible.



VI. CONCLUSIONS The requisites for ICN can be used as the rules to judge  ICN mechanism as well as to guide the design of a deployable ICN in practice. In this paper, the odICN mechanism based on mature technologies such as OpenFlow and data centers is proposed. The experiments of its prototype prove that users can obtain the content from the optimum data center according to its name; content can be optimally deployed according to specific rules automatically, and also the load balance of all the network links can be carried out. In the future, the extensibility, security and efficiency of deploying the odICN mechanism will be explored.

