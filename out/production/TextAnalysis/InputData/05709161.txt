Mining Positive and Negative Sequential Patterns with Multiple Minimum Supports  in Large Transaction Databases

Abstract?Sequential patterns mining is an important research topic in data mining and knowledge discovery. The objective of mining sequential patterns is to find out frequent sequences based on the user-specified minimum support threshold, which implicitly assumes that all items in the data have similar frequencies. This is often not the case in real-life applications.

If the frequencies of items vary a great deal, we will encounter the dilemma called the rare item problem. In this paper, an efficient algorithm to discover sequential patterns with multiple minimum supports is proposed. The algorithm can not only discover sequential patterns forming between frequent sequences, but also discover sequential patterns forming between either frequent and sequences rare sequences or among rare sequences. Moreover, an algorithm for mining positive and negative sequential patterns with multiple minimum supports is designed simultaneously.

Keywords- multiple supports ;data mining; sequential patterns

I. INTRODUCTION Sequential patterns mining is an important research topic  in data mining and knowledge discovery, which is firstly proposed by R.Agrawal [1]. While association rules mining is to find the intra-transaction relations, sequential patterns mining is to find the inter-transactions relations. A sequential pattern is formed as (A, B), where A and B are disjoint item sets, and its support is no less than a user-specified minimum support.

Inspired by the idea of negative association rules [2][3], we set forth the concept of negative sequential patterns. For instance, if one buys Linux operating system software, then he would not buy application software based on MS- Windows. The negative sequential pattern can be formed as (A, ?B), which means that if A is in a transaction, then B would not in another transaction with high probability. There are other forms negative sequential patterns likes (?A, B) and (?A, ?B).

The user-specified minimum support threshold is a key element of mining sequential patterns, which is used to prune the search space and to limit the number of rules generated.

Using only a single minimum support implicitly assumes that all items in the data have similar frequencies in the database. This is often not the case in real-life applications.

In many applications, some items appear frequently in the data, while others appear rarely. If the frequencies of items vary a great deal, we will encounter the dilemma called as the rare item problem. If minsup is set too high, we will not find those sequential patterns that involve rare items in the data. If minsup is set too low in order to find sequential patterns that involve both frequent and rare items, it will cause combinatorial explosion because those frequent items will be associated with one another in all possible ways and many of them are meaningless.

In order to deal with the rare item problem, we put forward a multiple minimum supports based model for mining sequential pattern. In this model, we can specify a different minimum item support for each item, which is calculated for each item based on a monotonous decreasing  power function such as x  of its support.

Consequently, the difference between the minimum item support for each item and its support will vary in an expected way. For the frequent items, the difference is small; for the rare items, the difference is large. Thus, the minimum item support for frequent item is slightly less than its support, and the minimum item support for rare item is much lower than its support. The number of frequent itemsets will not explode; the rare itemsets will not be missed.

In this paper, we combine these two extensions to propose a novel approach to mining both positive and negative sequential patterns with multiple minimum supports.

The rest of the paper is organized as follows. The definitions for positive and negative sequential patterns with multiple minimum supports are given in Section 2. In Section 3, we describe the discovery algorithm for mining positive and negative sequential patterns with multiple minimum supports. Section 4 presents our primary experimental results. The conclusions are made in the last section.



II. PROBLEM DEFINITION  A. Sequential Patterns Let I = {i1, i2, ? ,im} be a set of literals called items. Let  the database D = { t1, t2, ? ,tn } be a set of transactions,  2010 Second WRI Global Congress on Intelligent Systems  DOI 10.1109/GCIS.2010.213   2010 Second WRI Global Congress on Intelligent Systems  DOI 10.1109/GCIS.2010.213   2010 Second WRI Global Congress on Intelligent Systems  DOI 10.1109/GCIS.2010.213   2010 Second WRI Global Congress on Intelligent Systems  DOI 10.1109/GCIS.2010.213   2010 Second WRI Global Congress on Intelligent Systems  DOI 10.1109/GCIS.2010.213     where each transaction is a subset of I. A non-empty subset of I is called itemset. An itemset containing k items is called k-itemste. The support of an itemset X denoted as sup(X) is defined as the number of transactions containing X in D. An itemset is frequent if its support is greater than a user- specified threshold minsup.

A sequence is an ordered list of itemsets such as s = (s1, s2, ? ,su), where each itemset si is an element of the sequence. An item can appear only once in an element, but can occur multiple times in different elements of a sequence.

Items in an element are assumed to be sorted in lexicographic order. A sequence with k items, where ?= j jsk || , is called a k-sequence,where | sj | denotes the number of items in itemset sj.

A sequence t = (t1, t2, ? ,tv) is called a subsequence of s if there exist integer 1?j1<j2<?<jv?u such that  11 j st ? , 22 jst ? , ? , vjv st ? . A sequence database SD  is a set of tuple <sid,t>, where sid is the sequence identifier and t is a sequence. A tuple <sid,t> is said to contain a sequence s if s is a subsequence of t. The support of a sequence s, sup(s), is defined as the number of tuples in the sequence database SD containing sequence s. A sequence is frequent if the support of the sequence is no less than the predefined minimum support threshold minsup. The maximally large sequences are called as sequential patterns.

The algorithm proposed by Agrawal and Srikant to mine sequential patterns from large transaction databases is divided into five phases[1]:?1?Sort phase. The transaction database is sorted by customer ID as the major key and transaction time as the minor key. The phase converts the original transaction database into a database of customer sequences; (2) Large itemset phase. The set of all the large itemsets are found from the customer sequences database by the similar method with the process of mining association rules. Note that the counting of itemset is for customer sequence not for transaction. When an itemset occurs more than one time in a customer sequence, it is counted just once for this customer sequence. (3) Transformation phase. In this phase, each large itemset is mapped to a contiguous integer and the original customer sequences are transformed into the mapped integer sequences. (4) Sequence phase. The set of transformed integer sequences are used to find large sequences among them. (5) Maximum phase. The maximally large sequences are derived and output to users.

B.  Negative Sequential Patterns Corresponding to a positive sequential pattern such as (A,  B), there are three possible negative sequential patterns, (A, ?B), (?A, B) and (?A, ?B). For a sequence (A, ?B) and a certain transaction sequence CS, if A ? CS and ?B ? CS, we say that CS supports (A, ?B). Assume there is a negative sequential pattern such as ({i1}, ?{ i2 , i3}), which means that if i1 is in a customer sequence CS, i2 and i3 would not appeared in the customer sequence CS, but there is a possibility that one of the i2 and i3 is in this customer sequence.

To discover negative sequential pattern, we need to consider all of the possible sequence in transaction databases. If (A,?B) is a negative sequential pattern, it will hold that sup(A,?B) >= minsup. A higher value for minsup possibly means sup(A,B)<minsup, i.e., (A, B) is infrequent sequence. However, there are too many infrequent sequences in database. If A is a frequent itemset while B is a infrequent itemset with support 1, we will have: sup(A)>=minsup, sup(B)?0, sup(A, ?B) ?sup(A)>=minsup. Therefore, it seems that (A, ?B) is a negative sequential pattern. In fact, this kind of sequences is rather prevalent in real database, for example, a set of the goods rarely bought by customers in supermarket is an infrequent itemset. In practice, since the task of data mining is to find all kinds of valuable correlations, we usually more focus on the correlations between the well-sold goods, which are based on the frequent sequence. In other word, if (A, ?B), (?A, B) and (?A, ?B) are negative sequential patterns, A and B would be frequent sequence. In generally speaking, we only focus on the frequent sequence whether the sequential patterns are positive or negative.

In order to find valuable association rules, Piatetsky- Shapiro had put forward an interestingness measurement of association rules [4]. If sup(X?Y) ? sup(X) ? sup(Y), X?Y is considered as uninteresting rules. In other words, we can say that as the association rule X?Y is interesting only if sup(X?Y) ? sup(X) ? sup(Y) is no less than a specified minimum interesting value, mininterest. Similarly, we adopt the same method to measure the interesting of negative sequential patterns.

We formally define an interesting negative sequential pattern (A, ?B) as:  (1) A ? B = ?; (2) sup(A)>=minsup, sup(B)>=minsup, sup(A??B) >=  minsup.

(3) sup(A??B) ? sup(A) ? sup(?B)>= mininterest.

Noted it need to satisfy condition sup(B)>=minsup since  we are only interested in frequent itemset in sequential patterns.

By the same way we can define conditions of negative sequential patterns forms as (?A, B) and (?A, ?B).

If (A, ?B) is a negative sequential pattern, A?B will be an interesting infrequent sequence. If i is an interesting infrequent itemset, there exists at least one expression, i=A ?B, which makes one of (A, ?B), (?A, B) and (?A, ?B) be interesting negative sequential pattern hold.

C. Multiple minimum supports In multiple minimum supports model, every item ij of the  itemset I={i1,i2,....,im} has been assigned a minimum item support based on its support value sup(ij), denoted as mis(ij).

Definition 1: the minimum item support of an item ij is defined as   otherwise  LS )m(i if      )( )( j  ? ? ? >  = LS  im imis jj     )sup( 1)sup()(  j jj i  iim ?=  Definition 2: the minimum support for an sequence X is the minimum of minimum support of the items contained in the sequence, denoted as mis(X).

Definition 3: An sequence X is said to be frequent if  )()sup( XmisX ?

III. DISCOVERY ALGORITHM FOR MINING POSITIVE AND NEGATIVE SEQUENTIAL PATTERNS WITH MULTIPLE  MINIMUM SUPPORTS Based on the constraint conditions of interesting frequent  sequence and infrequent sequence, we proposed an algorithm for mining positive and negative sequential patterns with multiple minimum supports. The algorithm generates frequent sequences by making multiple passes over the data set. However, in contrary to single minsup approaches which follow ?downward closure property? (all the subsets of a frequent sequence are frequent), multiple minimum support approaches follow ?sorted closure property?. Let Ck denote the set of candidate k-sequence and Fk denote the set of frequent k-sequence. Note that the items in an sequence are arranged in increasing order of their MIS values from left to right.

Notations used in this algorithm are described as Table 1.

TABLE I.  NOTATIONS  Notation meaning n The total number of transactions in database m The total number of items c The total number of customers  Ck the set of candidate itemsets with k items Lk the set of large itemsets with k items  SCk the set of candidate sequences with k itemsets SLk the set of frequent sequences with k itemsets  SNLk the set of infrequent sequence with k itemsets FreS the set of all frequent sequences  InFreS the set of all infrequent sequences min_sup The predefined minimum support threshold  Algorithm: Mining RIMMS(Mining Both Frequent and Infrequent Sequence with Multiple Minimum Supports) Input: Database D, Least minimum support LS; Output: Set of frequent sequences FreS, set of infrequent sequences InFreS; Begin  (1) FreS = ? ; InFreS = ?; (2) C1 = {candidate 1-sequence}; (3) For each sequence c ? C1  do )sup(  1)sup()( c  ccm ?= ;  (4) If m(c)<LS mis(c) = LS Else mis(c) = m(c); (5) F1={ c| c ? C1 ? sup(c)>=mis(c)}; (6) F1 = sort(F1, MIS);  (7) FreS = FreS ? F1; S1= ?; (8) For (k=2;Fk-1 ? ? ;k++) { (9)    Ck = Candiate_Gen(Fk-1); (10)    For each transaction sequence t in D do { (11)       Tempt = k-sequence in both t and Ck; (12)       For each itemset i in Tempt do i.count++; (13)       } (14)    Fk = {c| c ? Ck ? sup(c)>=mis(c)}; (15)    Sk = Ck ? Fk; (16)    FreS = FreS ? Fk; (17)    InFreS = InFreS ? Sk; (18)    }  End.



IV. CONSTRUCT NEGATIVE SEQUENTIAL PATTERNS Based on the definition of interesting negative sequential  patterns in section 3, we proposed three types of negative sequential patterns and their constructing algorithm.

Definition 4: Let I be all the set of items in transaction database D, A and B are sequence, where i=A?B, A ? B = ?, mininterest is the minimum interestingness. We have:  If sup(A)>=mis(A), sup(B)>=mis(B), sup(A ? ?B)>=mis(A??B) and sup (A??B) ? sup (A) ? sup (?B)>= mininterest, (A??B) will be a interesting negative sequential pattern.

If sup(A)>= mis(A), sup(B)>= mis(B), sup(?A? B)>=mis(?A?B), and  sup (?A?B) ? sup (?A) ? sup  (B)>= mininterest, (?A?B) will be a interesting negative sequential pattern.

If sup(A)>= mis(A), sup(B)>= mis(B), sup(?A??B)>= mis(?A??B), and sup (?A??B) ? sup (?A) ? sup (?B)>= mininterest, (?A ? ?B) will be a interesting negative sequential pattern.

According to the above definitions we set forth the following negative sequential pattern mining algorithm.

Algorithm: CPNFSP(Construct Positive and Negative Sequential Patterns) Input:database D; Minimum interestingness mininterest.

Output: Positive sequential patterns set PSP; Negative sequential patterns set NSP.

Begin  ?1? Call procedure MiningRIMMS; ?2? Transform the maximally large q-sequence in  FreS, q?2, into sequences of original items and put them to PSP  ?3? For each sequence i in InFreS Do ?4?    For any A?B=i and A ? B = ? Do ?5?      Begin ?6?       If sup(A)>=mis(A) ? sup(B)>=mis(B) ?  sup(A??B)>=mis(A??B) ?7?       Then If sup(A ? ?B) ? sup(A) ?  sup(?B)>= mininterest ?8?           Then NSP = NSP ? {(A??B)}; ?9?       If sup(A)>= mis(A) ? sup(B)>= mis(B)  ?     sup(?A?B)>=mis(?A?B) ?10?       Then If sup(?A ? B) ? sup(?A) ?  sup(B)>= mininterest ?11?            Then NSP = NSP ? {(?A?B)}; ?12?       If sup(A)>=mis(A) ? sup(B)>=mis(B) ?  sup(?A??B)>=mis(?A??B) ?13?       Then If sup(?A ? ?B) ? sup(?A) ?  sup(?B)>= mininterest ?14?              Then NSP = NSP ? {(?A??B)}; ?15? End;  End.



V. EXPERIMENT To test the performance of our proposed algorithms we  have done some experiments. The computation environments are Pentium 3.0GHz, memory of 2G, operating system of WindowsXP. The algorithm is implemented with C++. The synthetic experiment data are generated by Assocgen [1] program of IBM Almaden research center. The meaning of used parameters are showed in Table 1.

TABLE II.  PARAMETERS  Symbol Meaning D Number of customers(=size of database) C Average number of transactions per Customer T Average number of items per Transaction S Average length of maximal potentially large  Sequences I Average size of Items in maximal potentially  large sequences NS Number of maximal potentially large  Sequences NI Number of maximal potentially large Sequence N Number of items    C10T5S4I25        1 0.8 0.6 0.4 0.2  Least Mininum Support  R u n  t i m e ( s )  CPNFSP   Figure 1.  Execution times  We set parameters C=10, T=5, S=4, I=2.5, NS =500, NI =2500, N =10000, total number of customers D=100000, and the generated dataset is named as C10T5S4I25. Figure 1 shows the algorithm executing time variance with minimum support decreasing from 1% to 0.2%, where the mininterest is set to 70%. It demonstrates that the algorithm increases with the declining of least minimum support LS.

To examine the scalability of algorithm we increased the numbers of customer D from 50,000 to 150000, with LS=1%, mininterest=70%. The results are shown in Figure 2. The executing time is increased almost linearly with the increasing of dataset size. It can be concluded our algorithm has a good scalable performance.

C10T5S4I15        50 75 100 125 150  Number of Customers  R u n  t i m e ( s )  CPNFSP   Figure 2.  Scale-up: Number of customers

VI. CONCLUSION AND FUTURE WORK We proposed the concepts of positive sequential pattern  and negative sequential pattern with multiple minimum supports based on the current work about sequential pattern mining. And we implemented the negative sequential patterns mining algorithm. The experiments demonstrated that the algorithm is efficient and scalable.

As a future work, we will address fuzzy negative sequential patterns from large transaction database with quantitative items.

