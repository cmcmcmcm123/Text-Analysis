An Information Retrieval Method Based On Sequential Access Patterns

Abstract------It has become much more difficult to access relevant information from the Web With the explosive growth of information available on the World Wide Web. One of the promising approaches is web usage mining, which mines web logs for user models and recommendations. Different from most web recommender systems that are mainly based on clustering and association rule mining, this paper proposes an web personalization system that uses sequential access pattern mining. In the proposed system an efficient sequential pattern- mining algorithm is used to identify frequent sequential web access patterns. The access patterns are then stored in a compact tree structure, called Pattern-tree, which is then used for matching and generating web links for recommendations.

In this paper, the proposed system is described, and its performance is evaluated.

Keywords- Access Patterns ?  Information Retrieval; Personalization;

I.  INTRODUCTION It has become much more difficult to access relevant  information from the Web With the explosive growth of information available on the World Wide Web. One possible approach to solve this problem is web personalization [1]. This research focuses on developing an intelligent recommender system to provide personalized web service for accessing related web pages more efficiently and effectively. The goal of the intelligent recommender system is to determine which web pages are more likely to be accessed by the user in the future.

Various traditional techniques such as collaborative filtering [2] and hybrid content-based collaborative filtering approaches [3] have been developed for supporting web recommendations. However, such approaches suffer from a major drawback in which most users surf websites anonymously via a proxy, and their identities are hidden and difficult to get. More recent techniques are based on web usage mining, which aims to discover interesting usage patterns derived from the data stored in web server logs or web browser logs. Promising web usage mining techniques such as association rule mining [4] and clustering [5] have been applied for web recommendations.

Different from the majority of the existing web recommendation techniques, we propose an intelligent web recommender system known that uses a sequential pattern mining technique. Unlike clustering and association rule mining, sequential pattern mining algorithms [8] also consider the sequential characteristic of access patterns, which is very suitable for predicting the next web pages. In  addition, this paper also proposes a compact data model, called Pattern-tree, which stores the sequential web access patterns, and an efficient approach for user pattern matching and recommendation rules generation. Different evaluation measures including precision, satisfaction and applicability are proposed to measure the performance of the recommender system.

The rest of this paper is organized as follows. Section II presents the system architecture of SWARS. Section III discusses the performance evaluation and experimental results. Finally, Section IV concludes the paper.



II. SYSTEM ARCHITECTURE An overview of the architecture of the proposed system is  given in Fig. 1. First, all users? web access activities of a website are recorded by the WWW server of the website and stored into the Web Server Logs. Each user access record contains the client IP address, request time, requested URL, user ID, HTTP status code, etc. After obtaining the Web Server Logs, the Sequential Pattern Mining component is applied to mine the user access sequences from the Web Server Logs. Then, the Pattern-tree Construction component constructs the recommendation model or Pattern-tree from the mined sequential web access patterns. Both the sequential pattern mining and Pattern-tree construction processes are carried out off-line. The Pattern-tree can be updated regularly to incorporate new access data.

Web Server Logs  Pattern-tree  Sequential Pattern Mining  Patter-tree Construction  Recommendation Rules Generation  Current access  sequence Recomm endation Rules  Web Server Requested page with links for  recommended pages http request  Internet  User   Fig. 1 System architecture.

When a user visits the website, the user?s HTTP requests in the current browsing session are recorded in order, and the current access sequence is constructed. Each user accessing the website can be identified using his/her IP address. Matching the user?s current access sequence from the recommendation model of the Pattern-tree, the Recommendation Rules Generation component will generate recommendation rules. From the recommendation rules, recommended or ??related?? links will be dynamically inserted into the current requested page.

2010 Asia-Pacific Conference on Wearable Computing Systems  DOI 10.1109/APWCS.2010.75   2010 Asia-Pacific Conference on Wearable Computing Systems  DOI 10.1109/APWCS.2010.75   2010 Asia-Pacific Conference on Wearable Computing Systems  DOI 10.1109/APWCS.2010.75   2010 Asia-Pacific Conference on Wearable Computing Systems  DOI 10.1109/APWCS.2010.205   2010 Asia-Pacific Conference on Wearable Computing Systems  DOI 10.1109/APWCS.2010.69       Algorithm: Pattern-tree Construction Input:  set of Sequential Web Access Patterns Output:  T --- Pattern-tree of SWAP Method: 1: Create an empty root node R for Pattern-tree T.

2: For each sequence S?SWAP, denoted as S = e1e2?en, do a: Set current_node point to R.

b: For i = 1 to n do,  if current_node has a child node labeled ei, use the maximum support between S and this child node as the support of ei and set current_node point to ei, else create a new child node with the support of S, denoted as (ei:support of S), set current_node point to the new child node.

3: Return Pattern-tree T.

A. Sequential Pattern Mining In general, each line of web logs (one access record)  includes the following key information: date-timestamp, client IP address, user ID, requested URL, and HTTP status code. We define web logs to be a collection of sequences comprising web access events from each user during their corresponding session in timestamp ascending order.

Preprocessing must be performed on the web logs prior to applying sequential pattern mining. The main data preprocessing techniques used here include data cleaning, user identification, and session identification.

Let?s define sequential pattern mining [8] as follows.

Given a sequence database where each sequence is a list of transactions ordered by transaction time with each transaction comprising a set of items, find all sequential patterns with a user-specified minimum support, which is defined as the number of data sequences containing the pattern.

Let E be a set of unique access events, which represents web resources accessed by users, i.e. web pages, URLs, topics or categories. A web access sequence S = e1e2?en (ei ?E) for 1?i?n is an ordered collection (sequence) of access events, and |S| = n is called the length of the web access sequence. Note that it is not necessary that ej?ei for i?j in S, that is, item-repetitions are allowed. Suppose we have a set of web access sequences with the set of events, E = {a, b, c, d, e, f}. A sample web access sequence database is shown in Table I, which contains four unique web access sequences.

TABLE I A SAMPLE DATABASE OF WEB ACCESS SEQUENCES  Session ID Web Access Sequence 1 a b d a c 2 e a e b c a c 3 b a b f a e 4 a f b a c f c  A web access sequence S? = e1?e2??el? is called a subsequence of web access sequence S = e1e2?en, denoted as S? ? S,if and only if there exists some ij, 1?i1 <i2< ?<il ? n, such that ej? = eij for (1?j? l). For S = e1e2?ek ek+1?en, Sprefix = e1e2?ek is called a prefix sequence of S, and Ssuffix = ek+1ek+2?en is called a suffix sequence of S for 1? k ?n.

Given a database of web access sequences WASDB = {S1, S2, ?, Sm} in which Si (1?i?m) is a web access sequence, and |WASDB| = m is called the length of the database. The support of web access sequence S in WASDB is the total number of unique web access sequences in WASDB that contains S, as defined in the following equation: sup(S) = | {Si | S ? Si, Si?WASDB} | .

Note that although access events can be repeated in a web access sequence, any web access sequence S can get a support of at most one from each web access sequence Si. A web access sequence S is called a sequential web access pattern, if sup(S) ?MinSup, where MinSup is a given support threshold. An access event ei?E is called a frequent event, if sup(ei) ? MinSup. Otherwise, it is called an infrequent event.

TABLE  II SEQUENTIAL WEB ACCESS PATTERNS WITH MINSUP = 3 FROM THE SAMPLE DATABASE IN TABLE 1.

Length of Patterns Sequential Web Access Patterns with Support 1 a:4, b:4, c:3 2 aa:4, ab:4, ac:3, ba:4, bc:3 3 aac:3, aba:4, abc:3, bac:3 4 abac:3  Let?s consider the web access sequence database in Table

I. Suppose the support threshold MinSup = 3, then all the sequential web access patterns supported by at least three web access sequences are listed in Table II.

B. Pattern-tree Construction A Pattern-tree model is proposed for storing sequential  web access patterns compactly, so that it can be used for matching with a user?s current access sequence and generating recommendation rules more efficiently in the Recommendation Rules Generation component. In general, the set of sequential web access patterns can be treated as a set of strings over a finite alphabet E (the set of unique access events). Every node of the Pattern-tree is labeled with a symbol (access event) from E and has a corresponding support value. Sometimes, the edges of a Tree are labeled instead of the nodes, but nevertheless refer to the same structure in either case. Once the Pattern-tree is constructed, the original web access sequence database is no longer required for subsequent processing.

To construct a Pattern-tree, we only need to have one scan of all the sequential web access patterns. Fig. 2 gives the Pattern-tree Construction algorithm, which is based on the set of sequential web access patterns mined by the Sequential Pattern Mining component using CS-mine.

Fig. 2 The Pattern-tree construction algorithm.

Complexity analysis: Inserting a sequential web access  pattern S into the Pattern-tree T requires two steps. The first step is to search the matching prefix sequence Sprefix of S in T, and the second step is to create a new path for the remaining non-matching suffix sequence Ssuffix of S in T.

Here we assume equal costs for matching an existing node and creating a new node. Thus, the total cost of inserting a sequential web access pattern S with length m is O(|Sprefix|)+O(|Ssuffix|) = O(|S|) = O(m). The complexity of constructing the entire Pattern-tree from scratch is equivalent to the cumulative cost of inserting all sequential       Algorithm: Recommendation Rules Generation Input:  T --- Pattern-tree based on a support threshold MinSup S = a1a2?an - current access sequence of a user MinLength - minimum length of access sequence MaxLength - maximum length of access sequence, which should  be less than the depth of the Pattern-tree Output:  RR --- recommendation rule of a set of ordered access eventsfor S.

Method:  1: Initialize RR =?.

2: If |S| > MaxLength then remove the first |S|-MaxLength+1  items from S.

3: If |S| < MinLength then return RR, else set current_node point  to the root node R of T.

4: For each item ai from the head of S to the end do  a: If current_node has a child node labeled ai, then set current_node point to this child node.

b: Else remove the first item from S, and repeat from step 3.

5: If current_node has child nodes, then insert these child nodes  into RR ordered by their supports.

6: Return RR.

web access patterns S1, S2, ?, Sl with a total length n, which is O(|S1|)+O(|S2|)+?+O(|Sl|) = O(n).

In practice, web logs are not static since new updates are constantly being added. However, for web recommendation, we can assume it to be relatively static for a certain period of time.

C. Recommendation Rules Generation The Recommendation Rules Generation component  searches for the best-matching access path in the Pattern- tree according to the user?s current access sequence. In general, the longer the user?s current access sequence is, the lower the possibility is of finding the matching path from the Pattern-tree. To increase the applicability of recommendation rules generation, the suffix sequences of the current access sequence will be considered when the matching path of the whole access sequence cannot be found. As such, we will search the matching path based on the same access sequence by removing the first item repeatedly till a matching path is found or when no more item can be removed from the access sequence. In addition, the length of the longest path in the Pattern-tree is the depth of the Pattern-tree. The matching path will not exist when the length of the current access sequence is longer than the depth of the Pattern-tree. Therefore, some initial items can be removed to make the current access sequence shorter than the depth of the Pattern-tree before the sequence matching process begins.

Fig. 3 Algorithm for Recommendation Rules Generation based on the Patterntree.

Generally, the recommendation rules generated from shorter matching paths usually have lower accuracy. In order to improve the precision of recommendation rules generation, only web access sequence whose length is not less than a given threshold can be processed. In other words, the sequence matching process will be stopped if the length of the remaining access sequence is less than the threshold.

Suppose the current access sequence of a user is S = a1a2?an, the algorithm for generating recommendation rules for S, Recommendation Rules Generation, is given in Fig. 3.

Complexity analysis: The cost of looking up the current access sequence S of length m in a Pattern-tree T with MinLength = Lmin and MaxLength = Lmax is O(min(m, Lmax )). The maximum possible number of lookups is Lmax - Lmin. This gives the total cost of matching S as O((Lmax - Lmin)*min(m, Lmax )). The complexity of recommendation rules generation is thus O(Lmax 2), where Lmax should be less than the depth of the Pattern-tree.



III. PERFORMANCE EVALUATION  A. Evaluation Measures Let S = a1a2?akak+1?an be a web access sequence. For the  prefix sequence Sprefix = a1a2?ak (k ? MinLength), we generate a recommendation rule RR = {e1, e2, ?, em} using the Pattern-tree, where all events are ordered by their support.

If ak+1?RR, we label the recommendation rule as correct, and otherwise incorrect.

If there exists ai?RR (k+1? i ? k+1+m, m>0), we deem the recommendation rule as m-step satisfactory. Otherwise, we label it as m-step unsatisfactory.

Let R = {RR1, RR2, ?, RRn} be a set of recommendation rules, where RRi (1? i ?n) is a recommendation rule. |R| = n is the total number of recommendation rules in R. We define the following measures.

Definition 1: Let Rc be the subset of R that consists of all correct recommendation rules. The overall web recommendation precision is defined as  precision= || ||  R RC  This precision measures how probable a user will access one of the recommended pages.

Definition 2: Let Rs(m) be the subset of R that consists of all m-step satisfactory recommendation rules. The m-step satisfaction for web recommendation is defined as  Satisfaction(m)= ||  |)(| R  mRS  The m-step satisfaction is a very important evaluation measure for web recommendation. Actually, the next web page accessed by a user may not be the target page that the user wants. In many cases, a user has to access some intermediate pages before reaching the target page.

Therefore, it is not appropriate if we only use the precision measure to evaluate a web recommender system. The m- step satisfaction gives the precision that the recommended pages will be accessed in the near future (within m steps).

Clearly, the satisfaction and precision measures are equivalent for m = 1. In order to realistically evaluate our web recommender system, m has been set with an appropriate value m = 5 to indicate that the recommended page should be accessed in the near future.

Definition 3: Let Rn be the subset of R that consists of all nonempty recommendation rules. The applicability of web recommendation is defined as  applicability = || ||  R Rn  As the Pattern-tree only stores web access sub-sequences accessed frequently by users (with a support of at least MinSup), the recommendation rules generation approach is unable to find recommended pages if the current access sequence does not include a frequent suffix sequence, in which case the generated recommendation rule is empty.

Therefore, the applicability measure gives a rough idea of how often recommendations will be generated. Some parameters such as MinSup in the proposed approach can influence the applicability of web recommendation.

Generally, the smaller the MinSup is, the more applicable the web recommendation is. But, this comes at the expense of increased sequential pattern mining and Pattern-tree construction cost.

B. Experimental Results Let WAS(MinLength) = {S1,S2, ?,Sn} be the set of web  access sequences, where each sequence has no less than MinLength items, i.e., min(|Si|) ? MinLength (1?i?n, MinLength>0). Given the support threshold MinSup, we construct the Pattern-tree based on WAS(MinLength). Let WAS?(MinLength+MaxSteps)={S1?,S2?, ?,Sk?} (MaxSteps > 0, which is the same as m in the definition of m-step satisfaction) be the set of testing sequences, which is separated from the set of sequences in WAS(MinLength) that contains the training sequences.

10 20 30 40 50 60 70 80 90 100 110  Support Threshold  Ru n T im e (s e c)   Fig. 4 Scalability vs. Support thresholds.

In the first experiment, we measured the scalability of the Sequential Pattern Mining and Pattern-tree Construction processes with respect to different support thresholds. We used CS-mine [8] as the sequential pattern mining algorithm. This experiment used the 22,717 web access sequences with different support thresholds (from 5 to 100).

The experimental results are given in Fig. 4, which shows that the runtime of this process increases sharply as the support threshold is reduced to less than 10.

In the second experiment, the scalability of the precision, satisfaction, and applicability measures of recommendation rules generation had been measured with respect to different support thresholds. This experiment used MinLength = 2 and MaxSteps = 5 with different support thresholds (from 5 to 100). From both experiments, we can conclude that better recommendations can be obtained with smaller support thresholds, at the expense of increased computational  complexity for sequential web access pattern mining and maintaining a larger Pattern tree. Balancing the trade-offs between complexity and applicability, we decided to use a support threshold value of 10 for subsequent experiments.

0% 10% 20% 30% 40% 50% 60% 70% 80% 90%  100%  1 2 3 4 5 6 7 8 9 10  The number of recommended pages  Satisfaction  Precision   Fig. 5 Scalability vs. Number of recommended pages.



IV. CONCLUSION In this paper, we have proposed an intelligent web  recommender system known as WAPPSbased on sequential web access patterns. In the proposed system, the sequential pattern mining algorithm CS-mine is used to mine frequent sequential web access patterns. The mined patterns are stored in the Pattern-tree, which is then used for matching and generating web links for online recommendations. The proposed system has achieved good performance with high satisfaction and applicability.

