Rough Set-based Debugging for Web Services System

Abstract ?Web services technology provides a flexible and cost-effective paradigm to construct highly dynamic systems through service discovery, composition, and ultra-late binding.

However, its new features bring great pressure to maintain Web service-based system. Based on the massive testing results, how to locate the fault points in system is a challenging task. In the paper, a two level diagnosis framework for Web services system is proposed. In service unit level, the WSDL interface information is used to construct decision table. In service composition level, the decision information system is built by comprehensively using process specifications and interface information. Then, rule mining algorithm in rough set reasoning is adopted to reveal the input cases associated with service or system failures. How to utilize such rules to locate faults in Web services system is also discussed. In addition, two cases are introduced to validate the feasibility and effectiveness of our approach.

Keywords ? Web services; debugging; service composition; association rule; rough set reasoning

I. INTRODUCTION In recent years, service-oriented architecture (SOA) is a  prevalent pattern to construct a new system or integrate the legacy applications. In fact, it?s an architecture that represents software functionality as discoverable services on the network [1]. Web service [2] is the representative technology of this software pattern, which provides a flexible way for applications to interact with others over network through a set of standards, such as WSDL [3], SOAP [4] and BPEL [5]. Although Web services technology has been widely applied in software industry, and a lot of Web service systems have been put into use, there are still some challenging problems, such as quality assurance of Web service system.

Since Web service system is composed of some self- description, distributed and heterogeneous service units, whose code is infeasible for service users, how to maintain such new style software is a troublesome problem in the field of software engineering [6]. Over the past years, researchers focused on the testing stage, and quite a few testing methods are proposed. Of course, almost all methods belong to functional testing. Although testing is an important means of software quality assurance, the latter stage of debugging should not be ignored.

In order to reveal the most potential defects in software, testing organization usually adopts plenty of test data to execute software. Accordingly, the test results produced by  such process are also very large. How to use them to locate the bugs is a time-consuming stage at all. Until today, some methods such as statistical analysis [7] and data mining [8-12] have been utilized to tackle this difficulty. Most of them are based on the trace information (also called execution spectrum) [13,14] with respect to software?s structural testing. However, service?s code is infeasible for system developers and maintainers (i.e., service users). Hence, useful information from system testing is very limited for the purpose of defect diagnosis. Under this condition, the rational solution is to fully utilize the testing result information to reveal the clue of potential defects. In the paper, we attempt to adopt rough set reasoning technique to derive the association rule from the testing information set, and then use these rules to locate the fault position with the help of programming slicing technology.

The rest of this paper is organized as follows: Section 2 describes the background information about Web services system and its testing. The overall diagnosis framework is addressed in Section 3, the instrumentation method used to collect execution information is also discussed. Then, rough set-based debugging method is proposed in Section 4, and followed by a literature review and conclusions in Section 5 and 6, respectively.



II. BACKGROUND A Web service is defined by the W3C as ?a software  system designed to support interoperable machine-to- machine interaction over a network? [2]. It can also be treated as an internet-based application fulfilling a specific task or a set of tasks, which can be combined with other Web services to maintain workflow or business transactions [6,15].

In fact, Web services are usually Web application programming interfaces (APIs) that can be accessed over a network such as the Internet, and executed on a remote system hosting the requested services. This new technology mainly involves three kinds of shareholders, that is service provider, registration center and service requestor. On the side of service providers, they are responsible for developing service and publishing the service onto registration center. In general, service code runs on the provider?s Web server, and only interface information is stored in registration center. So the source code of Web service is transparent for other two sides. Service requestor uses the standard interface protocol to invoke service through passing the specific context parameters and gathering return value.

2010 IEEE Asia-Pacific Services Computing Conference  DOI 10.1109/APSCC.2010.63     Service interface information is usually written via Web service description language (WSDL) [3], a XML format standard drawn up by W3C organization. In this exchange document, the parameter types of input and output are explicitly defined. The data passing from service requester to Web server is encapsulated in accordance with the simple object access protocol (SOAP) [4]. Except from the pre- defined WSDL file, the service provider and requester perhaps may make some agreements about the service invocation and QoS assurance, i.e. service level agreement (SLA).

Due to the code infeasibility for service users, they have to choose the functional (or black-box) testing methods to validate service quality. Among them, equivalence class partitioning, boundary value analysis, decision table [16], random testing and combinatorial testing [17] are the typical ones. The test cases produced by the above methods usually consists of two parts: input data and expected results (i.e.

oracle). Of course, some testing approaches without oracle, such as metamorphic testing [18], are also adopted to test Web services system. But this method is not so general for requiring some invariant relations in system specifications.

As a loose-coupling application, Web service-based system is implemented by means of Web services compositions (WSCs). Its business workflow is usually modeled by using process languages like WS-BPEL [5], BPML [19] and OWL-S [20] etc. In these business specifications, Web service units are composed together via some specific logics, such as sequence, branch, and parallel.

In a system, services are usually from different service providers. Therefore, once the failure occurs in WSCs, it?s too hard to locate the faulty service unit. The current solutions for testing Web services system are mainly to model the control flow of business workflow in graphical notation at first. Then, control flow testing and data flow testing are carried out according to these construct representations.



III. SYSTEM DIAGNOSIS FRAMEWORK  A. Overall Diagnosis Framework In this section, we consider Web services system  diagnosis problem in the following two ways: single service debugging and WSCs debugging.

Single Web service debugging. In this case, it should extract interface information from the specifications such as WSDL and SLA, and then use it to build a test driver.

Because the test cases are generated by the approaches such as equivalence class partitioning and decision table, the produced test results can easily form an information system (IS). Accordingly, the failure related association rules can be generated through performing rough set reasoning on IS.

Web services composition debugging. For the system composed of several Web services, its diagnosis activity is more complex than the case of single service unit. Even though a service unit itself has no problem, its interaction with other services will cause defect in some cases. For Web service composition, it also needs to analyze interface information for each service in system. Meanwhile, business  workflow should be modeled from the process specifications such as BPEL or BPML file. Based on the above information, the system can be instrumented to record service invocation and monitor system?s output (or exception behaviors). After achieving each service?s input parameter and the corresponding system behavior, rough set technique can be adopted to generate the association rules for system failures.

Finally, the achieved rules can be used for further service configuration checking or service validation on provider side.

Figure 1.  Diagnosis framework for a single Web service  The key step in this intelligent diagnosis framework for Web service-based system is the collection activity for input data and system behaviors. Here, we utilize instrumentation technique to record service?s input data, and adopt monitoring strategy to gather system output information.

B. Information Collection In this section, we used BPEL-based WSC to  demonstrate the instrumentation for collecting Web service invocation information. For each service invocation, it will appear in the following form:  <invoke name="..." partnerLink="..." portType="..." operation="..." inputVariable="..." .../>  Aspect-oriented programming strategy is adopted to record the input parameter of each service port. We designed an aspect to record each service?s operation invoking. Of course, this specific aspect can also be encapsulated as a service in the whole system. Then, the input data set of each service interface can be further divided into several equivalence classes.

The normal output of a service operation invoking is usually returned with outputVariable clause or <receive .../> statement in BPEL program. All normal outputs are classified into the non-failure case. We utilize the exception handling mechanism in BPEL standard to tackle abnormal exist of whole system, and classify the failures according to exception types.

Based on the above treatment, two parts of the collected information all can be divided into the forms of some equivalence classes (refer to Figure 3).

After achieving the above partitioning criterion, we can translate the test cases, which include input data and test     oracle (i.e., expected output), into table records. In these records, the specific inputs are converted into the equivalence class flags, and the failures are also mapped into several types. It is not hard to find that, these execution records of test cases can be stored in the form of decision table.

equivalence class 1  equivalence class 2  equivalence class m  exception 1  exception 2  exception k   Figure 3.  Demonstration for input data and system behaviors partitioning

IV. ROUGH SET-BASED DIAGNOSIS  A. Basic Concepts of Rough Set Rough set theory, proposed by Z. Pawlak in 1982 [21], is  a formal method used to tackle incomplete and undetermined knowledge. Different from the traditional statistic techniques, this method doesn?t need the additional and priori knowledge but only uses the information provided by the data itself.

Based on the direction of set theory, it performs processing on the uncertain knowledge through classifying the observed or measured data.

In general, the decision table (DT) is an important part of knowledge expression system in rough set reasoning. To make the paper self-content, we first review the basis about rough set [21].

Definition 1 A knowledge expression system can be denoted as ( ,  ,  ,  )S U C D V f? ? , where 1 2{ , , ,S X X? ?  }nX  is the set of objects, A C D? ? is the set of attributes, which can be divided into conditional attribute set ( C ) and  decision attribute set ( D ). These two subsets hold restrictions such as C D A? ?  and C D? ?? . (V ?  ,  )a A aU V?  is the set of attribute?s value, and aV  is the range of value of attribute a . :f U A V? ?  is an information function, which assigns a value to each attribute of each object, i.e., ,  ,a A x U	 ? ?  get ( , ) af x a V? .

As mentioned in Section 3.2, the collected execution information of test cases can be easily transformed into decision table. However, decision table is an important and useful style for expressing information in rough set reasoning.

Therefore, rough set reasoning technique is very useful to analyze the black-box testing results of Web service-based system.

Extracting rules from information system is the main task in the field of data mining or knowledge reasoning. In general, four kinds of rules can be mined from data, i.e., characteristic rule, association rule, discriminant rule, and classification rule. Here, we mainly use rough set-based reasoning to mine association rules from test results, and then employ these rules to program debugging.

Definition 2 Given an information system ( ,  S U C? ? ,  ,  )D V f , and G  and H  are subset of conditional attributes  and subset of decision attributes respectively. g h?  means a decision rule, where g  denotes the pre-condition of rule, and  h  denotes post-condition of rule.

The relation between input and output of program is the typical cause-effect mapping rule. For software debuggers, the chief task is to find the reason causing software failure.

When the input and output are converted into the decision table, the cause-effect rule in the form of g h?  can be easily deduced via rough set reasoning.

Definition 3 For any two objects y x , if the condition | | | |x y x yd C d C d D d D? ? ?  is satisfied, then we call xd  is  consistent, otherwise not. Here, xd  is a rule in system S , |xd C  is the pre-condition of rule, and |xd D  is the post-  condition.

Figure 2.  Diagnosis framework for Web service compositions     Due to the causes of system failure varies, the debugging rules formed as ?reason ? failure type? may be inconsistent. In this section, we mainly discuss the situation of consistent rules mining. The treatment for inconsistent case will be discussed in the latter section.

B. Debugging for Single Web Service Web services technology was earlier used in e-commerce  systems such as Amaze.com. In the online sales system, the most frequent activity is to treat price query. In this subsection, we introduce the price query service to demonstrate the Web service debugging with help of rough set reasoning.

Case Study 1. Suppose there is a Web service unit for querying computer price at present, which can be denoted as Web Service: PriceQuery(M,V,S,C). The first input parameter represents manufacturer who can produces computer, the second stands for the variety of computer product, the third is the flag of screen size, and the last one represents which city sells the computer. The possible value can be assigned to input parameter of service unit as expressed in following table.

TABLE 1.  TABLE TYPE STYLES POSSIBLE VALUES FOR INPUT PARAMETERS OF PRICEQUERY SERVICE UNIT  No. Parameter Detailed Values  1 manufacturer Lenovo, TCL, Dell  2 variety home PC (HPC), business computer (BC), notebook (NB)  3 size 15 inch, 14 inch, 12 inch  4 city Beijing (B), Shanghai (S), Hangzhou (H) In order to test the above Web service, tester should  prepare some test cases and observe their execution behaviors. Here, we suppose that testers perform testing on that application with fifteen test cases. Eleven out of them are running without failure, so we denote their output as ?Succ.? (see Table 2). However, the remaining four threw two kinds of exceptions, which are respectively marked with E1 and E2.

TABLE 2.  TEST CASES FOR THE EXAMPLE SERVICE UNIT PRICEQUERY  No. Manu. Variety Size City Result  t1 Lenovo HPC 15 inch B Succ.

t2 Lenovo BC 12 inch H E1 t3 Lenovo BC 14 inch B Succ.

t4 Lenovo HPC 14 inch S Succ.

t5 Lenovo NB 12 inch H Succ.

t6 TCL BC 12 inch S E1 t7 TCL HPC 14 inch H Succ.

t8 TCL NB 12 inch S Succ.

t9 TCL NB 14 inch B E2 t10 TCL BC 15 inch H Succ.

t11 Dell HPC 14 inch B Succ.

t12 Dell BC 15 inch H Succ.

t13 Dell NB 14 inch B E2  t14 Dell HPC 15 inch S Succ.

t15 Dell NB 12 inch S Succ.

In order to facilitate the reasoning process, we denote the  four parameters with symbols M, V, S and C. Accordingly, the output parameter is denoted as D. Based on the above DT, we can find that 1 4 7 11 14( ) { ,  ,  ,  ,  }VPos D t t t t t?   is the biggest one in the set of ( )MPos D , ( )VPos D , ( )SPos D  and  ( )CPos D . Hence, the following rule can be derived out.

.Variety HPC Result Succ? ? ?                            (R1)  Then, a new decision table (ref to Table 3) can be rebuilt though removing the records t1, t4, t7, t11 and t14.

TABLE 3.  THE NEW DECISION TABLE AFTER REMOVING RECORD IN ( )VPos D  No. Manu. Variety Size City Result  t2 Lenovo BC 12 inch H E1 t3 Lenovo BC 14 inch B Succ.

t5 Lenovo NB 12 inch H Succ.

t6 TCL BC 12 inch S E1 t8 TCL NB 12 inch S Succ.

t9 TCL NB 14 inch B E2 t10 TCL BC 15 inch H Succ.

t12 Dell BC 15 inch H Succ.

t13 Dell NB 14 inch B E2 t15 Dell NB 12 inch S Succ.

For the new table, we can gain the following  classifications through considering the values of conditional and decision attributes.

2 6 3 5 8 10 12 15 9 13/ {( , ),( , , , , , ),( , )}U D t t t t t t t t t t? 2 3 5 6 10 8 9 12 13 15/ ( , ) {( , ),( ),( , ),( , ),( ),( , )}U Ind M V t t t t t t t t t t? 2 5 3 6 8 9 10 12 13 15/ ( , ) {( , ),( ),( , ),( ),( ),( ),( ),( )}U Ind M S t t t t t t t t t t? 2 5 3 6 8 9 10 12 13 15/ ( , ) {( , ),( ),( , ),( ),( ),( ),( ),( )}U Ind M C t t t t t t t t t t?  2 6 3 5 8 15 9 13 10 12/ ( , ) {( , ),( ),( , , ),( , ),( , )}U Ind V S t t t t t t t t t t? 2 10 12 3 5 6 8 15 9 13/ ( , ) {( , , ),( ),( ),( ),( , ),( , )}U Ind V C t t t t t t t t t t? 2 5 3 9 13 6 8 15 10 12/ ( , ) {( , ),( , , ),( , , ),( , )}U Ind S C t t t t t t t t t t?  It is not hard to find that ( , )( )V SPos D  is the largest one of the six positive domains. Therefore, five associate rules can be induced according to the classification / ( , )U Ind V S  as below.

12  1Variety BC Size Result E? ? ? ? ?                (R2) 14  .Variety BC Size Result Succ? ? ? ? ?            (R3) 12  .Variety NB Size Result Succ? ? ? ? ?            (R4) 14  2Variety NB Size Result E? ? ? ? ?                (R5) 15  .Variety BC Size Result Succ? ? ? ? ?            (R6)  Among the above six rules, only R2 and R5 are related with Web service failures, so these two rules should be used for the next-step debugging. In general, service user (or called requester) will feedback this information to service provider so as to improve the quality of service.

C. Debugging for Web Services Composition Generally speaking, a Web service-based system is  constructed by composing quite a few service units. Thus, once a failure occurs in the system, it is very hard to judge     which part or interaction is the source of accident.

Furthermore, even each Web service has been ensured no problem, we can?t guarantee they can successfully interact with each other. Therefore, debugging for Web service composition is necessary, but a challenging task.

Case Study 2. Suppose there is a demo Web service- based system, named TravelDemo. Three service units are invoked in this system, that is, FlightBook, HotelBook and Payment, and the composition logic can be described by BPEL file as shown in Figure 4. In each Web service, it can receive the input message in the format defined in WSDL file. In this example, all three service have input variables in complex type. For FlightBook service, its input message includes three parts: airComp (i.e. airline company), seatType (senior or economics) and lineType (direct or transfer). Suppose the input message of service HotelBook consists of two parts, i.e., starLevel and roomType. The input of service Payment can be divided into two parts: payWay (i.e., VISA, Master or Unionpay) and amount.

<?xml version="1.0" encoding="utf-8"?> <process name="TravelDemo" ...> <partnerLinks>  ......  </partnerLinks> <variables>  <variable name="flightRequest " ?/>  ?? </variables> <sequence> ??  <flow> <sequence> <invoke partnerLink="FlightBook" operation=" bookFlight" inputVariable="flightRequest" .../>  <receive partnerLink=" FlightBook " operation=" flightCallback" variable="flightResp" .../> </sequence>  <sequence> <invoke partnerLink="HotelBook" operation=" bookHotel" inputVariable="hotelRequest" ?/>  <receive partnerLink=" HotelBook " operation="hotelCallback" variable="HotelResp" ?/> </sequence>  </flow> ??  <invoke partnerLink="Payment" operation="paySubscription" inputVariable="payInfo" .../> </sequence> </process>  Figure 4.  BPEL program of the TravelDemo system  For the diagnosis of WSC, the conditional part of decision table of each service should be constructed first, then incorporated into a bigger decision table. In the whole DT as shown in Table 4, the decision part is the behavior of the whole Web service-based system. Take Web service composition TravelDemo for example, the decision table for system diagnosis includes seven conditional attributes, such as airComp, starLevel, and payWay. The observed behavior is the decision attribute of whole information system.

In general, the attribute with discrete value can be easily conducted to form several equivalence classes. But, for the attribute with continues data type, it is hard to partition its value. Its partitioning should dependent on the maintainer?s domain knowledge. For the example system in this subsection, we divide the attribute of payment amount into three intervals: (-, 0), [0, M], (M, +). Here, M represents the reasonable threshold of payment for booking flight and hotel, symbols + and ? stand for the positive and negative infinity respectively.

Another case should be taken into consideration, that is, some services are located in different branch structures of BPEL specification. For the reason of branch execution, some services can not be invoked, so their parameters have no specific value. Here, we assign any value (denoted as asterisk) to the corresponding conditional attributes in decision table.

After the decision table for whole Web service composition is achieved via the above method, we can perform the same rough set reasoning algorithm to mine the rules associated with system failures.

D. Discussion For the parameter value of each service interface, we  adopt the equivalence class method to classify it into a specific category. Although it is beneficial to construct decision information table, it will also bring trouble to the further reasoning, that is, inconsistent record in decision table.

Due to the arbitrariness of equivalence partition, two cases with the same input data will produce different output, e.g. one can successfully run and the other maybe cause a runtime exception. Accordingly, these two test cases will  TABLE 4.  THE DECISION TABLE FOR THE WEB SERVICE-BASED SYSTEM TRAVELDEMO  FlightBook HotelBook Payment No.

airComp seatType lineType starLevel roomType payWay amount Result  t1 CZ senoior direct 5_star single VISA [0, M] Succ.

t2 MU economics transfer 3_star standard Unionpay (-, 0) E1 t3 ZH economics direct 4_star standard Master [0, M] Succ.

... ... ... ... ... ... ... ... ...

ti MU senoior transfer 5_star standard VISA (M, +) E2  ... ... ... ... ... ... ... ... ...

tn CZ economics direct 3_star single Unionpay [0, M] Succ.

* Here, E1 and E2 denote two exceptions respectively, and M is a threshold value of payment.

bring inconsistent objects into decision table. To handle the inconsistency in decision table, reference [22] proposed an algorithm named LEM2 to extract rules from that table. Its main idea can be described as below: At first, it computes the super proximity ( *( )R X ) and inferior ( *( )R X ) for each attribute classification X . Then we can generate deterministic rules from *( )R X  and probabilistic rules from  *( )R X . The final output rules are the sum of these two kinds of rules.

The second threaten is the uncertain attribute value problem mentioned in the above subsection. That is to say, the value of some attributes is undetermined or arbitrary.

Fortunately, this case has been studied in the field of intelligent information processing. The typical treatment can be addressed as below: the undetermined attribute value can be denoted by *, the corresponding information system (IS) is called incomplete IS. Then, the decision rules can be directly derived from such an incomplete decision table according to the algorithm in [23].

The last problem is how to locate the faults according to association rules produced by rough set reasoning. In service unit level, service providers (or developers) can use the traditional program slicing technique to find defect. Since Web service is usually written in the common language such as Java or C#, the existing slicing method can handle this matter. In the service composition level, except for the independent debugging of each service unit, our previous work in [24] can settle this problem. The technical sketch is to build a BPEL program dependence graph through in-depth analysis on the new activity elements such as flow and pick.

Then the dynamic backward slicing algorithm is proposed to find the statements closely related with the specific value of some variables. For a system failure rule r , assume  ( , , )i iDynSlice v l t  is the dynamic slicing results for conditional attribute iv  with value t  at the line il  in BPEL program. Then, the intersection 1 ( , , )  n i ii DynSlice v l t??  is the  suspect statements in BPEL file, where n  is the service unit number in whole system.



V. RELATED WORK Software debugging is an important task after the testing  activity. In recent years, the automated debugging has aroused lots of interests both in academic and industrial fields. However, the diagnosis or fault localization for Web service-based system has not caused enough attention until today.

When the source code of program is visible, the methods in machine learning and data mining have been adopted to find the knowledge which can assist debugging activity. In order to avoid repetition of debugging activities, Dickinson and Podgurski initially employed clustering analysis on failure executions, and sampled several records from each cluster to assist debugging [8]. Li and Zhou adopted another data mining technique, i.e., frequent item-set mining, to mine usage patterns among the execution records of program elements [9]. Other methods such as nearest neighbor query [10], Bayesian reasoning [11], frequent pattern mining [12]  and statistical method [7] have been widely used for locating faults in program code. The execution history of statement, branch or path is an important evidence to reveal the defects, so the spectrum-based method [13] and its variants [14] have been validated as an effective way for software debugging.

However, the source code of Web service is invisible for service user (i.e., developer of Web service-based system) in most cases, so the traditional program code-based debugging methods is not suitable for Web service system. Based on our previous work [25], we adopt the rough set reasoning to find the knowledge rules for the depth fault location.

In the existing fault diagnosis of Web services, monitoring-based method [26] is the typical one. In this diagnosis model, the sending or receiving information of each service interface is monitoring via embedded object, and then compare this information with the expected states to locate the abnormal service unit. L. Ardissono et al. proposed a model-based diagnosis method to enhance fault analysis [27]. They add to each service a local diagnoser which relates hypotheses about incorrect outputs of itself or incorrect inputs from other services. Meanwhile, a global diagnoser service is used to perform message exchanging and global diagnoses. In addition, Bayesian network-based method [28] is also used to identify the most likely problematic services in a Web service composition process.

In our work, another intelligent analysis technique, rough set reasoning, is introduced to settle Web service debugging problem.

Generally speaking, program slicing is a useful fault location technique for software maintainers. In service unit level, the service providers can slice service?s code to find the potential defects according to the feedback from service requesters. In service composition level, the workflow of whole system is usually described in the process specification language such as WS-BPEL [5], and OWL-S [20]. In order to reveal the interaction faults between services, the composition code written in these languages should be analyzed. In [24], a method for slicing BPEL programs in Web service compositions is proposed. When the suspect BPEL code is exposed, the composition logic should be further checked. So the WSC slicing method can be treated as the complement step after achieving the failure association rules.



VI. CONCLUSIONS Web services technology is a new pattern for integrating  the programs or components over the Internet. Due to its merits such as loose-coupling, language independence, and distributed execution, it has been widely adopted to construct complex software system. However, the above features bring some inevitable trouble to maintain Web service-based software. In recent years, the researches mainly pay attention to Web service testing techniques. But the testing activity is mainly to find the input cases associated with system failures.

According to the testing results, how to expose the defect point in Web service system is still an open problem.

In the paper, a system diagnosis framework based on rough set reasoning is proposed. Two level debugging models, i.e. single service debugging model and Web service     composition debugging model, are discussed in details. After the decision table is constructed through collecting WSDL interface information, composition process specification, and testing execution information, rule extraction algorithm in rough set reasoning is used to find the rules associated with system or service failures. In addition, the feasibility and effectiveness of our approach are validated by two examples and experiments. At present, we only consider the debugging problem for the common Web service system, the fault location for semantic Web services should be further explored in the on-going research.

