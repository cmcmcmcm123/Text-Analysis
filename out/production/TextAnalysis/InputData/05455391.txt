Building a resource overlay for distributed  monitoring*

Abstract?To address the problems of resource sharing and utilization in the distributed environment, the paper aims to establish a resource overlay for the distributed system monitoring. The resource overlay can construct a logical space, and the type of the nodes in the space can be classified as host node and resource node. The host node and resource node are mapped into the logical space of network by the consistent hash function and the location preserving hash function respectively.

An improved DHT algorithm is used to establishing the resource overlay, and supporting the range query for the resource information.  Experiments have proved the validation of the method, and the results show that it is an effective method for finding the available resource in less routing hops.

Keywords- resource overlay; distributed  resource monitoring; DHT; location preserving Hash.



I.  INTRODUCTION Effective resource monitoring in a large-scale distributed  system, such as server, network, memory, storage and some other specific resources, will affect the performance of the system. The monitoring data can be used for load balancing, job scheduling, fault diagnosis, and quality of service in the distributed system. Therefore, it is important to build a resource overlay for the distributed system monitoring. The resources include the state of the system, performance parameters, applications, and process monitoring status about nodes of the distributed system. The performance parameters mainly refer to CPU utilization of each node, memory usage, I / O of disk, network throughput, etc.

The core idea of DHT (Distributed Hash Function) is that the distributed object is stored in the node using the Hash Key, which can be calculated from the features (keywords) of the storage object by the hash function. However, DHT algorithm only supports exact query, not for the range query. There are already some research works in the improving of DHT algorithm for the distributed resources monitoring. In paper [4], the method builds a mapping between resource types and the host node of the resources. While it can narrow the range of the routing in resources discovery, but in order to achieve the range query it still need to traverse the total relevant node. In the distributed environment with a large amount of nodes, this method is less efficient. SWORD[2] uses a kind of DHT algorithm for resource discovery, but it does not take into account the resources discovery in multiple domains.

Different from the above methods, the paper will map the distributed computing nodes and attribute information to host node and resource node in logical space of the resource overlay, modifying association rules of the distributed system nodes and the logical space, and take a different mapping method in order to achieve the range and multiple attributes query of resource node. Experiments show that the method can quickly find the right resources under the less routing hops and lower delay.



II. THE METHOD FOR RESOURCE SHARING BASED ON DHT ALGORITHM  A. The resource overlay We build a resources overlay for distributed monitoring  based on the layered framework (fig 1). The architecture consists of two layers: the upper layer is function layer to provide the action interface for the resources monitor of node; The lower layer is implementation level including the directory service module, searching and maintaining the attribute information, updating mechanism, the routing module guiding the forwarding for the news service and maintaining the topology, and the messaging service module for the communications among the nodes.

Figure 1.  Framework of Resource Overlay  The resource monitor is deployed in each node to detect the performance metrics in the resource overlay. The resource metrics are classified into two types: numeric attribute and string attribute. The numeric attribute can be integer or floating type. The resource attributes such as the information of CPU        and memory, the status of net devices and partitions, the average of load and up time are numeric type, which play an important role in the selection resources and is the most critical resources for the query to support fuzzy query. Some other resources like available devices attributes are string type, and require exact match. The range query is about the search of numeric type. According to the requests from each node, the matched resource can be searched by the range query.

The logical node is consisted of host node and resource node, respectively mapped by the consistent hash and the locality preserving hash[1].

FunctionHashfoResourceInshResourceHa FunctionHashConsistentNodeHash  )aleattributeVameattributeNRHash(resourceID Address)NHash(nodenodeID  peerID  ?? ??  ? ? ?  ><= =  =  : ,:  , (1)  NodeID expresses the computing node in the distributed system and is the only variable. Resource node corresponds the attribute information of the computing node in the distributed system, which is described by three-tuple: (resourceID, resourceInfo, addressInfo). The resourceInfo describes information for the resource attribute, and addressInfo is for resource location. The resourceID is marked for the location where resource attribute information is in the logical space. It is a numeric type attribute and has a partial order relation with attribute values. Resource node is determined by both resourceID and addressInfo corresponding with each attribute.

The information of three-tuple, stored on the immediate successor resource node, is maintained by host node in the logical space. Indexing information for each resource node is only stored in one host node.

The method improves Chord algorithm[5] that the length of the logic of the space is 8 bits and the number of node name is the ID of node. Figure 2 shows the model for the improving algorithm. When computing resources of the distributed system join in the network, they firstly publish the information to host node, and then to the network. The information of resource node will eventually be routed to its corresponding with immediate successor node. If node7 is res2 and res5 direct successor node, the three-tuple corresponding with these resource nodes will be stored on node7. The query on resource node is to send message to the immediate successor node to search.

Due to support the range query for resource node and maintain the partial order relation between the attribute, the resource node ID corresponding with node60 is larger than node150; As a result of node100 and node150 have the same CPU idle which is 0.75,  the direct successor of res14 saves two different resource nodes with 14 as their ID.

Figure 2.  The model of the improving algorithm  B. Mapping algorithm on resource node The locality preserving hash[1] function has the following  property:  1) H( iv ) < H( jv  ) iff iv  < jv  , and if an interval;  2)[ iv , jv  ] is split into [ iv , kv ] and [ kv , jv ], the corresponding interval [H( iv ),H( jv )] must be split into [H( iv ),H( kv )] and [H( kv ),H( jv )].

H(v) in our method is suitable with the property of the locality preserving hash.

Vale)(attributeHName)(attributeH valueIDtypeID  )aleattributeVameattributeNsh(resourceHa resourceID   ,  ?= ?=  ><=   (2)  Equation (2) shows the mapping function of resourceID.

Here, 1H  is the consistent hash function, and 2H  is the location preserving hash function. The filed of NodeID is divided into two parts as attribute type field of m bits and attribute value field of n bits. The consistent hash function is used to map the attribute type, in order to make the attribute of node uniformly distributed in the logical space avoiding the condition of the load imbalance. The logical space is divided into the space of multiple attribute by the ID of attribute type.

The query of the attribute is along the corresponding arcs. The method supports the changes of resource attribute types. The value of the attribute is mapped by the locality preserving hash function keeping a partial order relation with the attribute type.

We give an example: host node is buaa/202.112.136.231: 4133, and its information of resources attribute described by RSL as shown in table 1. According to RSL description, we compute the ID of host node by the consistent hash function to get the  nodeID of host node with 160 bits for 28482ba862b4dc66ce0ebe7bef5dd806cac5114e, corresponding       to a list for triple of resources node as shown in Figure 3, the front 16 bits of resourceID is for the distributed management domain ID. After the domain ID is the property of four types of ID, Figure Cpu idle rate of the attribute type. The last 128 bits of  resourceID is attribute value ID of resource.

TABLE I.  THE MAPPING FOR THE RESOURCE INFORMATION  Description for distributed  resource  Three-tuple for resource node  cpu-speed (3.0GHz)  (c9a3,760d,5b632fe0865ea889b1ddffa43df30920, Cpu : 3.0GHZ, buaa/202.112.136.231:4133)  cpu-idle (0.682)  (c9a3,bc27,47b1209d4f48f81d86ef602f39ead05c, Cpu-idle : 0.682, buaa/202.112.136.231:4133)  memory-size (1024)  (c9a3,0259,076e9b0b3ce4627c6eef91485bfc40a8 , Memory : 1024, buaa/202.112.136.231:4133)  memory-idle (0.237)  (c9a3,0f65,71ab56eba6d6ba7a4a25bd1f527f0ffc, Memory-idle:0.237,buaa/202.112.136.231:4133)  C. The query and update of resource node Single-attribute query approach is as follows: assuming  query resources of node0 is in accordance with v ( uvl ?? ).The node0 constructs a query request ),,(_ XRkrangeQuery . k is the key for Chord routing, initially k=H(l). R is the expected range of attribute value. X is a list of resources discovered in the range. Initially, X is Null. node0 sends the request to the target nodek. When node1 receives the query request, it searches the local resource entries and adds the matched resources to X. Then node1 checks whether it is the successor of H(u) also. If true, it sends back the search response to node0 with X. Otherwise, it forwards the query request  ),,(_ XRkrangeQuery  to its immediate successor nodej. nodej repeats the process until forwarding to nodeu.

In terms of the definition of H(u), the value of resource node is in the range of [l, u], and the immediate successor node must be located between node1 and nodeu in the Chord ring. So the above query algorithm is complete. Obviously, the query request takes )(log NO  hops for N nodes. The next sequential forwarding from node1 to nodeu takes )(lenO , where len is the number of nodes between node1 and nodeu. So there are total  )(log lenNO +  routing hops to resolve a range query for single attribute. Since there are len nodes that might contain the resources matching the range query, we have to visit all of those len nodes to find the correct search result. In this sense,  )(log lenNO +  routing hops is optimal for range query.

Multi-attribute query approach: node0 divide query{ 000 uvl ?? && 111 uvl ?? && 222 uvl ?? ? nnn uvl ?? } into a number of single-attribute query iiii uvlv ??,  ,then send query request ),,(_ iii XRkrangeQuery to the corresponding attribute domain successively. Finally node0 calculates the intersection of each result collection: X = iXXX ...10 ?? .X is the final result. It takes ))(log( ilennOMax + , which depends on the largest time-consuming query.

Due to the dynamic attribute of distributed resources, the information for resource node is invalid after the change of the attribute value.  In order to ensure the accuracy of resource monitoring, we need to monitor the change conditions for the resource node and update the resource information. The process for the updating is that host node sends messages to request for deleting the invalid resource node, and then publishes the latest resource node to the network. The complexity of the method is )(lognO .



III. EVALUATION In this section, we present evaluation results.

A. Explaination  TABLE II.  ATRRIBUTE OF ACTION  Action of host node Interval of action Consumption of bandwidth  Distribution of attribute information  The node join the network  Yes  Change of attribute information  Based on the attribute value  No  Detection of attribute update  [1s,90s] No  Request for query [1s,45s] Yes Maintaining for topology  [5s,600s] Yes  Table 2 shows the setting of the node action in the simulation environment. The resource information is disseminated while host node is on initialization.

TABLE III.  LIST OF RESOURCE ATTRIBUTE  Type of resource Changing frequency  Update threshold Range of  attribute value Cpu  Static - [500MHz?5GHz]  Memory static - [32M?4096M]  Cpu-idle [1s,30s] 8.7% (0,1)  Memory-idle [1s,45s] 8.7% (0,1)  Bandwidth-idle [1s,45s] 8.7% (0,1)  As shown in table 3, there are five types of resource attribute, including the static attribute such as dominant frequency of CPU and Memory value, and dynamic attribute for CPU, Memory and idleness of bandwidth. In the paper, experiments conduct on the wave of TS10000 cluster and the largest number of nodes for the simulation is 5000.

B. Result    Figure 3.  Response time of random resource query  Figure 3 is an analysis on the delay of the query with non- empty value. When the number of nodes reaches 5000, the delay can still be controlled within 2 seconds; moreover, the rate of the growth is very stable, which is lower than the growth of the host node.

Figure 4.  Response time of latency  Figure 4 is a comparison of average delay between random query and enumeration query. The growth rate of the delay is declining with the increasing numbers of the nodes in enumeration query. Due to the delay of the two queries raises, the growth rate of the response time in enumeration query is higher than that in random query.

Figure 5 shows the comparison of the average routing hops for query. The growth of the hops is similar with the delay of the query. While the numbers of the nodes are fewer than 800, the average routing hops is lower than nlog  due to the policy in the experiment is maintaining the whole network topology. it is an effective method for finding the available resource in less routing hops.

