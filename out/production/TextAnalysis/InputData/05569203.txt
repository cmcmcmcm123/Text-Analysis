

Abstract?With the rapid development of online shopping, electronic commerce has offered a new channel for instant on-line shopping. It is necessary for company to on-line one-to-one market to e-shoppers. Therefore, the ability to predict e- shoppers? purchase behavior basing on data mining  has become a key source of competitive advantage for company. Frequently occurring sequential patterns, identified in sequences in a large dataset, comprise lists of subsequences. Sequential pattern mining is crucial to data mining domains. In this paper, the concept of sequence close level is proposed for counting the distance between a pair of items of k-trees pattern in a transaction sequence. This paper presents a novel data mining approach for exploring hierarchical tree structures, which includes algorithm 1 and algorithm 2. The approache not only counts the frequency of occurring patterns, but also addresses the distance between a pair of items of k-trees pattern in a transaction sequence. The better result is achieved by applying the new approache to a given database for e- shoppers.

Keywords-e-shopper;  rule;  sequential pattern; tree

I.  INTRODUCTION During the last few years more and more organizations  develop sophisticated interactive web environments to accommodate the on-line shopping experiences for consumers.

Shoppers desire to define their preferences and customize the purchase information within the electronic shopping environment according to their individual needs. E-shoppers? wants and needs change more rapidly[1]. Therefore, today marketers face the challenge of a constantly evolving market where customer?s needs are changing all the time. In such an environment, marketers must understand e-shoppers? needs and their changes in time, and accordingly develop correct marketing strategies to satisfy customers? needs in order to survive and gain a competitive advantage.

Data mining is crucial for extracting and identifying useful information from a large amount of data [2-5]. Typically, data mining is used in statistical analysis and modeling when mining valuable patterns and their relationships from substantial amounts of data.

So far, a good number of efficient methods for extracting sequential patterns have been proposed [6-8]. The many algorithms are utilized to mine sequential patterns or frequent  patterns in time-based data. Sequential pattern mining has already become one of the widely applied techniques in data mining. However, at the present time, there usually are two principal approaches to be used to extract sequential patterns: methods based on association rule mining[9-11] and techniques based on using regular structures to denote navigation patterns, such as path, trip, tree, and graph structures. Several well- known approaches for mining association rules [12-14] have been modified and applied in exploring sequential patterns for recent years. Furthermore, web mining is a primary application for sequential pattern mining[15-16]. Web mining extracts frequent patterns in analyzing users surfing behaviors.

Additionally, a substantial amount of research has investigated approaches[17-18] that can identify frequently occurring sequential patterns in extremely complex structures, such as tree and graph. The researches are developed for mining tree structures, whereas other researches focused on exploiting graph patterns.

A tree structure, which is a special hierarchical structure, can be widely applied to mine in many domains, such as customer relationship management, purchasing behavior analysis, and knowledge discovery[19-20]. Frequently occurring sequential patterns, identified in a large database, comprise lists of subsequences. This paper addresses a novel structure, called a tree-like structure, extracted from transaction records. A tree-like form is conceptualized from a sequence of items, which reveals the relationships among items in transaction database.

This paper is organized as follows. Section 2 introduces the basic concepts of sequence pattern, sequence close level  ( )T kCL and analyzes relationships between items in a sequence. Section 3 proposes a novel algorithm for extracting the maximal k-tree pattern. Section 4 illustrates an example of extracting e-shoppers? purchase rules by mining sequential patterns. Section 5 makes a conclusions about mining sequential patterns.



II. RELATIONSHIPS BETWEEN ITEMS IN A SEQUENCE  Let I be a set of m distinct items comprising an alphabet.

An item stands for goods. Each sequence has k  items, which belongs to I . Sequence is a set of items or itemset. A sequence database is defined as:     Ds = { }NlnjIiiiiSS jnll ?????= 1,1,,,| 21 ??     (2.1) Where N is the size of database, also known as the number of sequences in Ds denoted by NDs = .For example, itemset { }gfedcbaI ,,,,,,= , { }acbdbas ,,,,,1 = and =S 2 { }cbabcba ,,,,,,  are the sequences in Ds with size 5=Ds  as depicted in Table 1.

TABLEI.     SEQUENCE DATABASE  Sequence ID Items(sequences)  S1 S2 S3 S4  { }efeadba ,,,,,, { }hgbfdcdaba ,,,,,,,,,  { }bdca ,,, { }gbfcdab ,,,,,,   Items purchased by e-shoppers indicate a sequential  pattern. Therefore, sequential pattern mining is widely used in analyzing e-shopper?s behavior by mining sequential datasets.

According to e-shopper?s purchased items, a record for transaction data usually is depicted as tree-like sequence pattern. Tree-like pattern is a subsequence ( )ttt k21, with k nodes, where t1  is a root of k -tree sequence pattern, and node ti  has a parent and children. Fig.1 shows Tree-like pattern.

Usually, there exist various tree-like patterns in a transaction record. Two principal relationships exist between these sequence patterns: parent?child and siblings. For example, 3-tree sequential pattern explored is in S1 , and 5-tree pattern explored is in S 2 . Subsequence ( )dba ,,  can be extracted to represent 3-tree as shown in Fig.1 A, and ( )fcdba ,,,,  can be extracted to represent 5-tree as shown in Fig.1 B.

Relationship between items in 3-trees pattern, T3, is  parent?child. The root of 3-trees, a  is a parent of b , and b  is a parent of d . There exist relationships of both parent?child and siblings in 5-trees pattern, T5. The root of 5-tree, a  is the common parent of b and d , and d  is the common parent of c and f . c and f are siblings. Exchange of c and f has no any impact on 5-trees pattern. 3-trees pattern of parent?child indicates that frequency of all the items in the sequence occurring is same. However, 5-trees pattern existing sibling  relationship indicates difference in occurring frequency for the items.

In addition, most of the counting support approaches count only the frequency of occurring patterns and do not address the distance between a pair of items of k -trees pattern in a transaction sequence. The length between two items in a sequence is called distance. Distance of the same pair of items in different sequences varies. For example, 3-trees { }dba ,,  as sequence pattern, a  and b are neighbors in S1 , however a and b  are far from each other in S3 . The distance between two items in a sequence assists in determining the closeness of their relationships. If two items are far from each other, their relationship is loose. On the contrary, their relationship is close if two items are neighbors. Therefore, it is necessary for sequence pattern mining to calculate the distance between two items in a sequence in addition to counting the frequency of occurring pattern.

Before describing the significance of distance between items, distance is first defined. If two items are neighbors, the distance between them is set to 1.To estimate the significance of the distance for sequence, sequence close level is defined as follows:  ( ) 1   ? ?? ?  ? ?? ?  ?  = ?  ?  =  kCL  k  i ik dT                                                 (2.2)  Here k is the length of k -tree patternT k ; d i  is the distance between two items, and ( ) ( )ttd iii pp ?= +1  where ( )tip  is the position of ith item ti  in sequence. The value of ( )T kCL  is between 0 and 1. When ( )T kCL  is equal to 1, all items in a sequence to the k-trees are close to each other and the sequence is very important. If the value is close to 0, the sequence has lower significance. When ( )T kCL  is equal to 0, the sequence does not contain the k -tree patternT k .

For example, subsequence { }dba ,,  as 3-trees pattern, the ( )TCL 31  of { }hgbfdcdabaS ,,,,,,,,,2 = is calculated by formula (1) as follows: The distances from a  to b and b to d are =d1 1, and =d 2 2, respectively.

( ) ( ) 75.0132   1 ???  ? ? ?  ? ? ? +  =TCL  If subsequence { }fda ,, , as 3-trees pattern instead of { }hcb ,, , the ( )TCL 3  of { }hgbfdcdabaS ,,,,,,,,,2 =  is calculated by formula (1) once more. The result is as follows:  ( ) ( ) 27.0135   2 ??  ? ? ?  ? ? ? +  = ?TCL  ( )TCL 31 ? ( )TCL 32 , this result indicates relationships between items in S 2 toT 31 ( dba ,, ) is closer than ones between items in S 2 toT 32 ( fda ,, ). Although subsequence { }fda ,,  and { }hcb ,, all are 3-trees pattern to S 2 , subsequence { }fda ,,  as  a  b  d  a  b d  c f  Figure1. Sequential pattern  A B     3-trees pattern to S 2 is more important than { }hcb ,, . The bigger value of ( )T kCL  is, the more desirably e-shoppers purchase the items in subsequenceT k .



III. MINING TREE-LIKE SEQUENCE  PATTERNS Analyzing on relationships between items in a sequence  indicates that it is necessary to calculate ( )T kCL  for mining e- shopper?s sequence patterns. Therefore, studying e-shopper?s purchase pattern should consider both support of k -trees pattern and close level between items in a sequence. This section presents the following algorithms.

Algorithm 1 is used to calculate close level between items in a sequence. The basic process is as follows: Algorithm 1: Calculating-CL(T k ).

Input: A sequence S ? Ds stored in one-dimension array  [ ]nS 2,1 and k -trees pattern ( ttt k21, ) Output: Value of ( )T kCL Initialization: ?        Q // Set queue to empty;  01 =d ; 1. for ( 1=i ; 1?? ki ; 1+= ii ) do { 2. enqueue ti  to Q // 1,2,1 ?= ki ; 3. for S[i] i = n2,1 in sequence 4. if S[i] = ti ; 5.   Then Dequeue ti from Q 6. else; 7.   1+= dd ii } 8. Calculating ( )T kCL ; 9. end for  Algorithm 2 is used to generate candidate sequences Ck .

The process is as follows: Algorithm 2: Candi-gen(Lk-1)  if (k=2)  then  insert into Ck; select  p.iteml; q.item1 from L1  else insert into Ck select  p.iteml; p.item2;?; p.itemk-1; q.itemk-1  Where p.item1=q.item1, ?, p.itemk-2=q.itemk-2, p.itemk-1 < q.itemk-1.

Here a dynamic algorithm is proposed, which simplifies the process generating candidate sequences. The proposed algorithm includes four parts: initialization, front-search, middle-count and back-search. In initialization, the algorithm generates k -trees frequent subsequences Fk . Front-search is used to generate +k step frequent subsequences F stepk+ . In middle-count, the algorithm generates the candidate sequences which are ignored by the front-search. Finally, back-search deletes not maximal k-tree sequences, and generates maximal sequence pattern.

Ck : Candidate k -trees sequences Ct : Candidate k -trees sequences included in e-shopper?s  transaction sequences  Lk : frequent k -trees sequences sup.S : support value of a k -trees sequence  Input: a transaction databases Output: maximal sequence patterns  Initialization: L1 = {frequent items}; for (k=2; ??Lk 1 ? and k?step; k=k+1) do Ck = Candi-gen(Lk-1); for all customer sequence c?Ds  do Ct = subset(Ck , c); for all s?Ct  do sup.S = sup.S +1; end for end for  Lk = { s?Ck | sup.S ? minsup}; end for  Front-search: for (k=step; ?Lk ? ; k=k+step) do  =+C stepk ?; for all customer sequence c?Ds  do  Q = S-generating( Lk , Lstep , c); for all q?Q do  if q? C stepk+  then add q toC stepk+ ; else q.sup = q.sup+1; end if  end for =+L stepk { s?C stepk+ | sup.S ? minsup}  end for Middle-count:  for (k-1; k ? 1; k=k-1) do if =Lk ? then  if ??Lk 1 ? then Ck = Candi-gen(Lk-1); else Ck = Candi-gen(Ck 1? );  end if end if  end for Back-search:  for (k-1; k ? 1; k=k-1) do if =Lk ? then  delete all sequence in Ck contained in Li (i?k) for all customer sequence c?Ds do Ct = subset(Ck , c);  for all s?Ct  do sup.S = sup.S +1; end for  end for Lk = { s?Ck | sup.S ? minsup};  else delete all sequence in Lk contained in Li (i?k) end if  end for

IV. ILLUSTRATIVE EXAMPLE It is clear that e-shoppers ?purchase rules can be  discovered by mining e-shoppers? sequential pattern. A given transaction database is given in table 2. The given database includes nine transaction records. The letters such as ,,ba  and f  etc denotes products purchased by e-shoppers.

TABLEII.     TRANSACTION DATABASE  Sequence ID Sequences  S1 S2  S3  S4 S5 S6 S7  S8 S9  { }ea,? { }b { }c { }d { }a { }f { }c { }d { }ec,?  { }a { }b { }c { }d { }g { }f { }a { }a { }c { }e  { }a { }f { }ah,? { }b { }d { }e  { }d { }e { }ea,? { }k { }c { }e   The support is set to 2, and the step of searching candidate  sequences is set to 2 too. According to the mentioned algorithms above, the process for extracting maximal sequential patterns on table 2 is as follows:  In initialization phase, the algorithm generates large 1- sequences and 2-sequences respectively. Firstly, the algorithm counts the support for every 1-sequence. The following 1- sequences satisfy the supporting qualification, and make up of large 1-sequences: { }?a , { }?b  { }?c , { }?d , { }?e , { }?f . Basing on the large 1-sequences, secondly, the algorithm (Candi-gen(Lk-1)) generates candidate 2-sequences and counts the support of 2- sequences. The following 2-sequences satisfy the supporting qualification, and make up of large 2- sequences: { }?ba, , { }?ca, , { }?da, , { }?ea, , { }fa, , { }?cb, , { }?db, , { }?eb, , { }?dc, , { }?ec, , { }?ed , .

In front-search phase, the algorithm only generates only 4- sequences because 6-sequences are void. Only 4- sequen { }?dcba ,,,  satisfies the supporting qualification.

Therefore candidate 4-sequence { }?dcba ,,,  is large 4-sequence.

In middle-count phase, the algorithm (Candi-gen(Lk-1)) generates candidate 3-sequences basing on large 2-sequences, and generates candidate 5-sequences basing on large 4- sequences. But there is only a sequence in large 4-sequences, and candidate 5-sequences are void. So candidate 3-sequences are only generated in middle-count phase. The following sequences are candidate 3-sequences: { }?cba ,, , { }dba ,, , { }?eba ,, , { }?fba ,, , { }?dca ,, , { }?eca ,, , { }fca ,, , { }eda ,, , { }fda ,, , { }?dcb ,, , { }?ecb ,, , { }?fcb ,, , { }?edc ,, , { }?fdc ,, .

In back-search phase, the algorithm counts the support of every candidate 3-sequence and generates large 3-sequences, and then deletes subsequences. The following sequences are large 3-sequences: { }?cba ,, , { }?dba ,, , { }?eba ,, , { }?dca ,, , { }?eca ,, , { }?eda ,, , { }?dcb ,,  , { }edc ,, .

Finally, the algorithm generates the following maximal sequential patterns: { }dcba ,,, , { }?eca ,, , { }?ed , .

The maximal sequential patterns reveal e-shoppers? purchase rules.

To understand the importance of the maximal sequential patterns to transaction records, calculation of ( )T kCL  is made.

Subsequence { }dcba ,,, , as maximal sequential pattern, is 4- trees pattern. According to formula (1), the ( )TCL 4 of the 4- trees pattern for transaction records is calculated. Table 2 includes nine transaction records. Sequences such as S1 , S2 , S3 and S7 are considered to count ( )TCL 4 . The other sequences are ignored. The results of ( )TCL 4  is as shown in table 3. Subsequence { }eca ,, and { }?ed , , as maximal sequential pattern, are 3-trees and 2-trees pattern respectively. Their results of ( )TCL  is as shown in table 4 and table 5, respectively.

TABLEIII.    ( )TCL 4  FOR { }?dcba ,,, ( )TCL 41  Sequence ID Sequences  0.33     0.33    S1 S2 S3  S4  S5  S6  S7  S8  S9  { }ea,? { }b { }c { }d { }a { }f { }c { }d { }ec,?  { }a { }b { }c { }d { }g { }f { }a { }a { }c { }e  { }a { }f { }ah,? { }b { }d { }e  { }d { }e { }ea,? { }k { }c { }e  In table 3, S1  and S3 include 4-trees sequential pattern { }dcba ,,, , and their ( )TCL 4  are equal to 1. The other sequences don?t contain 4-trees sequential pattern, and so their ( )TCL 4  are very small.

TABLEIV. ( )TCL 3  FOR { }?eca ,, ( )TCL 31  Sequence ID Sequences  0.5 0.5  0.25      0.75  S1 S2 S3  S4  S5  S6  S7  S8  S9  { }ea,? { }b { }c { }d { }a { }f { }c { }d { }ec,?  { }a { }b { }c { }d { }g { }f { }a { }a { }c { }e  { }a { }f { }ah,? { }b { }d { }e  { }d { }e { }ea,? { }k { }c { }e     In table 4, sequences S1 , S2 , S5 and S9 all include 3-trees sequential pattern{ }?eca ,, . However, only ( )TCL 3  of S5 is equal to 1, and the other sequential ( )TCL 3  are less than 1.

TABLEV. ( )TCL 21  FOR { }?ed , ( )TCL 21  Sequence ID Sequences  0.33        S1 S2 S3  S4  S5  S6  S7  S8  S9  { }ea,? { }b { }c { }d { }a { }f { }c { }d { }ec,?  { }a { }b { }c { }d { }g { }f { }a { }a { }c { }e  { }a { }f { }ah,? { }b { }d { }e  { }d { }e { }ea,? { }k { }c { }e  In table 5, sequences S2 , S7 and S8 all include 2-trees sequential pattern { }?ed , , and their ( )TCL 2 are equal to 1.

The results of ( )TCL k  indicate that for sequences including k- trees sequential pattern, the bigger value of ( )T kCL  is, the closer all items in the sequence are each other, and the more desirably e-shoppers purchase the items according to k-trees sequential pattern.



V. CONCLUSIONS In this study, this paper proposed a novel data mining  scheme for mining k-trees. The novel algorithm includes four subprogram: initialization, front-search, middle-count and back-search to count the support and extract large sequences.

And Algorithm 1 is proposed to calculate ( )T kCL when matching one k-tree in a sequence. The degree of importance for k -tree sequential pattern in a sequence can be determined calculating close level between items. The value of ( )T kCL ranges from 0 to 1. The Values close to 1 indicates a high degree of significance of sequences for the k-trees. If the value is is equal to 0, the sequence does not contain the k -tree patternT k .

