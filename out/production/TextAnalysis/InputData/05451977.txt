

Abstract?Notwithstanding the fact that data mining and particularly sequence mining have come to the help of database proprietors and experts in variety of fields by extracting the hidden knowledge in their raw data, they have provided an opportunity for adversaries to take advantage from this sensitive knowledge. So this work addresses the problem of sequential pattern hiding, and proposes an efficient and applicable algorithm which benefits from a multi-objective scheme to fulfill the requirements of the problem as well as maintaining database fidelity as much as possible.

Keywords-privacy preserving data mining; sequential pattern hiding; knowledge hiding

I.  INTRODUCTION Recent advancements in the data mining field have made  opportunities to get access to the knowledge concealed in vast amount of data. Nonetheless, the divulged knowledge could also be considered adversely, inasmuch as every unauthorized person could elicit and use it to take advantage over database owners. To give a clear-cut example, consider a market which gathers its costumers' transactions, and by analyzing them extracts their purchase patterns, so by utilizing it could design promotions for other products. But it will lose its business situation over their competitors, if they get access to this sensitive knowledge, owing to the fact that this provides an opportunity for others to steal this market's business advantage. Clearly, an organization could neither keep its data hidden nor publish it thoroughly; a compromise should be made. Withholding others to take advantage of our data, and preserving our knowledge privacy are the main objectives of the knowledge hiding process and received conspicuous attention in recent years.

There are varieties of methods to achieve this, and majority of them try to alter the database, which to be published. The altered database is also called the sanitized  database. But majority of sanitization methods and algorithms have dealt with classic and simple forms of databases and knowledge so far, namely frequent itemsets and association rules. In [1, 2] disjoint sensitive association rules were hidden one at a time by reducing their support or confidence. The works in [3, 4, 5] introduced unknown values, and again aimed to reduce association rules' support or confidence. Authors of [6] defined a sanitization matrix, and used it to hide frequent patterns. The work by Oliveira et al. [7] concerned with sharing the association rules and hiding the sensitive ones rather than the data. An algorithm was introduced by Aggarwal et al. [8] for the problem of protecting sensitive entries in a database. Authors of [9, 10] presented a border-based approach to hide frequent itemsets.

A new form of practical knowledge, co-ocurring itemsets, and approaches for hiding it were proposed by Abul and et al.

[11].

But a relatively new and more structured form of data has been presented recently which is sequence mining [12].

Incontrovertibly, knowledge preserving should be applied to this category of data, too, due to its more capability to cope with real world problems. Little research has been done in this field. Abul et al. [13] addressed this problem in their work. So the aim of this paper is to propose a novel algorithm to surmount the problem of sequential pattern hiding in sequence databases in more expeditious ways than [13].

This paper is organized as follows. In section II we present some background information and the notation used in the rest of the paper. In section III we introduce our approach to attack the sequential pattern hiding problem, an algorithm is presented, and enforcement of constraints is included, too. Section IV contains wide range of experiments and comparisons. Finally, we conclude the discussion in section V.

Volume 1  C 978-1-4244-5586-7/10/$26.00      2010 IEEE

II. PROBLEM STATEMENT In this section, first some basic definitions of sequence  data mining, which are based on [14], are stated, and then a depth discussion about the problem of sequential pattern hiding will be followed.

A sequence is an ordered list S = s1s2...sl, where each si(1 ? i ? l) is an itemset, and is called an element which is denoted as (x1x2...xm) such that each xk(1 ? k ? m)? ?, and ? is a finite set of distinct items. A sequence a = a1a2...an is called a subsequence of another sequence b = b1b2...bm and b a super-sequence of a, if there exists integers 1 ? j1 < j2 <...< jn ? m such that a1 ? bj1, a2 ? bj2, ?, an ? bjn. In addition, a sequence database SDB contains a set of sequences. The support of a sequence a in a SDB is the number of sequences in SDB that are super-sequences of a: supSDB(?) = |{S ? SDB?? subsequence of S}|. A sequence a is called a sequential pattern in SDB if supSDB(?) ? min-sup.

Given a sequence S=s1?sn and a subsequence S'=s'1?s'm, a set of positions {i1, i2, ?, im} is called an occurrence of S' in S if 1 ? i1 <...< im ? n and s'k = sik  for each 1 ? k ? m.

Consider S = bab(cd)(abd)bb(cbd) and S' = (cd)bb.

Occurrences of S' in S are {4, 5, 6}, {4, 5, 7}, {4, 5, 8}, {4, 6, 7}, {4, 6, 8}, and {4, 7, 8}, which occurrences' indices correspond to element numbers.

Given a sequence database and a minimum support threshold, the sequential pattern mining problem is to find the complete set of sequential patterns in the database.

Definition (related occurrence set of an item in a sequence): given a sequence S, a sequential pattern SP, and an item x which is the ith item from SP, the related occurrence set of x from SP in S encircles item numbers in S which correspond to item x from SP and is denoted as rossp?s(x:i).

For example, if S = bab(cd)(abd)bb(cbd), and SP = (cd)bb, the related occurrence set of 3th item from SP, i.e. b, in S is ros(cd)bb?s(b:3) = {7, 9, 10}.

Definition (Sensitive Patterns): Sensitive patterns are sequential patterns which are determined sensitive by field experts, and must be hidden. In addition, we refer to items in sensitive patterns as sensitive items.

Problem definition: Given a sequence database SDB, a sensitive pattern set SPS, and a hiding threshold ?, the goal is to minimally alter the SDB to hide all of sensitive patterns in it by reducing their support to ?.

There are four important issues in the definition. First, the database's sequences should be altered. This will be done by replacing some of their element's items by unknown value "?". We refer to the number of item changes as distortions.

Second, the term "minimally" imposes that distortions should be as few as possible, due to the fact that distortions decline data's quality. Then, the support of sensitive patterns must reduce to exactly ?, because excessive support declining diminishes database's quality, but in [13], the authors require that sensitive patterns' support must not be more than ?, so they permit excessive support declining in their algorithm.

Next, in our work we cope with complex sequential patterns rather than the simple form. Simple sequences, which are the  subject of [13], contain a single item as their elements instead of itemsets.



III. THE PROPOSED APPROACH The proposed approach and its comparison with [13], the  presentation of the hiding algorithm, and handling constraints are discussed in this section.

A. Overview of the Proposed Hiding Approach The definition of the problem is very generic that needs  further clarification in every aspect of it.  Firstly, we need to explain how a sequential pattern vanishes from a sequence: to do this all the occurrences of the sequential pattern must be cleared from the sequence, such that the sequential pattern no longer is supported by the sequence. Again, consider the sequence S = bab(cd)(abd)bb(cbd) and the sequential pattern SP = (cd)bb. To hide SP it is adequate to select one of its items, for instance, item c from first element of SP, i.e. the item number 1, and to replace all items in S with "?" which are included in ros(cd)bb?s(c:1) = {4}.  So the sanitized sequence with one distortion S = bab(?d)(abd)bb(cbd). Note that the other item c in the S, the 11th item, remains intact.

Other alterations are plausible. For example, the sanitized sequence bab(cd)(abd)??(c?d) is acquired by choosing item number 3 from SP and by replacing "?" with its related occurrences. Distinctly, this would not be a good solution owing to its imposed distortions. Now, consider a case which a sequence S = bab(cd)(abd)bb(cbd) comprises more than one sensitive pattern: ac(ad) and (cd)bb. The sanitized S = bab(?d)(abd)bb(cbd) is gained by solely one distortion, because rosac(ad)?s(c:2) = ros(cd)bb?s(c:1) = {4}. As a result, the sequence should be sanitized with fewer distortions as possible. It is worth mentioning that optimal sanitization, which is hiding all occurrences of sensitive patterns in a sequence is NP-Hard [13].

To clarify the sanitization process take into account our sample database in table I, the hiding threshold ? = 1,  and a sensitive pattern set SPS = {ac(ad), (cd)bb, ebe}, which sup(ac(ad)) = 2, sup((cd)bb) = 3, and sup(ebe) = 2. So the patterns in SPS should be hidden by reducing their supports to ?.

We introduce a multi-objective sequence selection framework to surmount the sensitive patterns hiding problem which first analyzes each sequence of the database and finds the best candidate solution to sanitize it, and then by comparing all best candidates in the database, it selects the winner sequence, i.e. the best overall candidate, and applies it to the corresponding sequence, so the support of some sensitive patterns will reduce by one unit. This process will iterate until all sensitive patterns' supports ascend to the exact value of ?.

TABLE I.  SAMPLE DATABASE  Sequence ID (s-id) Sequence 1 bab(cd)(abd)bb(bcd) 2 (cd)ac(ad)cbeb(ad)e 3 (cd)b(cd)bebe    Volume 1       The candidate solution selection process should consider the following factors:  1. Number of sensitive patterns (SP) which their supports will be reduced one unit by the solution.

2. Number of distortions (D) of the candidate solution.

3. Number of non-sensitive patterns which their  supports will reduce by one unit by the solution (NSP).

Factor SP holds positive effect and should be maximized, while the effects of D and NSP is negative and need to be minimized. Thus, the problem of hiding all sequences s?SPS in sequential data base SDB is defined as to find s' as a subsequence of s to be hidden and changing SDB into SDB' so that:   Max SP(s'), Min D(s'), Min NSP(s') (1) s.t. s' subsequence of s, for all s ? SPS supSDB'(s) = ? , for all s ? SPS   To solve the above multi-objective optimization problem,  a weighted summation of the above objectives is introduced:   F(SP(s'), D(s'), NSP(s')) = ? ? SP(s') ? (? ? D(s') + ? ? NSP(s')) (2) ?, ?, and ? ? [0,1]   The sequence analysis process, which results in the best solution, is conducted by constructing a candidate tree. The candidate tree is composed of all possible solutions to sanitize a sequence in such a way that each of its nodes is a solution, so each of them encircles the following information: 1) the sensitive items involved, and 2) the associated objective functions or a 3-tuple, i.e. (SP, D, NSP). Fig. 1 depicts the candidate tree for the sequence with s-id = 3 in table I. This sequence comprises two sensitive patterns: (cd)bb and ebe. For the sake of simplicity the effect of NSP is ignored: ? = 0. The number of items in a sensitive pattern is included in the repeated items to help distinguish them from each other.

An important point about the candidate tree is that first it examines solutions which are composed of a single sensitive item. These solutions could be seen in the first level of the candidate tree in Fig. 1, and then pairs of solutions with a sensitive item are amalgamated, and the result will be the solutions with couple of sensitive items, but as it is clear in the candidate tree of Fig. 1, none of the sensitive items from a same sensitive pattern are coalesced; there is no need to hide a sensitive patterns by hiding more than one of its items in the sequence. As a result, to avoid this, some amalgamation criteria are considered: solutions which construct the ith level of the candidate tree must incorporate the combination of i items from i distinct sensitive patterns, so:  ? To yield solutions with two sensitive items all the solutions which contain one item and are compatible with the above criteria will participate.

? Solutions with three or more sensitive items are produced in a similar fashion.

So if a candidate tree is merely constructed on a single sensitive pattern, no combination will be necessary.

Therefore, by using this bunch of rules when constructing a candidate tree a huge number of unnecessary and useless solutions will be pruned beforehand.

So far the sequence with s-id = 3 is analyzed by constructing its candidate tree. Now, based on the objective function F, the best solution will be determined. In aggregation, there are four combinations of (SP, D) in the candidate tree in Fig. 1: (1, 2), (2, 3), (1, 1), and (2, 2), and assume ? = 0.5, 	 = 1, and F(1,2) = ?1.5, F(2,3) = ?2, F(1,1) = ?0.5 and F(2,2) = ?1, so the third solution will be the winner. To exhibit the significance of the weighted F to decide the winner, consider another example with ? = 1, 	 = 0.5. The winner solution in this case is the fourth solution with F(2,2) = 1. The winner solutions in both cases are circumscribed in Fig. 1. Moreover, it worth mentioning that if two or more solutions with the same value for the F function have the highest value among other solutions, the winner is selected based on a preconceived preference. For instance, one may prefer fewer distortions.

In Fig. 1 distortions number for solutions is calculated based on the related occurrence sets. For instance, for the node b:4,b(2,2), which is equivalent to one of the winners, roscd(bb)?s-id:3(b:4) ? rosebe?s-id:3(b:2) = {6,8} ? {8} = {6,8}, which means two distortions are required.

Candidate trees of other two sequences in the sample database in table I will be constructed, and the overall winner will be pointed out and applied to the corresponding sequence. Assuming ? = 0.5, 	 = 1, table II shows overall winners and their results on the database and supports of sensitive patterns. As a result, by only two distortions the sample database is sanitized, and, furthermore, this approach does not obtrude any extra distortions by reducing the support of some sensitive patterns below the ?.

In the proposed approach in [13], the authors first sort the database's sequences in ascending order according to the number of sensitive pattern occurrences in them, second select the first |SDB| ? ? sequences, where |SDB| is the size of the database, then sanitize them by hiding all the occurrences of sensitive patterns in them. So this method necessitates that when a sequence is selected for sanitization, all the sensitive patterns must be deleted from it, while it is not necessary; we should consider the entire database for sanitization not just a single sequence at a time; in addition, by sanitizing all the sensitive patterns from the selected sequence, we might lose the opportunity to sanitize the database with fewer distortions. In the table II in the second iteration the sequence with s-id = 2 is selected as the overall winner, but after altering it, it still contains the sensitive pattern ac(ad). Moreover, by selecting top |SDB| ? ? sorted sequences, some sensitive patterns' supports might descend below the ? which will cause unnecessary distortions. For instance, the sequences in table I contain 7, 5, and 4 occurrences of sensitive patterns respectively, so according to the method of [13] the sequences with s-id = 3 and s-id = 2 will be sanitized in order with 2 and 3 distortions respectively. So with 5 distortions the database is sanitized.

Furthermore, after the sanitization sup(ebe) = 0, but our approach imposes neither excessive distortions, nor excessive support declination.

Volume 1       cd(bb)                                                                                                              ebe c(1,2)                      d(1,2)                             b:3(1,2)                         b:4(2,2)                      e:1(1,1)                   b(1,1)                  e:3(1,1)       c,e:1(2,3)     c,b(2,3)     c,e:3(2,3)     d,e:1(2,3)     d,b(2,3)     d,e:3(2,3)     b:3,e:1(2,3)     b:3,b(2,3)     b:3,e:3(2,3)     b:4,e:1(2,3)     b:4,b(2,2)     b:4,e:3(2,3)   Figure 1.  Candidate tree for the sequence with s-id = 3 in table I  TABLE II.  SANITIZATION PROCESS FOR SAMPLE DATABASE IN TABLE I  Iteration Data base Winner (s-id)  Replace location Supports ac(ad) (cd)bb ebe  bab(?d)(abd)bb(cbd) (cd)ac(ad)cbeb(ad)e (cd)b(cd)bebe  1 4 1 2 2  bab(?d)(abd)bb(cbd) (cd)ac(ad)cbe?(ad)e (cd)b(cd)bebe  2 10 1 1 1  B. The Proposed Algorithm The novel hiding algorithm MOSS (Multi-objective  Sequence Selection) is presented in Fig. 2, and summarizes our hiding framework. In this algorithm DBSeqsToCheck, which at first holds the s-id of all sequences, is used to determine which SDB sequences should be checked in the next iteration. The algorithm iterates until all sensitive patterns become hidden. In the first step it finds the best candidate solution for each sequence, and then finds the best solution for the entire SDB. This solution is applied to the corresponding sequence, and as a result of that supports of sensitive patterns in that sequence will be reduced by one unit. In this point those sensitive patterns which are successfully hidden are deleted from the SPS.

One of the features of our algorithm is that after the first iteration, which in it all sequences in SDB are checked, it solely rechecks the updated sequence as well as those sequences which contain the hidden sensitive patterns, given the fact that their candidate tree will not include the hidden sensitive patterns anymore. Other sequences' candidate trees will remain intact. Therefore, a small number of sequences are checked in each iteration.

Algorithm: MOSS INPUTS: SDB, SPS, ?, ?, 	, ? - OUTPUT: sanitized SDB (SDB') DBSeqsToCheck all s-ids While |SPS| > 0  1. For each s-id in DBSeqsToCheck 1.1. Generate solutions which consider one  sensitive item for deletion 1.2. Combine solutions to generate solution tree 1.3. Compute rank of each solution 1.4. bestSolutions highest ranked solution in  the solution tree 2. Find best overall solution 3. Apply best overall solution and update SDB 4. Decrease support of affected sensitive patterns 5. For each sp in SPS  5.1. If sup(sp) = ? then remove sp from SPS 6. Empty DBSeqsToCheck 7. DBSeqsToCheck updated sequence's s-id 8. DBSeqsToCheck s-id of sequences which  contain removed sensitive patterns 9. For each s-id in DBSeqsToCheck  9.1.    Delete the corresponding bestSolution  Figure 2.  MOSS algorithm  C. Handling Constraints The two types of constraints namely max/min gap and  max/min distance could conveniently be enforced to the hiding algorithm; no change is required in the algorithm in Fig. 2, and a solitary part that needs reconsideration is the definition of the related occurrence set. If a sequence S contains a subsequence SP, then a max/min gap constraint demands that the number of elements in S which are between every two elements of SP be less than (max + 1) and more than (min ? 1). In this case the related occurrence set is denoted as gaprosSP?S(x:i, min, max). Moreover, a max/min distance constraint obliges that the number of elements in S which are between the first and the last elements of SP be in the interval [min, max]. In this case the related occurrence set is denoted as disrosSP?S(x:i, min, max). The following corollaries are obvious about the related occurrence sets:   gaprosSP?S(x:i, min, max) ? rosSP?S(x:i) (3) disrosSP?S(x:i, min, max) ? rosSP?S(x:i) (4)   So to generate the newly introduced related occurrence sets, the rosSP?S(x:i) is computed at first, and then those item numbers which cannot satisfy the constraints will be excluded from it. For the sequence with s-id = 1 in table I, gaprosac(ad)?s-id=1(a:3, 1, 2) = {10} ? rosac(ad)?s-id=1(a:3) = {5, 10}. In another example, disrosac(ad)?s-id=1(a:3, 0, 1) = ?. In addition, these constraints could be forced into the hiding approach simultaneously.



IV. EXPERIMENTAL RESULTS We evaluate our algorithm with three datasets. The  first dataset is a randomly generated dataset over the alphabet {a, b, c, d} which contains 10000 complex sequences (sequences which are compatible with the definition of a sequence in section 2). The second dataset is the Molecular Biology dataset [15] with 106 DNA  Volume 1       sequences of length 57. The MSNBC.com Anonymous Web dataset [16] is our third dataset which incorporates 989818 sequences over integers from 1 to 17 as its items.

Each sequence is page views of a user during a 24-hour period, and the first 5000 sequences have been considered in the experiments. We denote these datasets as Random, DNA, and WEB respectively.

We compared our algorithm with the other sequence hiding approach [13] which we refer to it as OSH. Number of distortions is one of our measurements, and the other one is infidelity measure which encompasses those non- sensitive patterns which their support fall below the support threshold after sanitization.

Randomly selected sensitive patterns and other information regarding the datasets are shown in table III.

Throughout the tests we use a certain notation to refer to the algorithm and other information which is <algorithm- name, (?,?,?), constraint>. The second and third elements are optional. Because the algorithm in [13] cannot deal with complex sequences, we adopt it to accept them.

In the figures the x-axis is always the hiding threshold, i.e. ?, and the y-axis is either the distortion or infidelity.

Fig. 3.a, 3.b, and 3.c depict the number of distortions in Random, DNA, and WEB datasets respectively. The gradual entry in <MOSS-(1,gradual,0)> in Fig. 3.a indicates that ? gradually increases from 0.1 to 1 as ? ascends. To further discuss the impact of objective function the MOSS results are presented with different settings of the 3-tuple (?,?,?). As it is clear in Fig. 3.a, 3.b, and 3.c the MOSS with/without constraint surpasses the OSH with/without constraint.

Fig. 4.a, 4.b, and 4.c show the infidelity measure in datasets, and prove the better results of MOSS.

Furthermore, the effect of ?, which aims to preserve non- sensitive patterns according to the objective function, is eminent in the figures, but we have to say that this often has a negative effect on distortions, which is clear in Fig.

3.a when comparing <MOSS, (1,1,1)> with <OSH>, but, on the other hand, the infidelity measure decreases dramatically when comparing the results with the effect of ? with those that ignore it.

TABLE III.  DATASETS INFORMATION  Dataset Support threshold Patterns Sensitive patterns Random 1000 837 b(ab)b, cbb, cb(ab)a DNA 106 35628 caatttgcaa, ggcggac WEB 100 109 1 6 6, 2 2 1

V. CONCLUSION In this paper we addressed the problem of hiding  sequential patterns. The main contributions of this work over the other algorithm in the literature [13] could be summarized in dealing with complex form of sequences rather than simple sequences, and presenting a more efficient algorithm which hides sensitive patterns from a sequence database with fewer distortions, so data quality is preserved. Furthermore, we presented a highly flexible weighted objective function to find best solution among all candidate solutions to sanitize sequences. Moreover,  handling constraints was another topic of discusstion.

Experimental evaluations carried out on three datasets with distinct characteristics to prove the promised functions of both the algorithm and the objective function. The results indicated that the proposed algorithm surpasses the existing one significantly.

