A Dynamic Approach for Frequent Pattern Mining Using Transposition of Database

Abstract?an Important Problem in Data Mining in Various Fields like Medicine, Telecommunications and World Wide Web is Discovering Patterns. Frequent patterns mining is the focused research topic in association rule analysis.

Apriori algorithm is a classical algorithm of association rule mining. Lots of algorithms for mining association rules and their mutations are proposed on basis of Apriori Algorithm.

Most of the previous studies adopt Apriori-like algorithms which generate-and-test candidates and improving algorithm strategy and structure but no one concentrate on the structure of database. A simple approach is if we implement in Transposed database then result is very fast.

Recently, different works proposed a new way to mine patterns in transposed databases where a database with thousands of attributes but only tens of objects. In this case, mining the transposed database runs through a smaller search space. In this paper, we systematically explore the search space of frequent patterns mining and represent database in transposed form. We develop an algorithm (termed DFPMT?A Dynamic Approach for Frequent Patterns Mining Using Transposition of Database) for mining frequent patterns which are based on Apriori algorithm and used Dynamic Approach like Longest Common Subsequence. The main distinguishing factors among the proposed schemes is the database stores in transposed form and in each iteration database is filter /reduce by generating LCS of transaction id  for each pattern. Our solutions provide faster result. A quantitative exploration of these tradeoffs is conducted through an extensive experimental study on synthetic and real-life data sets.

Keywords- Longest Common Subsequence, Transposition of Database,Frequent Pattern mining

I.  INTRODUCTION Frequent Pattern Mining is most powerful problem in  association mining. Most of the algorithms are based on algorithm is a classical algorithm of association rule mining [2, 3, 4]. Lots of algorithms for mining association rules and their mutations are proposed on basis of Apriori Algorithm [2, 3, 4, 5, 6]. Most of the previous studies adopt Apriori-like algorithms, which generate-and-test candidates and improving algorithm strategy and structure.

Several modifications on apriori algorithm are focused on algorithm Strategy but no one-algorithm emphasis on representation of database. A simple approach is if we implement in Transposed database then result is very fast.

Recently, different works proposed a new way to mine patterns in transposed databases where a database with thousands of attributes but only tens of objects [1]. In many example attribute are very large than objects or transaction In this case, mining the transposed database runs through a smaller search space. In apriori algorithm each phase is count the support of prune pattern candidate from database.  No one algorithm filters or reduces the database in each pass of apriori algorithm to count the support of prune pattern candidate from database. We propose a new dynamic algorithm for frequent pattern mining in which database represented in transposed form.

And for counting the support we find out by longest common subsequence approach and after finding pattern longest common subsequence is stored or update in database so that next time instead of whole transaction we search from these filter transaction string.



II. FREQUENT PATERN MINING   Frequent Itemset Mining came from efforts to discover useful patterns in customers? transaction databases. A customers? transaction database is a sequence of transactions (T = t1.  . . tn), where each transaction is an itemset (ti ? I). An itemset with k elements is called a k- itemset. In the rest of the paper we make the (realistic) assumption that the items are from an ordered set, and transactions are stored as sorted itemsets. The support of an itemset X in T, denoted as suppT(X), is the number of those transactions that contain X, i.e. suppT(X) = |{tj : X ? tj}|. An itemset is frequent if its support is greater than a support threshold, originally denoted by min supp. The frequent itemset mining problem is to find all frequent itemset in a given transaction database.

DOI 10.1109/ICCSN.2010.15     The first, and maybe the most important solution for finding frequent itemsets, is the APRIORI algorithm [5,7].

Later faster and more sophisticated algorithms have been Suggested, most of them being modifications of APRIORI [5, 7]. Therefore if we improve the APRIORI algorithm then we improve a whole family of algorithms. We assume that the reader is familiar with APRIORI [1, 2, 3, 4, 5, 6, 7] and we turn our attention to its central data structure.

Most of these algorithms adopt an Apriori-like method:  generates a candidate pattern by extending currently frequent pattern and then test the candidate. During this process, many infrequent patterns are generated.



III. TRANSPOSITION OF DATABASE   To avoid confusion between rows (or columns) of the original database and rows (columns) of the ?transposed? database, we define a database as a relation between original and transposed representations of a database in Table-1. The attributes are A = {a1, a2, a3, a4} and the objects are O = {o1, o2, o3}. We use a string notation for object sets or itemsets, e.g., a1a3a4 denotes the itemset {a1, a3, a4} and o2o3 denotes the object set {o2, o3}. This dataset is used in all the examples between two sets: a set of attributes and a set of objects.



IV. DYNAMIC APPROACH   The longest common subsequence problem is one of the common problems which can be solved efficiently using dynamic programming. ?The Longest common subsequence problem is, we are given two sequences X=<x1,x2----------xn> and Y=<y1,y2---------ym> and wish to find a maximum length common subsequence of X and Y? for example : if X=<A,B,C,B,D,A,B> and Y=<B,D,C,A,B,A> then The sequence <B, C, B, A> longest common subsequence. Let us define C [i, j] to be the length of an LCS of the sequences xi and yj. If either i=0 or j=0, one of the sequence has length 0, so the LCS has length 0. The Optimal substructure of the LCS Problem gives the recursive formula in fig.1    TABLE I.  TRANSPOSITION OF DATABASE  DATABASE D   TRANSPOSED DATABASE DT       ( ) ( ) ( )( )  0 0 0 ( , ) 1, 1 1 , 0  max , 1 , 1, , 0  if i or j C i j C i j if i j and xi yj  c i j c i j if i j and xi yj  ? ?= = ? ?? ?= ? ? + > =? ? ? ?? ? > ? ?? ??   Figure 1.  Longest Common Subsequence Recursive Formula

V. ALGORITHM   The mining algorithm works over the entire database file, first transpose the database and count the number of item and transaction string generated for each item. Sort the item numbers. Now apply Apriori like Algorithm in which first we calculate frequent pattern C1.it reduces un-frequent pattern and its transaction details also. For each pass we apply following sequence of operation until condition occurred. First generate the candidate pattern and prune by Apriori method. To count the support , instead of whole database for each pruned pattern we find longest common subsequence and length of  transaction string of pattern?s item and also stored new pattern and its transaction string so that next iteration we trace above string. To find longest common subsequence we used dynamic programming approach which faster then traditional approach. Write pruned pattern list with transaction string. So that in next pass we used this pattern list instead of all pattern list. An advantage of this approach is in each iteration database filtering and reduces, so each iteration is faster then previous iteration   A. Algorithm DAPS (Algorithm for Pruning with Support)

I. Compute k-1 Subset of k-itemset

II. Generate Itemset Transition string from Filter Transposed Database

III. Computer LCS for each item in itemset using Transition string.

IV. If length of LCS >? then itemset is frequent.

B. Algorithm DFPMT ( Dynamic Approach for Frequent Patterns Mining Using Transposition of Database)

I. Convert Database in Transpose Form DT

II. Compute F1 of all Frequent Items

III. C1:= DT (Only Frequent Item row with Transition  id string ) IV. K: =2.



V. While Lk-1? { } do

VI. Compute Ck of all candidate k-1 Itemsets /* New Algorithm which prune and count support using LCS */

VII. Compute Lk=DAPS (Ck)

VIII. K:=K+1    Object Attribute Pattern  Attribute Object Pattern  O1 a1a2a3  a1 O1O2 O2 a1a2a3  a2 O1O2O3 O3 a2a3a4  a3 O1O2O3  a4 O3

VI. EXPLANATION WITH EXAMPLE WHICH SUPPORT THE ARGUMENTS   Study the following transaction database  .A={A1,A2,A3,A4,A5,A6,A7,A8,A9>, Assume ?=20%, Since T contains 15 records, it means that an itemset that is supported by at least three transactions is a frequent set    TABLE II.  GIVEN DATASE T  A1 A2 A3 A4 A5 A6 A7 A8 A9  1 0 0 0 1 1 0 0 0  0 1 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0  1 0 0 0 1 1 0 0 0  0 0 0 0 1 1 0 0 0        TABLE III.  TRANSPOSITION OF DATABASE WITH TRANSACTION ID  Item Id Transaction id String Count 1 1,14 2 2 2,4,6,7,13,15 6 3 4,6,10,11,14,15 6 4 2,3,6,13 4 5 1,3,5,8,10,11,12,14 8 6 1,5,7,12,13 5 7 3,5,7,10,11,13,14 7 8 1,2,9,12 4 9 7,15 2     Now Apply Algorithm   1) Pass 1  TABLE IV.  FREQUENT ITEM SET  Item Id Transaction id String Count 2 2,4,6,7,13,15 6 3 4,6,10,11,14,15 6 4 2,3,6,13 4 5 1,3,5,8,10,11,12,14 8 6 1,5,7,12,13 5 7 3,5,7,10,11,13,14 7 8 1,2,9,12 4   L1 :={ 2, 3, 4, 5, 6, 7, 8}   2) Pass 2  Generate candidate for k=2   C2:={{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},{3,4},{3,5},{3,6}  ,{3,7},{3,8},{4,5},{4,6},{4,7},{4,8},{5,6},{5,7},{5,8}, {6, 7}, {6, 8}, {7, 8}}   After Apply DAPS Algorithm  TABLE V.  RESULT OF DAPS ALGORITHM  Item Id Transaction id String Count 2,3 4, 6,15 3 2,4 2, 6,13 3 3,5 10,11,14 3 3,7 10,11,14 3 5,6 1,5,12 3 5,7 3,5,10,11,14 5 6,7 5,7,13 3   L2:= {(2,3),(2,4),(3,5),(3,7),(5,6),(5,7), (6,7)}         3) Pass 3   Generate Candidate for k: = 3   C3:={{2,3,4},{3,5,7},{5,6,7}}  After Apply DAPS Algorithm   Item Id Transaction id String Count 3,5,7 10,11,14 3 5,6,7 5 1   L3 :={( 3, 5, 7)} L: =L1UL2UL3

VII. CONCLUSION Determining frequent objects (item sets, episodes,  sequential Patterns) is one of the most important fields of data mining. It is well known that the way candidates are defined has great effect on running time and memory need, and this is the reason for the large number of algorithms.

We presented a  new research trend on frequent pattern mining is expecting transpose representation to relieve current methods from the traditional bottleneck, providing scalability to massive  Data sets and improving response time. In order to mine patterns in databases with more columns than rows, we proposed a complete framework for the transposition: we gave the item set in the transposed database of the transposition of many classical transaction ID. Then we gave a strategy to use this framework to mine all the itemset satisfying. We used dynamic approach which is better than tradition approach for finding longest common subsequence. We also presented a new research trend on filtering the database in each iteration. Our implementation can be further improved if parallelism is used to store reduced pattern.

Further investigations are needed to clear the possibilities of this technique.

