Attribute Based Sequential Aggregate Signature

Abstract?Attribute based signature (ABS) scheme is an im- portant cryptographic primitive which provides a powerful way for user to control their privacy. However, the computational and storage cost of ABS is reasonable when the number of users involved in the system is huge. In order to reduce the bandwidth needed to transmit attribute based signatures and the time needed to verify them, we propose attribute based sequential aggregate signature (ABSAS) scheme. The ABSAS scheme allows a set of players to sign the different messages compress into a short signature which can greatly decrease the store space.

In this paper, we also formalize ABSAS scheme and prove the security of this scheme in the standard model. The analysis shows that our ABSAS scheme has less signature length and need less verify computation than the traditional ABS which is more appropriate for the actual situation, especially where bandwidth is a bottleneck.

Keywords?Cryptography; Attribute-based signature; Sequential aggregate signature.



I. INTRODUCTION  Cloud computing has drawn extensive attention recently from both academia and industry as a promising comput- ing paradigm. Data security is greatly concerned from users when they offten store sensitive information on cloud servers.

Attribute-based encryption(ABE)[1][2] is considered as a new public key primitive due to it can achieve both information security and fine-grained access control. Compared with ABE scheme, attribute based signatures(ABS)[3] scheme provides a powerful way for user to control their privacy. It also helps to provide fine-grained access control in anonymous authentication systems. The ABS scheme extends identity- based signature where the signer is associate with a set of attributes instead of a single identity string. It provides a powerful way for users to control their privacy: the user can choose the subset of their attributes is relevant for the specific scenario in signing a document. For example, the headmaster wants a professor at age 45 in the computer science department to sign the technical report. In this scenario, this technical report would be sign with access structure {?professor? AND ?CS department? AND ?age 45?}. Any user who has an attributes set that contain the all attribute above could issue the signature. In some cases, there are many users involve in a project. Different users take charge of his owner part of the data. In order to keep the integrity of project document, different user should use his own attribute set to sign the part of data. When the number of user involved in the project is huge, it is difficult for the data storage to manage such  massive signature. Also, different user wants to sign a different document by using ABS and send to cloud center through wireless channel. The cost of bandwidth needed to transmit to the cloud center and space needed to store in the cloud center is reasonable when the number of signing users is huge. We want a scheme can reduce both the transmit cost and space cost in the cloud center.

A multi-signature scheme allows a set of players to sign the same message by generating a short signature which can be verified against the set of these players public keys.

Aggregate signature is a generalization of this notion which each player signs different message with their corresponding private key. Reducing bandwidth and store space is especially crucial for low-energy devices such as RFID chips and sensors.

Such signature schemes could reduce the bandwidth needed to transmit signatures, the space needed to store them, and the time needed to verify them.

In this paper, we propose a scheme called attribute based sequential aggregate signature(ABSAS) scheme in order to reduce the length of attribute based signature. The ABSAS scheme allows a collections of signatures associate with at- tributes to be able to compress these signature into on short signature. This kind of signature have less signature length than the original one and it is more appropriate for the actual situation, especially where bandwidth is a bottleneck.

A. Related work.

In basic ABE scheme, an important application of the Fuzzy Identity Based Encryption (FIBE)[1], a user encrypts the plaintext with a subset of their attributes and the receiver suc- ceeds decrypt the ciphertext with any set of attribute that has at least common attributes with the encrypt attribute set. We call this scheme threshold attribute-based encryption (t-ABE) for describe simplicity. Yang et al.[4] introduce a new crypto- graphic primitive called Fuzzy Identity Based Signature(FIBS) which the signature analogue of FIBE. Shahandashti et al.[5] proposed a threshold attribute-based signature construction for small attribute universe and large attribute universe. Maji et al.[6] introduce ABE scheme can provide strong privacy guarantee for the signer and strong unforgeability guarantee for the verifier. Li et al.[7] gave a hidden attribute-based signatures without anonymity revocation scheme which can reach anonymity and unforgeability. Later, Li et al.[8] pro- posed a new construction of ABS scheme supporting flexible threshold predicate which could compact the signature size and   DOI 10.1109/CLOUDCOM-ASIA.2013.46    DOI 10.1109/CLOUDCOM-ASIA.2013.46    DOI 10.1109/CLOUDCOM-ASIA.2013.46     improve the verification time. Recently, Liu et al.[9] proposed a scheme called attribute based which solved delegation problem of original signer to guarantee integrity of PHR and the anonymity of the signer.

Multi-signature scheme was first introduced by [10]. Boneh et al.[11] proposed the first aggregate signature which is the generalization of multisignature scheme and this scheme was based on the BLS signature in which individual signatures could be combined by any third party into a single constant- length aggregate. The advantage of this scheme is efficiently computable by using bilinear maps. Lysyanskaya et al. [12] employed another aggregate signature, called sequential ag- gregate signature (SAS). In a sequential aggregate signature scheme must be constructed sequentially by each signer mod- ifying the aggregate-so-far signature in turn. Their scheme is constructed in the random oracle. Lu et al.[13] proposed sequential aggregate signature and multisignature scheme.

Their scheme is proven secure without random oracles. The first Identity-based aggregate signature (IDAS) scheme was presented by Cheon et al.[14], this scheme can reduce the signature size into almost a half and efficiently verify multiple signatures.. Gentry and Ramzan[15] designed the efficient Identity-Based (Multi-/Aggregate) Signatures. Their schemes employ a group with a bilinear map in the random oracle mod- el. Boldyreva et al.[16] construct a new aggregate signature scheme called identity based sequential aggregate signature (IBSAS) scheme. Their scheme is constructed based on pair- ings on elliptic curves. Kyung-Ah Shim[17]gave an efficient ID-based aggregate signature scheme with constant pairing computations. Recently, Liu et al.[18] proposed attribute based multi-signature scheme without random oracles and also using the ABMS scheme to verify the integrity of the data in the wireless environment[19]. But the limitation of these a scheme are sign on the same message.

B. Our contributions  In this work, we make following contributions. (1) We define a scheme called attribute based sequential aggregate signature (ABSAS) scheme. We formalize the model of AB- SAS scheme. We also give security model for ABSAS scheme.

(2) We prove our ABSAS scheme is existential unforgeability in the standard model by using the computational Diffie- Hellman assumption. (3) We show our ABSAS scheme have less signature length and verify computation than the standard ABS scheme.

C. Organization  The rest of paper organized as follows: In section 2, we review some concept about bilinear pairing and complexity assumptions. In section 3, we give the formal models and and its security model of ABSAS scheme. In section 4, we give the specific construction about the ABSAS scheme. In section 5, we give security proof under the standard model for ABSAS scheme. Section 6 is we analyze the efficiency of our scheme and the concluding this paper in section 7.



II. PRELIMINARIES  In this section we introduce the notions related to bilinear maps, complexity assumptions and flexible threshold predicate.

A. Bilinear Maps  Let G and GT be two cyclic groups of prime order p with the multiplication. Let g be a generator of G and e be a bilinear map. Let e : G?G? GT be a bilinear map has the following properties:  1) Bilinearity: for all u, v ? G and a, b ? Zp , we have e(ua, vb) = e(u, v)ab.

2) Non-degeneracy: e(g, g) ?= 1.

3) Computability: There is efficient algorithm to com-  pute bilinear map e : G?G? GT .

Notice that the map e is symmetric since e(ua, vb) =  e(u, v)ab = e(ub, va).

B. Complexity Assumptions  Definition 1. The challenger choose a, b ? Zp at random and output (g, ga, gb). The computational Diffie-Hellman(CDH) problem is to compute gab. An adversary A has at least an ? if ??Pr[A(g, ga, gb) = gab]?? ? ?.

The computational (t, ?)-DH assumption holds if no t-time adversary has at least ? advantage in solving the above game.

C. Flexible Threshold Predicate  In this paper, we use predicates ? consisting of thresholds gates. All predicates ?k,??(?) ? 0/1 for ?? with threshold value k. If the number of attribute in ????? exceed threshold k, it output 1. Otherwise, it output 0.

?k,??(? ?) =  { 1, |?? ? ??| ? k 0, otherwise.

D. Lagrange interpolation  In this subsection, we describe Lagrange interpolation which is used in the ABSAS scheme. Given d points q(1), ? ? ? , q(d) on a d ? 1 degree polynomial, we can use Lagrange interpolation to compute q(i) for any i ? Zp. Let S be a d-element set. We define the Lagrange coefficient ?j,S(i) of q(j) in the computation of q(i) as:  ?j,S(i) = ?  ??S,? ?=j  i? ? j ? ? .



III. FORMAL MODELS AND ITS SECURITY MODEL  A. Formal Models of ABSAS scheme  The attribute based aggregate signature can be deiscribed as a collection of following algorithms:  Setup: This algorithm is run by the master entity on input the security parameter and generates the public parameter params of the scheme and the a master secret key. The master entity publishes params and keeps the master secret MSK to itself.

Extract: Given an attribute set ?, the master key and params. This algorithm generates the private key of ?. The master entity will use this algorithm to generate private keys     for all entities participating in the scheme and distribute the private keys to their respective owner through a secure channel.

Sign: Given a message m, an attribute set ?, a predicate ?, a private key d and params, this algorithm generates the signature ? of ? on m. The entity with attribute set ? will use this algorithm for signing.

Verify: Given a signature ?, a message m, attribute set and params. This algorithm outputs accept if a valid signature on message for attribute set and outputs reject otherwise.

Asign: Given master key MSK, the private key d, a message m and its signature ? which is to aggregate and aggregare-so-far ?? on message m. It generates aggregate signature ??? on message m||m under PK||PK.

Avf: Given a sequential aggregate signature ??, a message m, public key PK and attribute sets. If it is a valid aggre- gate signature, the algorithm outputs accept or outputs reject otherwise.

B. Existential unforgeability of ABSAS scheme  We define security for attribute based aggregate signature scheme between a challenger and an adversary.

Setup: The challenger runs the Setup algorithm and obtains both the public parameters params and the master secret key.

The challenger gives the params to adversary and keeps the master secret key by itself.

Queries. The adversary adaptively makes a polynomial bounded number of queries to the challenger. Each query can be one of the following:  -Extract query: The adversary can ask for the private key of any attribute set ?. The challenger responds by running the Extract algorithm and gives the private key to adversary.

-Sign query: The adversary can ask for the signature of attribute set ? on message m. The challenger responds by first running Extract algorithm to obtain the private key and running the Sign algorithm to obtain a signature which is given to the adversary.

-Aggregate sign query: The adversary requests a aggre- gate signature. The algorithm input the aggregate-so-far ?? on the message M. Check the aggregate-so-far ?? verifies, If the aggregate-so-far signature not holds, answer the invalid.

Otherwise, respond with ? = Asign(sk,M, ??,M,PK).

Output: Eventually, outputting a forgery ?? on messages M under keys PK. The challenger key must appear in PK, wlog we assume the challenge key appear at index 1. If the condition holds,it outputs 1, outputs 0 otherwise.

Definition 2. The attribute based aggregate signature scheme is (t, qe, qS , qAS , n, ?)-unforgeable if no t-time adversary mak- ing qe Extract queries, qS Sign queries, qAS Aggregate sign queries can win the above game with advantage more than ?, n is upper bound on the length of the sequential aggregates.



IV. OUR CONSTRUCTION  In this section, we give the concrete construction of the attribute based sequential aggregate signature scheme.

A. Attribute based aggregate signature scheme  Setup: We first define the attributes in the universe U as the element in Zp . A d ? 1 default attribute set from Zp is given as ? = {?1,?2, ? ? ? ,?d?1}. Select a random generator g ? G , a random ? ? Z?p and compute g1 = g? ? G. Next, pick a random element g2 and compute A = e(g1, g2). After that it choose t1, ? ? ? , tn+1 uniformly at random from G. Let N be the set {1, ? ? ? , n+ 1} and we define a function T , as:  T (x) = gx n   n+1? j=1  t ?j,N (x) j .

Finally, select random values y? from Zp and a random vector y = (y1, y2, ? ? ? , yk) from Zkp , then compute and U = (u1, u2, ? ? ? , uk) = (gy1 , gy2 , ? ? ? , gyk). The public parameters are  params = (G,GT , e, g, g1, g2, t1, ? ? ? , tn+1,U, A).

The master key are  MSK = (?, y1, ? ? ? , yk).

Extract: This algorithm generates a private key for an attribute set ?. The algorithm takes the following steps:  1) Choose a d?1 degree polynomial at random with q(0) = ?.

2) Generate a new attribute set ?? = ??? . For each i ? ??, choose and compute di0 = g  q(i) 2 ? T (i)ri , di1 = gri .

3) Finally, output  Di = (di0, di1)i???  as the private key.

Sign: This algorithm takes a private key for the attribute set ?, message m and predicate ?k,??(?) as input. In order to sign message m with predicate ?k,??(?), i.e., to prove owning at least k attribute among an n-elements ??. The algorithm selects a k-element form the subset ?? ? ???? and works as follows: (1) First, algorithm selects a default attribute subset ?? ? ? with |??| = d ? k and chooses n + d ? k random values r?i ? Zp for i ? ?? ? ??. (2) The algorithm computes  ?0 = [ ?  i?????? d ?i,S(0) i0 ][  ? i?????? T (i)  r?i ](u? k?  j=1  u mj j )  rs ,  {?i = d?i,S(0)i1 gr ? i}i?????? , {?i = gr?i}i???/?? , ??0 = grs .

Finally it outputs the signature:  ? = (?0, {?i}i?????? , ??0).

Verify: In order to verify the correctness of the signature ? = (?0, {?i}i?????? , ??0) on m with threshold k for attributes set ?? ? ?? , check the following equation holds:  e(g, ?0)[? i?????? e(T (i), ?i)  ] e(u?  k? j=1  u mj j , ?  ? 0)  = A.

If the equation holds, it indicates that the signature is indeed from some user with k attributes among ??. Otherwise, it denotes the signature is not valid.

Asign: This algorithm takes a private key for the attribute set ?, signature ? on message m which is to aggregate, the aggregate-so-far ?? on message m under public key PK as input. Verify that ? is valid by calling the Verify algorithm and verify the aggregate-so-far ?? by running the Avf algorithm.

If not, it output fail and halt. Check that the public key corresponding to sk does not already appear in PK. If it does, outputs fail and hail. Otherwise, set l = |PK| and parse ?? as (S?1, {?1,j}j???1???1 , ? ? ? , {?i?1,j}j???i?1???i?1 , S?3). Now for each i, 1 ? i ? l . Denote m[i] as (mi,1,mi,2, ? ? ? ,mi,k) and PK[i] as (A1, u?i, ui,2, ? ? ? , ui,k) and signature  ?i = (?i,0, {?i,j}j???i ???i , ??i,0).

Then compute  S1 = S ? 1 ? [  ? j???i???i  d ?j,S(0) i0 ][  ? j???i ???i  T (j) r?j ]  ?(??i,0)y ?+  ?k j=1 yjmj ,  S3 = S ? 3 ? ??i,0.

The aggregator computes an aggregate signature output as:  AG? = (S1, {?1,j}j???1???1 , ? ? ? , {?l,j}j???l ???l , S3).

Avf: The algorithm takes sequential aggregate signature ?? on message m under the public key PK as input. Now for each i (1 ? i ? l), denote m[i] as (mi,1,mi,2, ? ? ? ,mi,k) and denote PK[i] as (A1, u?i, ui,2, ? ? ? , ui,k). Finally, verify the equation  e(g, S1)[ l?  i=1  ? j?????? e(T (j), ?j)  ] e(  l? i=1  u? k?  j=1  u mj j , S3)  = l?  i=1  Ai.

If the equation holds, it output Valid ; if not, output Invalid.



V. SECURITY PROOF  In this section, we show by giving the following theorem to prove the security of the ABSAS scheme.

Theorem 1. The attribute based aggregate signature scheme is (t, qe, qS , qAS , l, ?)-unforgeable if the (t?, ??)-CDH assumption holds in where  ?? ? ?  ( d? 1 d? k  ) pd(nm + 1)(qs)  ,  t? = t+O((d(qe+qS)+nm(qS+lqAS)tm+(d(qe+qS)+lqAS)te), and tm and te are the time for a multiplication and an  exponentiation in G respectively.

Proof: We will assume that adversary A has advantage ? in attacking the scheme. We will construct the algorithm B that solve the CDH with probability at least ??. The algorithm B will be given a group G, a generator g and the elements  ga and gb. In order to use A to compute the gab, B must simulator a challenger for A. Such simulation can be created in the following way:  Setup: Let the default attribute set be ? = {?1,?2, ? ? ? ,?d?1} for some predefined integer d. We let lm = 2qs and choose a random k ? {0, ? ? ? , q}, and random numbers x?, x1, ? ? ? , xq in the interval {0, ? ? ? , 2lm ? 1}.

It then chooses a random n degree polynomial f(x) and an n degree polynomial u(x) such that ?x u(x) = ?xn if and only if x ? ?. B sets ti = gu(i)2 gf(i) for i from 1 to n. Since it is chosen independently at random, we have  T (i) = gi n   ?n+1 j=1  ( g u(j) 2 g  f(j) )?j,N (i)  = g in+u(i) 2 g  f(i). It also chooses additional random exponents z?, z1, ? ? ? , zq ? Zp.

u? = gx ??lmk?m 2 g  z? , uk = g xk 2 g  zk , 1 ? k ? q.

To make the notion easy to follow we define two functions F (m), J(m)  F (m) = x? ? k?l ? ? j  xjmj , J(m) = z ? +  ? j  zjmj .

the master secret key will be g?2 = g a 2 = g  ab and the following equations holds:  v? ? j?M  v mj j = g  F (m) 2 g  J(m).

Extract query: A can make requests for private key on ? such that |? ? ??| < k, We first define three subset ?,??, S in the following manner: ? = (? ? ??) ??? and ? ? ?? ? S and |??| = d ? 1. Let S = ?? ? {0}. For i ? ??, compute Di = (g  ?i 2 T (i)  ri , gri) where ?i, ri are randomly chosen in Zp. For i /? ??, could also simulate as:  D (i) 1 = (  ? j??? g  ?j?j,S(i) 2 )(g  ? f(i) in+u(i)  1 (g in+u(i) 2 g  f(i))r ? i)?0,S(i)  = ( ?  j??? g ?j?j,S(i) 2 )(g  ? af(i) in+u(i) (g  in+u(i) 2 g  f(i))r ? i)?0,S(i)  = ( ?  j??? g ?j?j,S(i) 2 )(g  a 2 (g  in+u(i) 2 g  f(i))? a  in+u(i)  ? (gin+u(i)2 gf(i))ri ? )?0,S(i)  = ( ?  j??? g ?j?j,S(i) 2 )(g  a 2 (g  in+u(i) 2 g  f(i))r ? i? ain+u(i) )?0,S(i)  = ( ?  j??? g ?j?j,S(i) 2 )g  a?0,S(i) 2 T (i)  ri  = g q(i) 2 T (i)  ri .

D (i) 2 = (g  ?1 in+u(i)  1 g ri ? )?0,S(i) = (gr  ? i? 1in+u(i) )?0,S(i).

Sign query: Consider the query for a signature of attribute set on m. If F (m) = 0( mod p), the simulation aborts. Otherwise, B selects a random set ? such that and |?| = d ? 1.

Define gq  ?(i) = g? ? i where ??i is chosen randomly in Zp.

Then it computes gq ?(i) =  (?d?1 k=1 g  ??k?k,??u (i) ) ga?0,??u (i) for  i ? ????. B randomly picks r?i, r? ? Zp for and compute the signature as  ? = (S1, {?k1}i??, S3),     where  S1 = g ? J(m)  F (m)  1 [ ?  i?????? (T (i) ri)  ?i,S(0)][ ?  i?????? T (i) r?i ]  ? (gJ(m)gF (m)2 )r?s = ga2 [  ? i?????? (T (i)  ri) ?i,S(0)][  ? i?????? T (i)  r?i ]  ? (gJ(m)gF (m)2 )rs? a  F (m)  = ga2 [ ?  i?????? (T (i) ri)  ?i,S(0)][ ?  i?????? T (i) r?i ]  ? (gJ(m)gF (m)2 )rs = ga2 [  ? i?????? (T (i)  ri) ?i,S(0)][  ? i?????? T (i)  r?i ]  ? (u? k?  j=1  u mj j )  rs  = [ ?  i?????? d ?i,S(0) i0 ][  ? i?????? T (i)  r?i ](u? k?  j=1  u mj j )  rs ,  S2 = {d?i,S(0)i1 gr ? i}i?????? , S2 = {gr?i}i???/?,  S3 = g ? 1  F (m)  1 g rs .

Aggregate signature query: Algorithm A request an aggregate signature. It supplies an aggregate so far ?? on message M on PK .

The simulator first check that the signature verifies ??, that the public key PK? related to attribute set ?? does not appear in PK, and that |PK| < n. If any of these condition does not hold, B return fail.

Otherwise, B queries its own signing oracle for pk? related to attribute set ?? to obtain a signature on message M . This can be considered as sequential aggregate on message M under PK?. The simulator then use Asign algorithm to construct the rest of the aggregation by adding to ? for each signer PK[i].

It output an aggregate signature ?? on message M||M under PK||PK?.

Output: Eventually, A outputting a forgery ?? = (S?1 , {??ki}i??, S?3 ) on message M under key PK. PK must satisfy |PK| < n. The key related to attribute set ?? must not appear in PK, wlog at index 1 and corresponding message M[1] must not have been queried by A of its sequential aggregate signing oracle. For each i, 1 ? i ? l = |PK|, denote PK[i] as  PK[i] = (Ai, u ? i, ui,1, ui,2, ? ? ? , ui,k).

and M[i] as (mi,1,mi,2, ? ? ? ,mi,k). Note that we have PK? = (A1, u  ? 1, u1,1, u1,2, ? ? ? , u1,k). Furthermore, for each i, 2 ? i ?  l, let (?i, y?i, yi,1, yi,2, ? ? ? , yi,k) be the private key correspond- ing to PK[i]. Algorithm B compute S1 = S  ? 1 ? ?l  i=2 (g?i2  ? ki??i???i  T (ki) r?ki (S?2 )  yi ?+  ?c j=1 yi,jmi,j )  ?1 .

S3 = S ?  We now have e(g, S1)  e(u?1 c?  j=1  u mi,j i,j , S  ? 2 )  ? k1??1??? e(T (k1), ?k1)  =e(g, S?1 ) ? l?  i=2  ? ki?????  e(T (ki) r?ki , g)  ?1 ? l?  i=2  e(g?i2 , g) ?1  ? l?  i=2  e((S?2 ) (y?i+  ?c j=1 yi,jmi,j), g)  ?1  ? e(u?1 c?  j=1  u mi,j i,j , S  ? 3 ) ?1?  k1??1??? e(T (k1), ?k1)  ?1  =e(g, S?1 ) ? l?  i=2  A?1i  [ l?  i=2  ? ki?????  e(T (ki), ?ki)  ]?1  ? l?  i=2  e((S?2 ) (y?i+  ?c j=1 yi,jmi,j), g)  ?1 e(u?1  c? j=1  u mi,j i,j , S  ? 3 ) ?1  ? ?  k1??1??? e(T (k1), ?k1)  ?1  =e(g, S?1 ) ? l?  i=2  A?1i ? [  l? i=2  ? ki?????  e(T (ki), ?ki)  ]?1  ? e( l?  i=2  ui ?  c? j=1  u mi,j i,j , S  ? 3 ) ?1e(u?1  c? j=1  u mi,j i,j , S  ? 2 ) ?1  ? ?  ki??1??? e(T (k1), ?k1)  ?1  =e(g, S?1 ) ? l?  i=2  A?1i ? [  l? i=1  ? ki?????  e(T (ki), ?ki)  ]?1  ? e( l?  i=2  ui ?  c? j=1  u mi,j i,j , S  ? 3 ) ?1e(u?1  c? j=1  u m1,j 1,j , S  ? 2 ) ?1  =e(g, S?1 ) ? l?  i=2  A?1i ? [  l? i=1  ? ki?????  e(T (ki), ?ki)  ]?1  ? e( l?  i=1  ui ?  c? j=1  u mi,j i,j , S  ? 3 ) ?1  =  l? i=1  Ai  l? i=2  A?1i = A1 = A.

If the equation holds and ? = ?? and F (m?) = 0( mod p), B compute and outputs:  S?1? k????? (S  ? 2 )  f(k) (S?3 )  J(m) = gab.

Where  S?1 =g a  ? ki??????  T (ki) rki?i,S(0)+r  ? ki (u?  k? j=1  u mj j )  rs  =ga2 ?  ki?????? (gf(ki)rki?i,S(0)gf(ki)r  ? ki )(gJ(m))rs .

S?2 = g rki?i,S(0)+r  ? ki , S?3 = (g)  rs .

TABLE I. PERFORMANCE ANALYSIS  Functionality/ Scheme Signature size Verification Model Li et al.[8] 2l +  ?l i=1 |ci + di ? ui| O(2l +  ?l i=1 (ci + di ? ui))? R.O.

Ours 2 + ?l  i=1 |ni + di ? ki| O(2 + ?l  i=1 (ni + di ? ki))? Standard  It is the solution to the given CDH problem. This completes the description of the simulation. It remain to analyse the probability of B not aborting.

We define the events Ak, A?, B, C does not abort during Extract queries, Sign queries, Aggregate signature queries  Ak : F (mk) ?= 0(modlm) A? : F (m?) = 0(modp)  B : jn + u(j) = 0(modp)  Form the analysis above, the probability of B not aborting is  Pr[Not? abort] ? Pr[ qI? k=1  Ak ?A? ?B]  The event ?qI  k=1Ak?A? and B are independent. The assump- tion lm(nm + 1) < p implies that if F (m?) = 0(modp) then F (m?) = 0(modlm).

Pr[A?] = Pr[F (m?) = 0(modp) ? F (m?) = 0(modlm)] = Pr[F (m?) = 0(modlm)] ? Pr[F (m?) = 0(modp) ? F (m?) = 0(modlm)] =   lm(nm + 1) .

We also have that:  Pr[  qI? k=1  Ak|A?] = 1? Pr[ qI? k=1  A?k|A?]  ? 1? qI? k=1  Pr[A?k|A?].

Since the output of F (mi1) and F (mi2) (i1 ?= i2) will differ at least one random chosen value, the event F (mi1) = 0(mod lm) and F (mi2) = 0(modlm) are independent. The event Ai and A? are independent for any i. Hence, we have  Pr[  qI? k=1  Ak ?A?] ? 1 lm(nm + 1)  ( 1? qs  lu  ) .

Let lm = 2qs and we get:  Pr[Not? abort] ? Pr[ qI? k=1  Ak ?A? ?B]  ? Pr[ qI? k=1  Ak ?A?] Pr[B]  ? 1 4(nm + 1)(qs)  ? 1 pd  .

If the simulation does not abort, the probability for correct guess of d ? k elements subset ?? from d ? 1 element set  ? is 1/ (  d? 1 d? k  ) . Therefore, the probability of solving CDH  problem as  ?? ? ?  ( d? 1 d? k  ) pd(nm + 1)(qs)  t? = t+O((d(qe+qS)+nm(qS+lqAS)tm+(d(qe+qS)+lqAS)te).

If the simulation does not abort, the probability for correct  guess of elements subset from element set is . Therefore, the probability of solving CDH problem as ?.



VI. ANALYSIS  In order to analyze the performance of our proposed cryptosystem, we compare our ABSAS scheme with Li et al.?s scheme in terms of storage, communication and computational overheads. We define each type of overheads as follows:  Storage overhead: the number of key materials for each entity and signature size storage in the data center.

Computation overhead: the number of key materials for each entity and signature size storage in the data center.

1) Storage overhead: Storage overhead are categorized into following types: the number of public parameters (params) available in the system, the number of private key D(k)(k = 1 : l) holds by each signing owner and the size of signature storage in the data center. The length of private key held by each signer is the same as the Li?s scheme. The public parameters in our scheme is longer than Li?s scheme because we use standard model to construct the ABSAS instead of random oracle. Also, this construction can support large universe construction. The signature size storage in the data center is greatly decreased by using ABSAS than Li?s scheme. We can aggregate l users signature into one short signature which can greatly decrease the storage overhead in the data center.

2) Computation overhead: Li?s scheme uses hash function to calculate the attribute. While in our ABSAS scheme, we use T (i) to construct ABSAS which supports large universe construction in the standard model. The number of multiplica- tion and an exponentiation to calculate T (i) is associate with the security parameter. When l signers involve in the system, ASign algorithm increases 2l more exponentiation and the polynomial number of multiplication, but decreases 2l pairing computation for the verifier by running Avf algorithm.

3) Security model: Li?s scheme uses random oracle model to proof its security. Random oracle model is first designs an ideal system in which all parties (including the adversary) have oracle access to a truly random function and proves the security of this ideal system. Then, one replaces the random oracle by using a ?good cryptographic hash function? which the succinct description of this function is providing to all parties[21]. However, One can indeed make clear statements regarding the security of the ideal system, but it is not clear what happens when one replaces the random oracle by a fully     specified implementation[22]. We use the standard model to prove the security of the ABSAS instead of the R.O. model.

The drawback by using the standard model has increase the length of public parameters.

Here we compares our scheme with scheme [20]. We let l be the number of signer, |ci+di?ui| be the size of the attribute set ??i ? ??i, |U| be the size of the universal of attribute set.

? is paring running time in the Avf algorithm. We make the comparison to list in Table 1.



VII. CONCLUSION  Bandwidth and computation cost is especially crucial for low-energy devices. How to decrease the computation cost for verifying the signature and storage cost for storing the signature is important problem. In this paper, we proposed a scheme called attribute based sequential aggregate signature scheme which have less signature length and need less verify computation than the traditional ABS. The ABSAS scheme is proved secure under CDH assumption. Analysis shows that the storage and verifying computational overheads of the ABSAS scheme is greatly decrease than the previous ABS scheme.

