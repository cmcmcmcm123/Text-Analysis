Incremental mining alogorithm Pre-FP in association rules based on FP-tree

Abstract?At present, most of association rule mining are static mining algorithms. However, in real Web applications, new transactions are usually incrementally inserted into database, the previous algorithms  couldn?t satisfy the rapid growth like this. In this paper, we proposed the incremental mining algorithms called Pre-FP based on PUFP-tree and Per-large- itemsets. This algorithm don?t need rescan the original database when the new transactions surpass the fixed threshold , especially when each time the small fraction of transactions are inserted, Pre-FP can achieve a good execution efficiency for renewing construction of frequent pattern tree.

Key words: Data Mining; web usage mining;  association rule;  incremental mining

I. INTRODUCTION Association rule mining is important in many data  mining tasks. Since people like Agrawal proposed this concept[1], researches that related to association rule mining are always very active. The previous association rule mining algorithms, such as Apriori, FP-growth mining algorithms and so on, are all based on the same premise----the tuples in database are not changed. But in real conditions, transaction database will renew a lot of new transactions everyday. In this case, the association rules which are mined from the original database may be invalid, or there will be new association rules produced. The incremental updating algorithm of association rules (maintenance algorithm) is used to tell us how to mine the association rules efficiently when the premise is not successful. The key point to make these algorithms efficient lies in using the existing results of mining as many as possible to produce the small candidate itemsets or reduce the times of scanning the database. Now most of incremental updating algorithms are the improvement and optimization which take Apriori algorithms as core. For example, Cheung proposed a incremental mining algorithm called Fast-Up-Data (FUP)[2] in 1996. FUP algorithms improved on the basis of the Apriori algorithm and used the branch cut technique of Direct Hashing and Pruning(DHP)[3]. First, it mined the frequent itemsets from the additional tansactions, then, compared them with the ones that mined from the tansaction database before.  According to the results of comparing, FUP decided that if the whole tansaction database needed to be rescanned. The above procedure dramatically reduced the time of renewing the association rules.

Although FUP achieved the idea of incremental mining, however, in some certain conditions, the algorithms still need to rescan the original database. Hong[4] proposed a new Pre-  large-itemsets algorithm which can reduce the times of rescanning the original database in 2001. The algorithm used two different support threshold, ?lower? and ?upper?, to define the frequency of item for the first time. This algorithm doesn?t need rescan the original database when the database is growing, unless there are a lot of new tansactions coming out, thus, Pre-large-itemsets algorithm greatly reduced the time of the renewing association rules.

In order to achieve the idea of FUP algorithm, Hong, Lin and Wu[5] designed a new FUFP-tree on the basis of FP-tree to improve the efficiency of processing the tree reconstruction after adding the new tansactions into the original database. In this paper, we proposed a new incremental mining algorithm called Pre-FP which was based on PUFP-tree and Per-Large-Itemsets[4]. This algorithm refered Pre-large-itemsets to define two support threshold to solve the problem that inconsistent frequency of the new itemsets in the original database and the new tansaction sets. Pre-FP can renew association rules all the time and doesn?t need to rescan the whole database in the process of database growth. Unless the amount of the emergence of new tansactions is greater than a set threshold, this threshold depends on the size of the two support threshold and database.



II. THE INTRODUCTION OF RELATED TECHNOLOGY  A. FUFP-tree The construction algorithm of FUFP-tree is almost the  same as FP-tree, the only difference is that the links between parent nodes and child nodes are bi-directional. The improvement is able to quickly find the nodes which should be removed in the process of renewing FUFP-tree. In addition, all the frequent items and their support counts need to be saved in the item header tables.

FUFP-tree must complete before adding the new tansactions , after adding the new tansactions, the renew programs of FUFP-tree will renew FUFP-tree with adding the new tansactions while don?t need to rescan the original database. The new items will be divided into four parts according to the frequency in the original database and the additional new tansaction sets , every part will be renewed into FUFP-tree through the different processes.

During the process of renewing FUFP-tree, after an original frequent item became infrequent, it will be removed from FUFP-tree directly, then, its parent nodes and child nodes will be linked with each other. Corresponding, after an original infrequent item became frequent for adding the new   DOI 10.1109/ICNDC.2010.49    DOI 10.1109/ICNDC.2010.49     transaction sets, its support usually surpassed support threshold a little, thus, it can be added into the end of the item header table. FUFP-tree need to be rebuilt once time only if the original database increased many tansactions. The updating method greatly improved the efficiency of FUFP- tree update algorithm and saved a lot of time of rebuilding trees.

B. Pre-large-itemsets T.P.Hong and Y.H.Tao first proposed using the two  support threshold called ?lower? and ?upper? to define a new sort of itmset?Pre-large-itemsets in the documents[4]. The definition of upper threshold is the same as that in the general mining algorithms. The definition of lower  threshold is the minimum support threshold of Pre-large-itemsets. If the support count of an item is less than lower, the item is considered to be infrequent. Pre-large-itemsets are considered to be a buffer pool in the process of the incremental mining to reduce the repeated operations which changes the frequent item into infrequent item, and vice versa.

After defined the two support threshold, the original database that is added new transaction sets can be expressed as 9 kinds of situations. The specific classifications are shown in Fig.1, the properties of each case ?s frequency are presented as follows:  a) An itemset is frequent in both D and T. This kind of item set must be frequent in D T? .

b) An itemset X is frequent in D, but it is infrequent in T. This kind of itemset may be frequent in D T? . The support of itemset in D is known , we only need to obtain the support of the itemset in T, then, through calculating if the inequality  . . ( )D TX count X count upper D T+ ? ? + is successful, so we can decide its frequency in D T? .

c) An itemset is infrequent in D while it is frequent in T. This kind of itemset may be also frequent in D T? . The support of itemset in T can be gotten directly, but the support of itemset in D needs to rescan D. At last, the itemset is decided if it is frequent in D T?  by calculating.

d) An item set is infrequent in both D and T. This kind of item set must be infrequent in D T? .

Figure 1.  9 kinds of situations of the renewed original database  Obviously, weighted counts in situation 1, 5, 6, 8, 9 can?t affect the association rules mined. Situation 2, 3 may reduce the existing association rules. Situation 4, 7 may increase the new association rules. If we save frequent itemsets, Pre- large-itemsets and their support counts after renewed every time , the results of Situation 2, 3, 4 will be relatively easy to calculate. In the whole process of renewing, compared with original transaction sets, the additional transaction sets are generally very small, especially when the original database is increasing very quickly. The items of situation 7 in the renewed transaction database can?t change to be frequent items unless the number of transactions in the additional transaction sets surpasses f, f is defined as following[4]:   ( )  u l  u  dS S f  S  ? =  ? ? ? ? ?? ?    f  is called as the safety threshold of the new transaction sets, uS is upper threshold, lS is lower threshold, d is the  number of transaction in the original database. The 9 kinds of situations above and their renewed results are in Table 1.

TABLE I.  THE 9 KINDS OF SITUATIONS AND THEIR RESULTS

III. INCREMENTAL MINING ALGORITHM PRE-FP The impoved algorithm in this paper will use the tree  structure of FUFP-tree and the theory of Pre-large-item.

FUFP-tree in the original transaction database must be finished before adding the new transactions. It used the same method of building FP-tree. First, scan the whole transaction database, find frequent 1-itemsets by Pre-defined minimum support threshold. Then, frequent 1-itemsets are arranged in descending order. Finally, rescan transaction database, construct FUFP-tree by frequent items in frequent 1- itemsets. The whole process is building in transactions, when all the transactions were completed, the building is over. In addition, define another variable c in order to record the new additional transactions since rescanned the original data sets  Situations?original database ? new tansaction sets Renewed results  situation1:Frequent-Frequent Frequent  situation2 :Frequent?Pre-large Need to judge frequent or Pre-large from specific cases  situation3:Frequent? infrequent Need to judge Frequent?Pre-  large or infrequent from specific cases  situation4:Pre-large?Frequent Need to judge Pre-large or Frequent from specific cases situation5 :Pre-large?Pre-large Pre-large  situation6 :Pre-large?infrequent Need to judge Pre-large or infrequent  situation7:infrequent?frequent When the number of additional tansactions is less than f, it is  infrequesnt or Pre-large.

situation8 :infrequent?Pre-large Infrequent or Pre-large situation9 :infrequent?infrequent Infrequent     last time. The marks which are used in Pre-FP algorithm are shown in Table 2.

TABLE II.  MARK THE DEFINTIONS  Marks Definition  D original database T new additional transaction sets  U Renewed transaction database?for example, D d? d The number of transactions in D t  The number of transactions in T  St  support threshold of Lower  Su  support threshold of upper  I  Items  ( )D IS   support count of I in D  ( )T IS  support count of I in T  ( )U IS  support count of I in U  Insert_Items itemsets which need to update into FUFP-tree in T Branch_Items itemsets which need to update into FUFP-tree in D  Rescan_Items the itemsets which need to rescan the whole original transaction database to decide if they are frequent.

The algorithm is described as follows: Input: a tansaction database which has ( )d c+  transactions, item header table which saved frequent 1- itemsets in descending order, corresponding FUFP-tree, support threshold of lower lS , support threshold of upper uS , Pre-large-item list which is used to save Pre-large-items of original transaction database, the new transaction sets which have t transactions.

Output: a updated FUFP-tree.

Step 1: According to the formula ( )  u l  u  dS S f  S  ? =  ? ? ? ? ?? ?  , we  can calculate the safety threshold f of the new transaction sets.

Step 2: Get all the item and their support through scanning the new transaction sets.

Step 3: the items in new transaction sets are sorted into frequent, Pre-large and infrequent by their support in the original transaction database  Step 4: For item of I which was generated in Step 3, if it is frequent in the original transaction database (the elements in the item head table), execute the following steps(Corresponds to the situation1, 2 and 3 in Fig.1):  Substep 4.1: The support of I in the renewed transaction database is updated into,    ( ) ( ) ( )U D TI I IS S S= + ? ( )D IS is the support of I in the renewed transaction database, ( )T IS is the support in the new transaction sets.

Substep 4.2: If ( ) / ( )U UI d c tS S+ + ? , the support count of I in the item header table will be updated  into ( )U IS , and I is put into Insert_Items, it will be  processed in step 10. If ( ) / ( )UU lI d c tS S S? + + ? , I will be removed from the item header table, the parent nodes and child nodes of I are linked in FUFP-tree, set ( ) ( )D UI IS S= , and save I and its support count ( )D IS in the Pre-large item  list. If ( ) / ( )U lI d c tS S+ + ? , I  will be removed from the item header table, the parent nodes and child nodes of I are linked in FUFP-tree .

Step 5: For the item I which was generated in Step 3, if it is Pre-large in the original transaction database, execute the following steps (Corresponds to the situation4, 5 and 6 in Fig.1):  Substep 5.1: the support of I in the updated transaction database is : ( ) ( ) ( )U D TI I IS S S= +  Substep 5.2: If ( ) / ( )U UI d c tS S+ + ? , item I became frequent after the original transaction database updated, put I into Insert_Items and Branch_Items, it will be processed in step 8. If ( ) / ( )UU lI d c tS S S? + + ? , set ( ) ( )D UI IS S= , and save I and its support ( )D IS  into the Pre-large table. If  ( ) / ( )U lI d c tS S+ + ? , I will be removed from the Pre- large table.

Step 6: For the item I which was generated in Step 3?if it is infrequent in the original transaction database while it is frequent or Pre-large in the new transaction sets (situation 7 and 8 in Fig.1), put I into Rscan_Items, these items will be used in rescanning database in step 7.

Step 7: If t c f+ ? or Rscan_Items is null, do no action; else operate the item I in Rscan_Items as followings:  Substep 7.1: rescan the original database to calculate the support count of I called ( )D IS .

Substep 7.2: the support of I in the renewed transaction database is ( ) ( ) ( )U D TI I IS S S= + .

Substep 7.3: If ( ) / ( )U UI d c tS S+ + ? , I becomes frequent item after renewed the original transaction database, put I into Insert_Items and Branch_Items. If  ( ) / ( )UU lI d c tS S S? + + ?  , and save I and its support  ( )D IS  in the Pre-large table. If ( ) / ( )U lI d c tS S+ + ? , do no action.

Step 8: put the items in Branch_Items into the end of the item header table, they are sorted in descending order in the new support count.

Step 9: For the item I in Branch_Items which has already been exsited in the original transaction database, if I doesn?t appear in the corresponding transaction branch in FUFP-tree, put I into the end of transaction branch, and set the support count of I as 1, else add 1 into the support count of I .

Step 10: the item I in Insert_Items which appeared in the new transaction sets, if I doesn?t appear in the corresponding transaction branch in FUFP-tree, put I into the end of the new transaction branch,  and set the support count of I as 1, else add 1 into the support count of I .

Step 11: if t c f+ > , set d d t c= + + , 0c = ; else c t c= + .

In step 9, the corresponding transaction branch is the branch which is generated by frequent items in every transaction according to the sequence in the item header table. After step 11 is executed , a new FUFP-tree is built through Pre-FP Update Algorithm, the new transaction sets have already added into the original transaction database to form a new transaction database. According to the new generated FUFP-tree, we can mine the association rules by FP-growth algorithm[6].



IV. EXPERIMENTAL ANALYSIS OF ALGORITHMS  In this segment, we use FP-tree, FUFP-tree and Pre-FP separately to mine the transaction database. Every time the new transaction sets are produced, the FP-tree algorithm adds the new transaction sets to the original database, and then reconstruct the FP-tree. But the incremental mining algorithm, FUFP-tree and Pre-FP, deal with the new transaction sets in incremental way with the existing mining results.

In order to show the results of the improvement, the mining date source used a larger log sample from online shopping system of Zhejiang Sci-Tech university campus network sites.

The experiment is divided into two parts, in the first test, pick the top 10000 transactions from the transaction database to construct FP-tree. The minimum support threshold is set to 1%-5%, and increases 1% every time, the three kinds of algorithms are compared, then, 800 transactions which are supposed as a new additional transaction sets are used to simulate the growth of database. The upper threshold of Pre- FP algorithm is set to 1%-5% which add 1% every time, the lower threshold is set to 0.5%-2.5% which add 0.5% every time. The execution time of the three algorithms in different support threshold is shown in Fig.2.

Figure 2.  the comparison of execution time under the different support  threshold  From Fig.2 we can see the time-consuming of the FP-tree is much more than the other two incremental algorithms, because after the new transaction was added to database every time, FP-tree must be reconstructed, which consumes a  lot of time. The execution time of Pre-FP is superior to FUFP-tree, because the times that Pre-FP rescans the whole transaction database are less than FUP algorithm. With this in mind, the new increased nodes are always added into the end of the item header table, the updated tree structure of Pre-FP updating algorithm may be different from the one that is reconstructed by using FP-tree construction algorithm.

The effectiveness of Pre-FP is shown in Fig.3, we can see the number of nodes which are generated by the three kinds of algorithms is almost the same, so the tree structure that can be constructed is basically same. So we can conclude that the validity of Pre-FP algorithm is acceptable.

Figure 3.  comparison of the number of nodes under the different support  threshold  The second test is used to compare the execution time and the number of generated nodes of the three kinds of algorithms under the different numbers of the new transaction sets. The minimum support threshold of FP-tree and FUFP-tree algorithm is set to be 4%, Pre-FP algorithm upper and lower thresholds are set to be 4% and 2% separately. Pick the top 10000 transactions from the transaction database to construct FP-tree, in the rest transaction sets, we take a group for every 800 as a new transaction sets to add into the original transaction database.

The results of the experiment are shown in Fig.4 and Fig.5.

Noting that in Fig.4, with the emergence of the new transaction sets and the growth of the original transaction database, compared to FUFP-tree algorithm, the advantages of the Pre-FP algorithm are more and more obvious. Because with the original database increasing, according to the  formula ( )  u l  u  dS S f  S  ? =  ? ? ? ? ?? ?  , f will  also increase  continuously, which means that more new transactions can be added without rescanning the transaction database. With the growth of the transaction database, the relative efficiency of Pre-FP algorithm will become increasingly evident, this feature is very ideal for the rapid growth of the Web usage mining. The results of the experiment for Fig.5 show that with the transaction database increasing, the numbers of nodes which are generated by the three kinds of algorithms are almost the same, which proved the effectiveness of the algorithms under different growth amplitudes of the database.

Through the experiments above, we can prove that the execution efficiency of Pre-FP is much higher than the traditional static mining algorithm PF-tree, comparing to the existing incremental mining algorithm FUFP-tree, Pre-FP also have some advantages, and its validity is as good as the other two algorithms.

Figure 4.  Comparison of the execution time of adding new transaction  sets continuously   Figure 5.  Comparison of the generated nodes of adding new transaction  sets continuously

V. CONCLUSIONS This paper proposed a kind of new incremental mining  algorithm Pre-FP based on the theory of Pre-large-itemsets, its main idea is that through predefined the two support threshold ?upper? and ?lower?,  set a Pre-large itemsets besides the frequent itemsets and the infrequent ones, when the new transaction sets are adding, the frequent items don?t be transformed into infrequent ones or the infrequent items don?t be transformed into the frequent ones directly, but the items are put into Pre-large itemsets first. This method reduced the times of rescanning the original transaction database.

On the basis of the experiment, made a comparison between Pre-FP algorithm and the other two algorithms in the performance and the results of mining, the experimental results show that Pre-FP algorithm has shorten the execution time and has no difference in the results of implementation compared to FP-tree and FUFP-tree, it achieved a good balance between the execution time and the structural complexity .

