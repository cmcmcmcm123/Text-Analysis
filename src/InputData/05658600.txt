Simulation Data Analysis and Study of CQMAR Algorithm

Abstract-The classification and the need of association rules have been outlined, for the analysis of simulation data, this  article has proposed CQMAR algorithm (CAlM and  Quantitative Matrix Algorithm for Association Rules  Analyzing), which only scans the database once, and can handle multi-value data. CQMAR algorithm has a strong  practical effect, which improves the timeliness and accuracy of  analysis, and has important reference value for simulation data for analysis and summary of findings.

Keywords-association rules; simulation datil; AQMAR algorithm; Apriori algorithm;

I. INTRODUCTION  Association is a class of important regularities which can be found between two or more variables. Association rules analyzing is that interesting correlation between itemsets or related links are found in large amounts of data. Association rules in data analysis are an important issue. Association rules are classified according to different situations: Rule? based categories of the variables in the processing, association rules can be divided into Boolean and multi? value type; Rule-based level of abstraction of data, association rules can be divided into single-association rules and multi-association rules; Rule-based data involved in dimension, association rules can be divided into one? dimensional and multi-dimensional [1].



II. CQMAR ALGORITHM  Association rules analyzing is to find the hidden rules of the simulation database. For the main issues of association rules analysis, this article focuses on studying how to get frequent item sets, and introduces the association rules algorithm which is based on CAlM [2] and multi-valued matrix algorithm CQMAR algorithm (CAlM and Quantitative Matrix Algorithm for Association Rules Analyzing), the algorithm introduces the concept of matrix model, and that the classic Apriori [3] algorithm is different and only needs to scan the database once, which can handle multi-value data strong practically.

A. Thinking for Algorithms Definition 2.1 Suppose X is a frequent pattern set, if X is  not all super-set of frequent, then X is called a maximal frequent item sets (maximal frequent itemset) or maximal frequent patterns (maximal frequent pattern).

Fei Yun, Shaoliang Zhou Academy of Armored Force Engineering  Beijing, China E-mail: fengyul124@163.com  Property 2.1:  The real supersets of the maximum frequent itemsets are not any frequent.

Property 2.2 : All non-empty sets of the maximum frequent itemsets are frequent.

Through the Property 2.1 and Property 2.2, we can see the maximum frequent itemsets are the dividing line between non-frequent itemsets and frequent itemsets. Maximal frequent pattern sets in the following are frequent patterns, maximum frequent pattern sets over are all non-frequent pattern. Therefore, as long as finding all the maximal frequent patterns, you can get all the frequent patterns by all the frequent subsets [4]. These two properties are important basis for this article.

B. Improvement of the Boolean Matrix Algorithm Use CAlM algorithm in literature [2] instead the  numerical attribute values of interval. And, compared with the Boolean association rules, which transforms multi-valued association rules directly , this article does not limit the number of time interval after dispersing, so that it ensures data compatibility and consistency after discretization in the maximum extent, reducing the loss of information.

? Creating the Pattern Matrix  Definition 2.2: Set up that itemset 1= {ip i2, ??? , iJ ' the transaction set D = {II' 12, ??? , 1m}' then the pattern matrix is generated as follows [5]: each element of matrix P {Pij} is defined as follows:  {I, Pij  = 0,  'liij Eli'  'liij ? Ii' There, i =  1,2, ... , m; j = 1, 2, ... , n.

(2-1)  Set up a database containing n matters. All matters involves m items, then the corresponding pattern matrix can be considered to be composed of the m-column vector of n,  Yi denotes the ith column vector, Y ij denotes the i-jth item  in the emergence 0 f affairs or not, if appearing, there is Y ij =  I, otherwise Yij = O.

Each line of matrix P for the same pattern can be  considered as vectors Xi' Xi denotes the ith column vector,  xij denotes the i-jth item in the emergence of affairs or not,  if appearing, there is xij = 1, otherwise xij = O.

For example: Set up I = {A,B,C,D,E,F} , tmnsaction  database tl ={A,B,C} , t2 ={A,C,D} , t3 ={A,B,E,F} , t4 ={A,B,C,D,F} , t5={B,C,D,E). Matrix is genemted:  1 1 1 0 1 0 1  1  p= 1 1 0 0 1 1 1 1 o 1 1 1  o 0 o 0 1 1 o 1 1 0  (2-2)  Therefore, the type (2-2) can also be expressed as:  Yl Y2 Y3 Y4 Ys Y6 XI 1 1 1 0 0 0 x2 1 0 1 1 0 0  P= x3 1 1 0 0 1 1 x4 1 1 1 1 0 1  X5 0 1 1 1 1 0 (2-3) ? Creating Frequent Itemsets Through the formation of pattern matrix, scan the  database once and get pattern matrix P, we will operate the database through operating on P, and get frequent itemsets  by computing the column vector Yi . Set the minimum support for the Smin = a%, SUP is the number of 1 in the vector. According to the definition of frequent item sets, we  take bitwise opemtion for the vector Yi' if the SUP value is not less than s in the results, then the items set corresponding to the vector shall be frequent itemsets; if less than s, then the items set must not be a frequent item set and we remove it. Continue to build pattern matrix after making opemtions on the vector retained, and as with the opemtion, repeat the above work, until the pattern matrix leave only one row or to be O. Finally, through all saved vector, output its corresponding itemsets, namely frequent itemsets L.

? Genemte Association Rules through Frequent Itemsets  After getting frequent itemsets L, genemte association rules from it, the geneml form is {X ? R - X}, measure of association rules is the support s and confidence c, where X, R must be frequent itemsets, and Xc R; X, R E L , requires ? Smin' C ? Cmin?  Read all X and R meeting the conditions of X C R from the L, and calculate confidence con/(X ? R - X) . If con/(X ? R - X) exceed Cmin ' then produce X ? R - X as a rule.

C. Propose the Algorithm This section focuses on the how to get association rules  of frequent item sets, the Boolean matrix method is the basis for CQMAR algorithm whose purpose is to transform from the multi-valued attribute matrix to a Boolean matrix for further operations. Literature [3] presents method of association rules algorithm to deal with Boolean matrix in the Apriori, this section has given the algorithm for tmnsforming the multi-value matrix to the Boolean matrix algorithm based on discrete CAlM [2]. First, two definitions are given:  Definition 2.3 The sub-vector Djp of vector Dj is defined as: Djp = (d1jp, d2jp, ... , dijp, ... , dmjp) T, where dijp denotes p-bit value in row j column i of the matrix.

Definition 2.4 : The length of the vector Dj is represented by 1 Dj I, namely Dj domain width.

Table 2-1 is a typical mixed-attribute decision table, which contains both discrete attributes and continuous attributes, so the data should be discretized. Use CAlM [2] algorithms to discrete Tab Ie 2 -1, then, get the decision tab Ie after discretization, as shown in Table 2-2:  TABLE I. THE REBUILDED DECISION TABLE  C D U Subhead Roadc2 Weather Numberof Damage  speed Cl C3 people C4 rate d 1 4.62 9 sunny 42 1.98 2 8.63 4 cloudy 18 20.30 3 11.51 8 sunny 12 3.68 4 3.55 3 sunny 12 4.25 5 7.35 4 sunny 16 3.14  . . .  . , .  . . .  . . .  . . . . .  .

TABLE II. DECISION TABLE AFTER DISCRETIZATION  C D U Speed Roadc2 Weather Numberof Damage  Cl C3 people C4 rate d 1 1 2 1 3 1 2 2 1 2 2 2 3 3 2 1 1 1 4 1 1 1 1 1 5 2 1 1 2 1  . . . . .  , ' "  . . .  . . .  . . .

DIscrete attrIbutes for codmg based on Table 2-3:  TABLE III. GIST OF ATTRIBUTES ENCODING FOR DECISION TABLE  Serial Coding Numb Attribute  er 1 2 3  1 Speed Cl [2.56,5.16] [5.89,9.35] [9.55,12.1 2] 2 Road C2 [3,5] [6,9]  3 Weather C3 sunny cloudy  4 Number of [7,13] [15,26] [33,46] people C4  5 Damage rate [1.67,8.98] [18.49,27.65] [31.25,44.

d 68]    Get various divided intervals and their corresponding codes, Boolean code: if code number is 2, Use 0 and 1 encoded directly; if code number is greater than 2, Boolean length of the field after a set of values of the data can be number (that is the domain width in the definition 2.4), each of the value is 0 or 1, the position of 1 is decided by the corresponding data. Take the discrete data encoding in the table 2-3 for example, Boolean encoding is in the following table:  TABLE IV. BOOLEAN DISCRETIZATION OF ATTRIBUTES ENCODED  Serial Attribute  Coding number I 2 3  I Speed Cl 100 010 001  2 Road C2 0 I  3 Weather C3 0 I  4 Number of 100 010 001 people C4  5 Damage rate d 100 010 001 The Data after Boolean Encodmg IS shown m Table 2-5:  TABLE V. DECISION TABLE AFTER BOOLEAN ENCODING  C D U Speed Roadc2 Weather Number of Damage  Cl C3 people C4 rate d I 100 I 0 001 100 2 010 0 I 010 010 3 001 I 0 100 100 4 100 0 0 100 100 5 010 0 0 010 100  Scan Table 2-5 and get the followmg matrix:  YI Y2 Y3 Y4 Ys  Xl 1 00 1 0 00 1 1 00 x2 0 1 0  0 1 0 1 0  0 1 0  P= x3 00 1 1 0 1 00 1 00 (2-4) x4 1 00 0 0 1 00 1 00 Xs 0 1 0  0 0 0 1 0  1 00  Making Yb Y4, Ys in the type (2-4) reclassified in accordance with each sub-vector can obtain the following matrix:  Yll Y12 Y13 Y2 Y3 Y41 Y42 Y43 Y51 Y52 Y53 Xl 1 0 0 1 0 0 0 1 1 0 0 X2 0 1 0 0 1 0 1 0 0 1 0  P= X3 0 0 1 1 0 1 0 0 1 0 0 (2-5) x4 1 0 0 0 0 1 0 0 1 0 0 Xs 0 1 0 0 0 0 1 0 1 0 0   The type (2-5) is matrix P transformed from the matrix, and then we can get the corresponding frequent itemsets.

D. Algorithm Flow Algorithm 2.1 CQMAR algorithm Input: Information system S= <U, A, V, f) , where  U is the universe of discourse U = {xl' x2' ? ? ?  , xJ minimum support is S min .

Output: frequent itemsets L.

Step 1: Generating pattern matrix.

Step 1.1: Discretization of the information system; Step 1.2: If discrete value is Boolean type, go to Step 1.4;  if discrete value is multi-value type, go to 1.3; Step 1.3: The Boolean encoding of multiple values; Step 1.4: Scan the database once, get pattern matrix P; Step 2: Generate frequent 2 - itemsets.

Step 2.1: First of all, calculate SUP of each column  vector of the P, if SUP <s, then round the colunm vector; If SUP> s then save the column vector. At this time, preserved column vector corresponding to the items set shall be frequent 1 - itemsets;  Step 2.2: According to the original model, re-combine the preservation of the colunm vector P into a matrix, then, we can get pattern matrix PI;  Step 2.3: Operate on the colunm of PI for by-bit, and calculate SUP of operations results, if SUP <s then round the column vector, If SUP> s, then save the column vector. At this time, preserved column vector corresponding to the items set shall be frequent 2 - itemsets;  Step 2.4: According to the original model, re-combine the preservation of the column vector of PI into a matrix, then, we can get pattern matrix P2;  Step 3: Generate frequent k-itemsets.

Step 3.1: first, Operate on the colunm of Pk-I for by-bit,  and calculate SUP of operations results, if SUP <s then round the column vector, If SUP> s, then save the column vector. At this time, preserved column vector corresponding to the items set shall be frequent 2 - itemsets;  Step 3.2: According to property 4.2, cut branch the preservation of the column vector P, the itemsets corresponding to the remaining column vector shall be frequent k-itemsets;  Step 3.3: According to the original model, re-combine the preservation of the column vector from Step 3.2 into a matrix, then, we can get pattern matrix Pk;  Step 3.4: If the pattern matrix only includes one column or Pk is empty, the algorithm end; otherwise repeat from Step 3.1 to Step 3.3 until the pattern matrix only includes one column or Pk is empty.



III. COMPARE CQMAR ALGORITHM WITH APRIORI ALGORITHM  Through Apriori analysis from the literature [3], for CQMAR algorithm, we can compare and analyze these two algorithms in the following areas:    A. Data type Apriori algorithm can only deal with Boolean data, for  each property of the database it can only set a breakpoint and may result in loss of information. But, the CQMAR algorithm does not restrict attribute value type, and can keep the consistency of data.

B. Time complexity Apriori algorithm needs to scan the database many times,  repeats operation, the algorithm's time complexity  is 0(1 D Ik+!) , I D I denotes the number of transactions the transaction database contains. The CQMAR algorithm only needs to scan the database once, time complexity  is O( mk n) , and m denotes the number of row pattern matrix scan, n denotes the number of column for the pattern matrix after Boolean operation. In practice, for large transaction databases, in general the number of transactions is much larger than the number of items, that is IDI D n. Therefore, CQMAR algorithm has better time efficiency.

C. Space complexity Apriori algorithm generates a large number of candidate  itemsets, and all having the same length candidate items must be stored in memory, it will take up a lot of memory space, causing memory constantly change in-to for the operation. The CQMAR algorithm uses the matrix for storage, it is no longer use database operations, it has a significant reduction in the required I / 0 times and reduces   storage space, debug that, it does not need to store all the candidate itemsets in memory and it has good spatial characteristics .



IV. CONCLUSION  Based on study of the simulation data analysis of association rules, these article pointes out the necessity and significance of association rules, and then introduced CQMAR algorithm. The algorithm can reduce the times for database scanning of the data analysis process, and can analyze multi-value data association rules, numerical tests show that this algorithm can save time for data analysis of association rules, the algorithm is applied to the simulation data analysis, achieving good results.

