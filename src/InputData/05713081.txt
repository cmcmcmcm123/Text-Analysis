THE PREDICTION OF SOFTWARE AGING TREND BASED ON USER INTENTION

ABSTRACT  Owing to the limitation of traditional software aging trend prediction method that based on time and based on measurement in dealing with sudden large scale concurrent questions, this paper proposes a new software aging trend prediction method which is based on user intention. This method predicts the trend of software aging according to the quantity of user requests for each components during the moment of system operation, and the software aging damage with each component is requested once.The experiment indicates, compared with the measurement  method, this method has highter accuracy in dealing with sudden large scale concurrent questions.

Index Terms?software aging,user intention prediction, cumulation damage, multivariate linear regression analysis , association rule mining  1. INTRODUCTION  Recent studies and extensive data indicate that the system failure occurs mostly due to software defects. With software working, system resources gradual exhaust or run errors gradual accumulate, they both cause system performance continues to decline and even hang down. This phenomenon is known as software aging[1].The reason why it happens is that, in the long-term continuous operation, software exists the occupation and leak in system memory, not released file lock, the data is not updated in time, storage space debrisa and the accumulation of rounding errors, etc.[1]. This phenomenon seriously threats the software reliability, especially if the server which faces extensive visits and large amount of data was down caused by aging, it wouldn?t respond to user requests and make significant losses. In order to resolve this problem, software rejuvenation is introduced. This kind of "software restore" technology is formally proposed in [2] by Y. Huang who come from AT&T Bell Laboratory. Software rejuvenation is a preventive measure designed to prevent accidental failure.

Simply, it terminates the running of program when the performance of software declines to a certain degree, restarts the system to clean up its internal state (such as collect  garbage, update the operating system kernel tables, re- initialize  the internal data structure, etc .)  and release of  the operating system resources, so that performance of software could be restored[2]. The key of software rejuvenation technique is to find the optimal rejuvenation time by the prediction of software aging trend. According to previous researches, we can group the prediction of software aging trend into two basic ideas. One is time-based[2], that is to establish mathematical model based on state of software system, and then to predict by mathematical method. S.Garg etc. [3] propose a most perfect comprehensive model about time-based. Another is measurement-based[4], that is to predict by main parameters which are monitored during actual running process . In [4], S.Garg proposes the key parameter is memory usage which is likely to lead to software aging. In addition, K. Vaidyanathathan etc. [5] take the system load into account, they think the rate of resources consumption as not only the function of time but also load.

It can be seen through the above description, time- based approach is easy to accomplish, but it does not measure the current state of the software, therefore it applies only to the system which has small changes in visiting and loading. The measurement-based method monitors the condition of running system to predict, but in unknow circumstance such as  sudden large scale concurrent, because of unexpected factors, it is difficult to predict based on current data. Therefore, this paper proposes a new software aging trend prediction method which is based on user intention. The reason why system aging is that various components effect, each component generates a little aging damage after it is requested once, according to the predicted result of  user intention, all the damages are accumulated to get the amount of damage of whole system. In this paper, firstly, use the method of multiple linear regression to compute the aging damage coming from various components which are requested once, and then predict the users  access amount in "next moment",finally, accumulate them to predict the software aging trend.

2. EXTRACT THE AGING DAMAGE OF COMPONENTS  Software aging is an process that error continuously accumulates, it usually shows through the loss of system  ___________________________________     resources, however, it does not immediately cause system failure, instead of gradual deterioration even failure.

Therefore, through the asymptotic loss of system resources, it can judge if the software exists aging problem or not. The use of system resources includes two parts: the normal running and the software aging damage. The normal running part is varied with system load, while the damage part appears an obvious upward or downward trend. Figure 1 shows a collection of system available memory data, it is observed that the available memory is random and rapid changing, that is because the load is gradually changed during system operation, but among the entire process, it appears an obvious downward trend, which is caused by the software aging damage. To analyze the process of software aging, firstly need to extract the software aging damage part from the normal running part[6].

Fig. 1 system available memory  The next step is to calculate the amount of damage after each component is requested once according to the overall damage. The whole system aging is the result of various components combined effect, this process could be seen as multiple independent variables affect a dependent variable, so we can solve this problem by multivariate linear regression analysis  method[7]. Take the damage of the whole system as dependent various and the damage after each component is requested once as independent various.

Comput the influence factors(the coefficient of independent various) according to the history records, then to predic. In addition, physical memory leak is an important factor leading to software aging, this paper takes  memory as research object. For illustration, make the following definition:  Definition 1 Set (Y,T)=((y1,t1),(y2,t2),(y3,t3),?,(yn,tn)) as the consumption of memory during interval time (t i-ti-1, i=1,2,?,n).

Definition 2 Set (S1,S2, ?,Sk) as the components deployed in the server, (x1,x2, ?,xk) as the amount of each component is called, in the k+1 dimensional sequence (?0 ?1 ?2 ?,?k), when k = 1,2, ..., k, it is the consumption of each component is called once, when k = 0 , it is the basic consumption of memory during the server running.

Definition 3 Set ?=(?1 ?2 ?,?n)as the random error, and ? N(0 ?2).

Take the n group of observed value (yi xi1,xi2, ?,xik) i=1 2?n,as the equation set:  1 0 1 11 2 12 1 1  2 0 1 21 2 22 2 2  0 1 1 2 2  k k  k k  n n n k nk n  y x x x y x x x  y x x x  ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ?  ? ? ? ? ? ?? ? ? ? ? ? ? ?? ? ? ? ? ? ? ? ? ?  1?? k1xk ? 2? k2xk  ? nkk? kxk Where yi(i=1,2,?,n) is the consumption of memory resources in some time, it is measurable, xij(i=1,2 ?,n j=1,2,?,k) is the  amount of each component is requested form i-1 to i period, it is recordable too. ? is the consumption of the memory caused by each component is called once and ? is the random error, the two values are waiting tested. The above equation can be written in matrix form in formula 1:  Y=X?+?                                           (1)  Where  11 12 1  21 22 2  1 2    k  k  n n nk  x x x x x x  X  x x x   ? ? ? ? ? ? ? ?  ?1kx1   1k ??1k x 2kx x     ?nkx   , Y=(y1,y2,?,yn)T,  ?=(?1 ?2 ?,?n)T, ?=(?0 ?1 ?2 ?,?k)T .

We can get ? by OLS. The solution of formular 1 is:   ' 1? ( ) 'X X X Y? ?? (2)  When yi=?0+?1xi1+?2xi2+?+?kxik+?i, define residual error ei as the estimation of random error ?(the form of ei defined in formular 3), so the estimation of ?2 is SSE, it is defined in formular 4.

0 1 1 2 2i i i i k ike y x x x? ? ? ? ? ? ? ?  ? ? ? ? ? ? k ikxk i? (3) Qe=e12+e22+?en2                                                         (4)  3. THE ACCUMULATION OF SYSTEM AGING DAMAGE  In order to predict the consumption of system memory caused by aging while the call number of components are  1 2( , , )kx x x x? (( , ,1 2x ( ,1 2 )k ) , it uses of the formula 5: 0 1 1 2 2 k ky x x x? ? ? ? ?? ? ? ? ? ??1 2 21 2?? ?? ?x x1 2 2 k kk kkk k??? kxk k               (5)  in formula 5, ? and ? are the estimated value in section 2, so now, the key is to seek for the number of call for various  components in "next time" , it is 1 2( , , )kx x x x? (( , ,1 2x ( , ,1 2 )k ) .

The services usually exsit in the form of components in  web site, there are various relationships information between components and components, and they are closely contacted with user access pattern. When a user visits a web site, it records the access log, the accumulated access logs are the best object of data mining[8]. By mining these logs, user access patterns can be found. For example, Association Rule Mining can get related information between components through history use access, make use of the information to predict the future situation of the user access real-time.

3.1Basic Concepts  In order to analyze the association rule between components, the formal definition is following:  Definition 4 (Component Set) All of the components appearing in the web site are expressed as  p=(p1, p2, ?, pk), the web pages which execute same function form a component.

Definition 5 (Item Sets) A series of components which are visited by someone user are called the item set ui, ui p. Define the number of items as the size of item sets.

Definition 6 The support S(pi) of pi p is the frequency of components appear.The support S(pi, pj) of pi pj is the frequency of components combination appear.

Definition 7 The confidence of rules pi=>pj is  S p p (p p )  S p i j  i j i  C ?  ?? ? ,it means the probabilityof  access the component pj after pi Definition 8 The importance of rules pi=>pj is I(p =>p ) ln[ (p |p ) / (p |not p )]i j j i j iC C?  , it means the effectiveness of the rules, if the value is the higher, the rule is more effective.

3.2 Mining User Intention by Association Rule  First of all, through the user access logs we can get a transaction database, such as Table 1.These data describe a series of components accessed by the users, for instance, T1 user accesses to the p1, p2 and p5 components. Take these records as historical data, through a large number of them to mine the relation information between components.

Table 1 user access record user component user component T1 p1 p2 p5 T6 p2 p3 T2 p2 p4 T7 p1 p3 T3 p2 p3 T8 p1 p2 p3 p5 T4 p1 p2 p4 T9 p1 p2 p3 T5 p1 p3  Then, according to the above historical data, us e association rule mining algorithm to get the possibility that is similar to user access pj after access pi. There are two key steps in association rule mining algorithm, the first  is how to generate frequent itemsets, the second is how to generate association rules based on frequent itemsets. Apriori[9] is a classical association rule algorithm, this paper uses it to get the posibility of user accesses pj after pi. The basic idea of Apriori algorithm could be found in[10], here is not described in detail.

Finally,build the confidence matrix Ck?k(fumula6) according to the confidence computed through Apriori algorithm . where Cij is the confidence of accessing pj after pi. If it is known that the amount of user request for each  components at the current time is ? = (?1, ?2, ..., ?k), the total amount of user request for component pj at the next time is expressed as fumula 7.

11 12 1  21 22 2  1 2  k  k k k  k k kk  C C C C C C  C  C C C  ?   ? ? ? ? ? ? ? ?  ?1kC1   1k ??1k C 2kC2 C    C ?kkCk C (6)   k  j i ij i  P C? ?  ?? (7)  Similarly, the total amount (P1,P2, ?,Pj) of user request for other components is easy to solve. P=(P1,P2, ?,Pj) is equal  to 1 2( , , , )kx x x x? (( , ,1 2x ( , ,1 2 )k, ), .

3.3Accumulating Damage Model  The memory damage of the whole system is the accumulation of all the components damages coming from the process of  requestion. It is  known the damage while each component is called once and the amount of calling at the next time, it could  predict the remain of system memory at the next time. The accumulating damage model can be expressed in the form of formula 5. ?0 ?1 ?2 ?,?k and ?  are estimated in section 2 , 1 2( , , , )kx x x x? (( , ,1 2x ( , ,1 2 )k, ), is estimated in section 3.

4. EXPERIMENT  The research is accomplished under the operation of Microsoft Windows XP configurate a Tomcat server which is saved 5 components, these components are compiled in JAVA. In order to simulate the phenomenon of software aging caused by memory leak, the basic function of these components is to create an object which occupies a certain amount of memory as well as doesn?t release before restarting the server. In this way, when each component is called, it produces a certain degree of memory leaks. By using pressure measurement tool provided by Loadrunner, virtual users are created to ask for these components, as described in Table 2, the result is demonstrated in figure 2.

The purple line is the actual running result of the system,the green line is the result of software aging trend prediction based on user intention and the red line is the result of measurement-based. From this picture, it can be seen that when the change of access amount is not significant,the two prediction methods both are near to the real value. However,when the change of access amount is dramatical, it is similar to the moment of 10 minutes, the measurement-based method can?t adapt to change of access amount, it predicts the software aging trend according to the outdated state. Similarly ,when the moment of 14 minutes,    the access amount is dramatically increasing from 0 to 220, the measurement-based method makes an inaccurate prediction too. On the contrary, whether the change of access amount is significant or not, the method based on  user intention could accurately predic the software aging trend. So ,it can be concluded that, compared with the measurement method, this method has highter accuracy in dealing with sudden large scale concurrent questions.

Table 2 request data  Fig. 2  prediction result  5. SUMMARY  Software aging of the system is due to the call and transformation of various components , each component will generate a certain of damage after calling, the more the amount of visiting, the greater the degree of aging. This paper calculats the damage of each component is requested once according to the history record by multiple linear regression, and then predict the amount of visiting for the next time by association rule mining, finally, accumulate the amount of damage from concurrent request to get the total amount of damage of entire system during certain period.

Using it to predic the software aging trend. The experiment illustrats that this method of considering the system loading is more precise than measurement-based method in solving the large concurrent problem.

6. REFERENCES  [1]Castelli V, Harper RE, Heidelberger P, etc. Proactive Management of Software Aging[J].IBM Journal of Reaserch & Development,2001,45(2):3ll 332.

[2]Huang Y,Kintala C,Kolettis N,etc.Software Rejuvenation: Analysis,Module and Application[C].Proceedings of the 25th  Symposium on Fault Tolerant Computer Systems, Pasadena, CA,1995:381?390  [3]Grag S,Puliafito A,Telek M,Trivedi K S.Analysis of Preventive Maintenance in Transactions Based Software [4]Garg S,van Moorsel A,Vaidyanathan K,Trivedi K S.A Methodology for Detection and Estimation of Software Aging.In:Intl.Symp.on Software Reliability Engineering, ISSRE 1998,Nov 1998.

[5]Vaidyanathan K,Trivedi K S.A Measurement-Based Model for Estimation of Software Aging in Operational Software Systems.In:Intl.Symp.on Software Reliability Engineering, ISSRE 1999,Nov 1999.

[6]Jiang L e-t i an ,Xu Guo-z hi ,Z hou L i n g-l i n g.

Abstraction of Software Aging Trend Ba sed on Robust Locally Weighted Regre ssion Algorithm[J]. Journal Of Shanghai Jiaotong University,2006,40(11):1951-1954.

[7] Wang Hui-wen, Ye Ming, Gilbert Saporta. Classification for Multiple Linear Regression Methods[J].Journal of System Simulation,2009(22):7048-7056.

[8]RUAN Guang-ce Ah-HwweYu.Heuristic Web mining algorithm based on interesting degree strategy.Computer Engineering and Applications 2009 45 35 148-150.

[9]Agrawal R, Imielinski T, Swami A. Mining association rules between sets of items in large databases .Proceedings Management of Data. New York, NY, USA: ACM Press, 1993:207-216 .

[10]Jiawei Han Micheline Kamber. Data Mining concetpts and techniques.China: Mechine Press,2007 137-138.

