Structure of Association Rule Set   based on Min-Min Basic Rules

Abstract? In this paper, we partition the association rule set into disjoint equivalence rule classes. Each of them contains rules having the same confidence and then it is split into basic and consequence rule sets based on the order relation on it.

Basic rule set, which includes minimal elements according to this relation, is directly found by our algorithm MG_BARS. In addition, by adding appropriate eliminable itemsets to both sides of basic rules in our algorithm MG_CARS, the consequence rules are completely and non-repeatedly generated and are confidence-preserved. Results of the experiments proved the efficiency of the above algorithms.

Association rule; basic rule;  consequence rule; generator; eliminable itemset.



I. INTRODUCTION The number of association rules found in knowledge  discovery problems in data mining is usually enormous [1].

Hence, understanding the structure of the association rule set enables us to generate various efficient algorithms to find out the rules. Recently, researchers often split the association rule set into sets of basis and consequent. Taouil et al. [4] proposed a basis for association rules. In [3], based on the concept of minimal rules, Pasquier et al. considered basic rules as min-max form (i.e. left-hand side of the basic rule is minimal and its right-hand side is maximal). Based on the concept of the most general rules, Zaki [6], considered basic rules as min-min form (i.e. both their left- hand and right-hand sides of the basic rules are minimal).

However, in order to find out basic rules, Zaki?s algorithm used many candidates. Moreover, he did not figure out an algorithm that can generate consequence rules from basic rules, whereas the consequence rules together with their support and confidence are essential for users.

In [5], we proposed algorithms to completely and quickly find basic rules as min-max form, and thus were able to find their consequence rules. In this paper, we explicitly show the structure of the association rule set by using the concept of basic rules as min-min form. Based on an equivalence relation, the association rule set will be partitioned into disjoint equivalence rule classes. As the result, we need to investigate only the structure of each equivalence rule class independently. Due to this partition, efficient parallel algorithms for mining association rules can  be easily obtained. After proposing an order relation between rules belonging to the same equivalence rule class, we define the basic rules as minimal elements according to this relation. The algorithm MG_BARS is indicated to quickly and directly find basic rules. Then with our algorithm MG_CARS, by adding eliminable itemsets to both sides of the basic rules, consequence rules are generated.

Both the basic rules and consequence rules are in the same equivalence class. Hence, the consequence rules are confidence-preserved, non-repeated. Moreover, they are totally different from all rules in other equivalence classes.

This efficient algorithm helps to reduce a considerable amount of time for mining consequence rules.

The rest of the paper is organized as follows. Section II recalls some primitive concepts and results of closed and eliminable itemsets in the association rule mining problem.

Section III presents the structure of the association rule set based on the concept of basic rules as min-min form. It also indicates efficient algorithms for finding rule sets of basis and consequent. Sections IV and V show the experimental results and conclusions.



II. PRIMITIVE CONCEPTS AND RESULTS  A. Primitive concepts Given set O contained transactions and A contained  items related to each of transaction o ? O and R is a binary relation in O x A. Now, consider two set functions: : 2O  2A, : 2A  2O determined in the following: ?A?A, O?O: (O) = {a?A | (o, a) ? R, ?o?O}, (A) = {o?O | (o, a) ?  R, ?a?A}. Defining the set function h in 2A by: h =  o , we say that h(A) are the closure of A. An itemset A ? A is a closed itemset if h(A)=A [2].

Let s0 be the minimum support, s0 ? [0; 1]. The support of an itemset A ? A is defined as s(A) = |?(A)|/|O|. If s(A) ? s0 then A is frequent itemset [1]. Let CS be the class of all closed frequent itemsets.

Let c0 be the minimum confidence, c0 ? (0; 1]. For any frequent itemset S (with threshold s0), we take a non-empty, strict subset L from S (??L?S), R = S\L. Let r: L?R denote the rule created by L, R (or by L, S). Then, s(r) =     s(S), c(r) = |?(S)|/|?(L)| = s(S)/s(L) are the support and confidence of r respectively. The rule r is an association rule if c(r) ? c0 [1]. Let AR_S ? AR_S(s0, c0) be the set of all association rules with thresholds s0, c0. Briefly, we call the association rules simply rules. For two non-empty itemsets G, A: G?A?A, G is called a generator of A if h(G)=h(A) and (?G? ? G  h(G?) ? h(G)) [3]. Let G(A) be the class of all generators of A.

In class 2A, an itemset R is called eliminable in S if R?S and ?(S) = ?(S\R). Let N(S) denote the class of all eliminable itemsets in S, N*(S) := N(S) \ {?}, we have [5]:  N(S) = {A: A ? S\G0, G0 ? G(S)}.

B. Primitive results Closed mapping h: 2A?2A generates a binary relation ~h  in class 2A: ? A, B ? A: A ~h B ? h(A) = h(B).

We see that ~h is an equivalence relation. It partitions 2A into the disjoint equivalence classes [5]. The supports of all itemsets in each equivalence class are the same. The equivalence class containing A is denoted as [A].

Theorem 1 (Presentation of itemsets [5]). For every itemset A such that ??A?CS, we have:  X ? [A] ? ? G0 ? G(A), ? X? ? N(A): X = G0 + X?. 1  The above presentation of itemsets is not unique because each itemset can have various generators. Hence, when we mention that R? is eliminable in S, we have to assign R? to a particular generator of S.

Proposition 1 (Support-preserved role of eliminable itemset). Adding an eliminable set R? of S to R (R?[S]) will not change its closure, thus will not change its support.

Proof: h(R) = h(R?R?) = h(S) ? ?(R) = ?(R?R?) = ?(S) ? s(R?R?) = s(R).



III. STRUCTURE OF ASSOCIATION RULE SET GENERATED FROM MIN-MIN BASIC RULES  In this section, we will partition the association rule set into disjoint equivalence rule classes using an equivalence relation based on the closures of left-hand side and also of both sides of association rules. Next, we construct an order relation to indicate how to find min-min basic rules by our algorithm MG_BARS. Then we suggest the way to derive confidence-preserved consequence rules which belong to the same equivalence rule class as basic rules. Finally, the efficient algorithm MG_CARS to generate non-repeated consequence rules is proposed.

A. Partitioning of association rule set based on equivalence relation   1 The symbol + is denoted as the union of two disjoint sets.

For a brief notation, let (L, S) denote two closed frequent itemsets: L, S ? CS, ? L?S. In [6] an equivalence relation was used for partitioning the association rule set into equivalence rule classes. Each of them, based on this relation, contains all rules which have the same support and confidence. Using the equivalence relation in definition 1, the following theorem 2 will show a smoother partition of the rule set AR_S.

Definition 1. (Equivalence relation on association rule set).

Let ~r be a binary relation in AR_S determined as follows: ? L?, S?, Ls, Ss ? A, ? L??S?, ? Ls?Ss, r:L? S?\L?, s:Ls Ss\Ls:  s ~r r  ? (Ls ? [L?] and Ss ? [S?]).

From the above definition, we have theorem 2. Although  this theorem is easy to prove, it plays an important role in partitioning the association rule set.

Theorem 2 (Partition of the association rule set). Relation ~r is an equivalence relation. It partitions AR_S into disjoint equivalence rule classes AR_S(L, S). For each class, we usually consider the representative rule r0:GL?S\GL, GL?G(L). The rules in AR_S(L, S) have the same support s(r0) and confidence c(r0) (the reverse is not always true).

AR_S = )S,L(  )S,L(S_AR .

Proof: Consider the rule r:L? R?, L? ? [L], L?+R? ? [S].

Since L? and GL belong to [L] so s(GL) = s(L?); s(r0) = |?(GL)??(S\GL))| = |?(S)| = |?(L??R?)| = |?(L?)??(R?))| = s(r), hence, c(r0) = c(r).

To investigate the structure of AR_S thoroughly, we need to investigate only the structure of each equivalence rule class AR_S(L, S) independently. Moreover, from this partition, the parallel algorithms are easily generated to quickly find association rules. This is the significance of the equivalence relations and is a typical instance of the divide- and-conquer method widely used in computer science.

Since the size of the paper is limited, we prove only some results related to equivalence rule class AR_S(L, S) with L ? S. With L = S, the similar results are easily proved.

B. Basic rules as min-min form In this section, an order relation in each equivalence rule  class is obtained to propose basic rule set as min-min basis.

Then, the algorithm for finding it is also indicated.

Definition 2. Consider a partial order relation ? on AR_S(L, S), defined by: ?rj: Lj?Rj ? AR_S(L, S), Sj=Lj+Rj, j=1,2:  r1 ? r2 ? (L1 ? L2 and R1 ? R2).

Basic rule set B(L, S) of AR_S(L, S) contains all minimal rules based on  the relation ?:  B(L, S) = {r0: Li?Ri* | Li ? G(L), Ri* ? Rmin(Li, S)}, where Rmin(Li, S) is the set containing all minimal elements of {Sk\Li | Sk\Li??, Sk ? G(S)} according to the normal    Trans Items 1 ACTW 2 CDW 3 ACTW 4 ACDW 5 ACDTW 6 CDT  (a) Database 1  (b) Frequent closed itemset lattice  order relation ??? in the set theory and c(r0) < 1, ? r0 ? B(L, S).

Similarly, ? L ? CS: L ? G(L),  B(L, L) = {r0: L0?{a}, L0 ? G(L), ? a ? L\L0} and c(r0) = 1, ? r0 ? B(L, L).

Both sides of all basic rules which Zaki considered the most general rules are minimal. In [6], he introduced the algorithm GenerateRules to find these rules. However, his algorithm used many candidates (for the most general rules with the confidence equal to 1) and operations for finding the closure of itemsets to check unnecessary conditions.

Based on definition 2, our below algorithm MG_BARS is better. The results of experiments will prove that.

B(L, S)     MG_BARS  (L, S) (1) B(L, S) := ?;   c := |?(S)| / |?(L)|; (2) for each (Li ? G(L)) do (3)         MS := Rmin(Li, S); (4)         for each (Rk ? MS) do (5)                B(L, S) := B(L, S) ? {<Li?Rk, s(S), c>} ; (6)  return   B(L, S); where G(L) is found by the algorithm MinimalGenerators [6].

Figure 1. Database 1 and Frequent closed itemset lattice  Example 1. Consider database 1 and the corresponding frequent closed itemset lattice in figure 1 (minimum support s0 = 0), where underlined itemsets are generators of corresponding closed itemsets. Consider the pair of closed itemsets (L, S), where S=ACDTW2 having G(S)={ADT, DTW} and L=ACDW having G(L)={AD}. We have a basic rule AD?T since Minimal{ADT\AD=T, DTW\AD=TW} = {T}.

From basic rules in B(L, S), based on eliminable itemsets related to them, we will propose efficient methods for non-repeatedly deriving all confidence-preserved consequence rules of C(L, S) := AR_S(L, S) \ B(L, S).

2 {a1, a2, ?, an} is abbreviated that a1a2?an  C. Complete derivation of confidence-preserved consequence rules from basic ones by adding eliminable itemsets.

From proposition 1, we see that adding appropriate  eliminable itemset to both sides of a rule will not change the support of that rule. Hence, its confidence is preserved.

This is the key point of the methods to generate confidence- preserved consequence rules.

Definition 3. Consider two set functions that generate consequence rules F+L, F+R: AR_S(L, S)?2AR_S(L, S), ?r0:L0?R0 ? AR_S(L, S),  F+L(r0) = {r+L:L0+L??R0 | L??N*(L), L? ? L\(L0+R0)}.

F+R(r0) = {r+R:L0?R0+R | R?N*(S), R ? S\(L0+R0)}.

Proposition 2. Obviously, F+L(r0) = {r+L:L0+L??R0 | ? ? L?? L\(L0+R0)} and F+R(r0) = {r+R:L0?R0+R | ? ? R? S\(L0+R0)}. The above definition is correct.

Proof: Since r0:L0?R0 ? AR_S(L, S), so h(L0)=L ? h(L0+R0)=S. (a) If ??L??L\(L0+R0) then L0 ? L0+L? ? L, L0+R0 ? L0+L?+R0 ? L+R0 ?S. Hence, L = h(L0+L?) and h(L0+L?+R) = S, i.e., r+L ? AR_S(L, S). (b) If ??R?S\(L0+R0) then L0+R0 ? L0+R0+R ? S, h(L0+R0+R)=S, i.e., r+R ? AR_S(L, S).

Consider equivalence rule class AR_S(L, S). With r?AR_S(L, S), the rule sets {r}, F+L(r) and F+R(r) are disjoint because either the left-hand side or right-hand side of any rules in them is different from the other rules. From each basic rule r0 ?AR_S(L, S), the  rules in each set F+L(r0), F+R(r0) are non-repeatedly generated and have the same confidence as r0 since they all belong to AR_S(L, S).

Moreover, we have: F+L(B(L, S)) = {r+L:Li+L? ? R*ik | Li ? G(L),  R*ik ? Rmin(Li, S), ? ? L? ? L\(Li?R*ik)},  F+R[B(L,S)+F+L(B(L,S))]={r+R:Li+L???R*ik+R?|Li?G(L), L?? ? L\(Li?R*ik), R*ik ? Rmin(Li, S), ? ? R? ? S\(Li+L??+R*ik)}.

Proposition 3. (Disjoint splitting of each equivalence rule class). AR_S(L, S) = B(L,S) + F+L(B(L,S)) +  F+R[B(L,S) + F+L(B(L,S))].

Proof: Since F+L(B(L, S)) + F+R[B(L,S)+F+L(B(L,S))] ? C(L, S), so we need to prove only AR_S(L, S) ? B(L,S) + F+L(B(L,S)) + F+R[B(L,S)+F+L(B(L,S))]. For every r:L??R ? AR_S(L, S), since h(L?)=L, L??R=? and h(S?)=S, where S?=L?+R, so there exists Li?G(L?), Sk?G(S?): Li?Sk and Sk\Li?R. Indeed, if there exists a?(Sk\Li)\R then a?L? and {a}+Li is subset of Sk, so {a}+Li is also generator and {a}+Li?G(L?): it contradicts with Li?G(L?). With S??:=S?\Sk, we have S?=Sk+S??= Li+ (Sk\Li)+(S?\(Li?Sk))=Li+(Sk\Li)+(L?\(Li?Sk))+(R\(Li?Sk)= Li+(L?\(Li?Sk)) + (Sk\Li)+ +(R\(Li?Sk)) = Li+(L?\Li) +    (Sk\Li)+(R\Sk), since L??R=? and Sk\Li?R so (L?\(Li?Sk)) = L?\(Li+(Sk\Li)) = L?\Li and R\(Li?Sk)=(R\Sk)\Li=R\Sk).

Thus, L?=Li+(L?\Li) and R=(Sk\Li)+(R\Sk). Let ik be the minimum index of Sk such that R*ik=Sik\Li is minimal.

Then L?=Li+L??, R=R*ik+R?, where L??=(L?\Li) and R?= R\Sik. Otherwise, with KU,L? :=  )'L(GL i  i  L ?  , we have L?? =  (L?\Li)?KU,L? + L?\(Li?KU,L?) = L?i+L~?L?\(Li?R*ik)? L\(Li?R*ik), where L?i=KU,L?\Li, L~=L?\KU,L?= L?\(KU,L??Rik). Similarly, with SU,L?+R=  )R'L(GS k  k  S +?  , we have  R? = R\Sik = (R\Sik)?SU,L?+R +R\(Sik?SU,L?+R) = SU,L?+R,ik+ S~  ?R\(L??Sik)?S\(L?+R*ik), where SU,L?+R,ik=(R?SU,L?+R)\Sik, S~=R\SU,L?+R. Then r:Li+L?i+L~?R*ik+SU,L?+R,ik+S~. Let us call r0:Li?R*ik ? B(L,S), r+L:Li+L?i+L~?R*ik, and r+R:Li+L?i+L~?R*ik+ SU,L?+R,ik+S~. We have three following cases: (a) if SU,L?+R,ik+S~ = ?, L?i+L~ = ?: then r?r0:Li?R*ik?B(L,S), (b) if SU,L?+R,ik+S~ = ?, L?i+L~ ? ?: then r?r+L? F+L(B(L,S)), (c) if SU,L?+R,ik+S~ ? ?: then r?r+R? F+R[B(L,S)+F+L(B(L,S))].

Based on proposition 3, each equivalence rule class AR_S(L,S) is split into two disjoint rule sets of basis and consequent. From basic rules, the consequence rules are completely generated and are totally different from the rules of all other equivalence rule classes. However, in each equivalence class the consequence rules generated by the functions F+L, F+R can be repeated. For example, with r01 and r02 different but having the same right-hand sides, two rule sets F+L(r01) and F+L(r02) can have some identical rules, i.e., F+L(r01)?F+L(r02) ? ?.

Example 2. Using the figure 1, we consider S=ADTWC having G(S)={ADT, TDW} with L?=ACTW having G(L?)={AT, TW}. Since W ? L?\(AT+D)=CW so the basic rule r1:AT?D derives the consequence rule r1+L:ATW?D.

The basic rule r2:TW?D also derives r1+L. Then, S is considered with L??=CD where G(L??)={D}. The consequence rule r3+R:D?ATW derived from the basic rule r3:D?AT (since W ? S\(D+AT)=CW) is the same of one consequence rule of the basic rule r4:D?TW.

D. Complete derivation of the non-repeated, confidence preserved consequence rules from basic rules This section proposes different forms of the functions  F+L, F+R. These forms will non-repeatedly generate all consequence rules in each equivalence rule class. The corresponding algorithms will be shown.

1) The non-repeated form F?+L of F+L  For every L ? CS, Li ? G(L), R?A, R?Li = ?, denote KU =  )L(GL i  i  L ?  , K~R = L\(KU?R), KU,Li = KU\Li, FS_(Li, R) =  {Li+L~ | L~?K~R}, we define:  FS1(Li, S) ? {Li+L?i+L~ | R*?Rmin(Li, S), Li+L~?FS_(Li, R*), L?i?KU,Li, i=1 or (i>1: not(Lk?(Li+L?i)\R*), ?1?k<i)}  and for every L*?L\Li, FS2(Li, L*) ? {(Li+L~+L?i)\L* | Li+L~?FS_(Li, L*),  |L?i+L~|>1, |L*| 1, L?i?KU,Li, i=1 or (i>1: not(Lk?(Li+L?i)\L*), ?1?k<i)}.

Definition 4. Consider r1:Li?R ? B(L, S) and r2:Li?{a} ? B(L, L). We define  F?+L(r1) ? {r1+L:L??R | L? ? FS1(Li,  S)\{Li}}, F?+L(L, S) ? ( )  )S,L(Br  ' L   rF ?  +  and     F?+L(r2) ? {r2+L:L??{a} | L? ? FS2(Li, {a})}, F?+L(L, L) ? ( )  )L,L(Br  ' L   rF ?  + .

Proposition 4. Replace F?+L(B(L, S)) with F?+L(L, S), we have: (a) The consequence rules in F?+L(L, S) are non- repeatedly generated, (b) F?+L(L, S) = F+L(B(L, S)).

Proof: (a) Assume that ?i1>i2, i1>1: Li1+L?i1+L~i1 ? Li2+L?i2+L~i2, Lik ?G(L), L~ik?K~, L?ik?KU,Lik, k=1,2. Since Li2?L~i1=?, so Li2?Li1+L?i1.. It contradicts the way selected L?i1.

(b) ???: For every r:Li?R?B(L, S), consider r+L: Li+L?i+L~?R ? F?+L(r). Since ??L?:=(L?i+L~) ? KU,Li+K~R ? L\(Li?R) so r+L?F+L(r)?F+L(B(L, S)). ???: ? r??F+L(B(L, S)), from theorem 1, let i be the minimum index such that r?:L??? R*, where L??=Li+Oi, Li?G(L??), and Oi?L\(Li?R*). Let us call L?i=Oi?KU?KU,Li, L~R*=Oi\KU?K~R*. We have L??=Li+L?i+L~R*, and hence, r?:Li+L?i+L~R*?R*. Assume that there exists i>1 and k<i: Lk?(Li+L?i)\R*, Lk?G(L), hence Lk?G(L??). Then L??=Lk+Ok, where Ok=L?k+L~R*, L?k=(Li+L?i)\Lk? L\(Lk?R*) and L~R* ? L\(KU?R*) ? L\(Lk?R*) so Ok?L\(Lk?R*). It contradicts the way selected the i index!

Therefore, not(Lk?(Li+L?i)\R*),?k<i, i.e., r??F?+L(L, S).

2) The non-repeated form F?+R of F+R For every L? ? Left(L, S) := {L? | ?r:L??R? ? [B(L,S)+  F?+L(L,S)]}, we denote Rmin(L?, S) = {R*ik:=Sk\L? | Sk?G(S), Sk\Li is minimal for each Li?G(L?)}, SU,L? :=  )',(  *  min * SLRR  i i  R ?  , SU,L?,i := SU,L?\R*i, S~L?:=S\(SU,L?+L?) and  Right(L?, S) := {R*i+R?i+R~ | R*i?Rmin(L?, S), R?i?SU,L?,i, R~?S~L?, i=1 or (i>1: not (R*k?R*i+R?i), ?1?k<i), |R?i+R~|>1}.

Definition 5.

F?+R(L, S)  ?  ? )S,L(Left'L {r+R:L??R?? | R?? ? Right(L?, S)}  and F?+R(L, L) ? {r+R:L??L* | Li?G(L), L*?L\Li, |L*|>1, L? ? FS2(Li, L*)}.

Similarly to proposition 4, we have proposition 5.

Proposition 5.  (a) The consequence rules in F?+R(L, S) are non-repeatedly generated, (b) F?+R(L, S) = F+R[B(L,S)+F+L(B(L,S))].

Proof: (a) All rules in F?+R(L, S) have either the left-hand sides in Left(L, S) or the right-hand sides in Right(L?, S) which are different. Hence, all consequences rules generated in F?+R(L, S) are non-repeatedly generated.

(b) Obviously by the definitions of F?+R(L, S) and F+R[B(L,S)+F+L(B(L,S))].

3) Complete derivation of non-repeated and confidence-preversed consequence rules Theorem 3 (Disjoint splitting of non-repeated rules in each equivalence class).

AR_S(L, S) = B(L, S) + F?+L(L, S) + F?+R(L, S).

Similarly, AR_S(L, L) = B(L, L) + F?+L(L, L) + F?+R(L, L).

Proof: Consequence of propositions 3, 4 and 5.

From the above propositions, the algorithm MG_CARS is suggested for deriving all non-repeated consequence rules C(L, S) in every equivalence rule class AR_S(L, S).

C(L, S)    MG_CARS  (L, S) (1) F?+L(L, S) := LeftAdding (L, S);    F?+R(L, S) := ?; (2) for each (L??Left(L, S)) do (3)           F?+R(L, S) := F?+R(L, S) + RightAdding(L?, S); (4) C(L, S) := F?+L(L, S) + F?+R(L, S); (5) return C(L, S);  The algorithm RightAdding for finding consequence rule subset F?+R(L?, S) is indicated as follows (the algorithm LeftAdding can be derived in the same way).

F?+R(L?, S)     RightAdding (L?, S) (1) F?+R(L?, S):= ?;  MS := Rmin(L?, S); (2) SU,L? :=  MSR i  i  R ?  ;    S~L? := S\(KU,L?+L?);  (3) for each (R~ ? S~L?) do (4)       for each (Ri ? MS) do (5)            SU,L?,i := SU,L?\Ri; (6)            for each (R?i ? SU,L?,i) do (7)                if (R?i?? or R~??) then (8)                     Repeated := false; (9)                     if (i>1) then for each (Rk ? MS | k<i) do (10)                                      if (Rk ? Ri+R?i) then (11)                                           Repeated := true; (12)                                           break; // for each Rk (13)            if (not(Repeated)) then (14) F?+R(L?, S) := F?+R(L?, S) + {r+R:L??Ri+R?i+R~}; (15) return F?+R(L?, S);

IV. EXPERIMENTAL RESULTS  Four benchmark databases in [8] are used during these experiments. Table I shows their characteristics. The source code of M. J. Zaki [9] is also used to find the frequent closed itemset lattice (Charm-L [7]) and generators.

TABLE I. DATABASE CHARACTERISTICS  Database (DB) # Transaction # Items Average size P 49046 7117 74 M 8124 119 23 Co 67557 129 43 Ch 3196 75 37  Table II shows the experimental results of our approach for finding association rule set based on the basic rules as min-min form. It shows the minimum support and the minimum confidence (MS=MC), the cardinality of the association rule set (#Tra) and the cardinality of basic rule set (#BAR). Column RTc shows the percent ratio of the time for finding the consequence rules to the one for finding all association rules. The ratio of the basic rules to all association rules and the number of redundant candidates generated in the GenerateRules algorithm [6] are in turn showed in columns RBT and #Rz. Table II also shows the run time for mining the basic rules by our algorithm MG_BARS (To) and the ratio (RT) of the one by the GenerateRules (Tz) to To.

TABLE II. THE EXPERIMENTAL RESULTS WITH BENCHMARK DATABASES  DB MS = MC #Tra #BAR RBT RTc #Rz To (s) RT  Ch 80 552564 316493 0.6 88.9 480 1.07 1.5 Ch 70 8171198 3396360 0.4 91.3 6498 11.34 1.6 Co 97 8092 4621 0.6 88.0 21 0.02 1.5 Co 90 3640704 324974 0.1 96.9 10000 1.00 2.2 M 40 7020 1419 0.2 93.1 26 0.01 1.5 M 20 19191656 59297 0.0 99.9 16166 0.30 8.2 P 95 1170 786 0.7 81.4 0 0.01 2.0 P 85 1408950 727532 0.5 87.4 1368 2.90 1.7  The experimental results show that: first, the algorithm MG_BARS quickly and directly finds basic rules; second, the algorithm MG_CARS completely derives all confidence-preserved and non-repeated consequence rules from the basic rules by adding appropriate eliminable itemsets to two sides of them. The total number of rules generated in our approach is the same as the one in the traditional algorithms [6]. Figures 2 and 3 show the relation between the cardinality of basic rule set and the one of association rule set and also the effect of minimum confidence on the number of basic rules.

Figure 2. All rules vs basic rules: Chess and Connect.

Figure 3. All rules vs basic rules: Mushroom and Pumsb.

Figure 4, 5 and 6 compare the run times for finding the basic rules by the MG_BARS and GenerateRules algorithms on Co (similar to Ch), M and P with the different minimum confidences. It shows that the run time of our algorithm MG_BARS is shorter in almost cases.

Figure 4.  The run times of MG_BARS vs. GenerateRules: Connect.

Figure 5. The run times of MG_BARS vs. GenerateRules: Mushroom.

Figure 6. The run times of MG_BARS vs. GenerateRules: Pumsb.



V. CONCLUSION In this paper, based on the eliminable itemset concept  [5] which plays an important role in preserving support of itemsets and confidence of rules in each equivalence class, an efficient approach for extracting all association rules based on min-min basis is proposed. This approach with four phases is built based on the theoretical results and tested on benchmark databases. The first phase is to partition the association rule set into the disjoint equivalence rule classes. The second one is to disjointly split each of them into two rules sets of min-min basis and consequent. Using the above structures, in the third phase the algorithm MG_BARS which significantly reduces the time for mining basic rules is obtained. And in the last phase, the algorithm MG_CARS that non-repeatedly and completely derive all consequence rules (together with their support and confidence) from the basic rules is proposed.

