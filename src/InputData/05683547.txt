Exploring Locality of Reference in P2P VoD Systems

Abstract?A critical problem to P2P VoD systems is to provide efficient user interactivity support. In this paper, we study intra- and inter-video operations separately and aim to reduce the latency of these VoD operations by exploiting the locality of reference in user access patterns. With a relaxed definition of data chunk holder, intra-video locality can facilitate a high likelihood of a peer seeking within a video, to find a holder of the requested data among its neighbors. Tapping on this property, an aggressive cached publish scheme is designed to build shortcut over the DHT network so as to reduce the lookup delay. Inter-video locality is exploited via learning association rules from the collective viewing history. A fast association rule learning algorithm is proposed to infer the relations between videos in a distributed manner based on partial knowledge. Both search and content prefetch are incorporated to achieve low inter-video jump delay with minimal overhead. Our simulations demonstrate that the proposed schemes can reduce the lookup delay for seeking within a video and provide an efficient prediction-based prefetch scheme for inter-video access.



I. INTRODUCTION  Video streaming services have been very popular and the growth of video traffic over Internet is still accelerating [1].

Video-on-Demand (VoD) is one of such kind of services where videos are streamed to end users with provisioning for user interactivity. Due to its large amount of data and real time re- quirement, providing VoD service with client/server technique is extremely costly. For example, In March 2008, YouTube?s bandwidth costs were estimated at approximately US$1 mil- lion a day [2]. Recently, Peer-to-Peer (P2P) mechansim has been recognized as a promising cost effective technique for internet-scale VoD systems.

As opposed to P2P live streaming systems, where only sequential access is allowed, P2P VoD systems support user interactivity. We have identified two kinds of user interactivity: seeking within a video and jumping to a different video.

Seek allows users to change their viewing positions when the current part is not of interest. Frequent seek behavior has been observed by PPLive [3]. Jump occurs when users have finished or gave up the current video. Usually, for long movies, jump operation is not as frequent as seek operation, but it would also be very common when videos are short clips or TV dramas.

User interactivity support imposes a stringent requirement on P2P VoD systems in terms of delay. Many solutions have been proposed to improve the streaming continuity after user intervention. Generally such solutions can be classified into two categories. The first is to construct an additional structured  overlay to help peers to locate video content over the P2P network efficiently [4], [5]. Although structured overlay seems to be appealing, the performance may degrade significantly in dynamic environment. For example, a study of the Bittorrent systems [6] shows that a DHT lookup may experience a delay of over 1 minute. VMesh [5] builds previous/current/next segment lists on top of DHT to accelerate the lookup, which can be very helpful when the segment size is large and a seek usually only skips less than 2 segments. However, large segment size will reduce the data sharing among peers and is not flexible for data scheduling. The second category of solutions is to enable non-sequential prefetch [7], [8].

Theoretically, prefetching schemes can reduce seek delay to zero if a prefetch hits. Nevertheless, the risk of prefetching is relatively high due to the large volume of video data. Lastly, the solutions discussed above are only designed to reduce seek delay, jump delay is not considered by existing studies.

In this paper, we propose two schemes to reduce seek and jump delay separately, by exploring the locality of reference of user access patterns. We first introduce the concept of partial holder. A partial holder is different from a complete holder as it only stores a part of a data chunk. The intra-video locality of reference is that, when a peer seeks within a video, there is a high probability that a holder of the requested data, either complete or partial, exists among the peers? neighbors. We then design a cached publish scheme to build shortcut via the holders in the neighbors so that the seek delay can be reduced.

Furthermore, in order to reduce the jump delay, we utilize association rules learning to discover the locality of reference in inter-video access patterns. Association rules can help to predict the videos that are likely to be watched next, so that we can search or download in advance. Although association rules learning has been used by VOVO [7], our method is different in the following aspects: 1) we use association rule learning for inter-video prediction, while in VOVO, it is for intra-video prediction. 2) we propose a fast association rule learning, which can discover relations with partial knowledge 3) our method combines both search and data prefetch, which strikes a balance on the trade-off between cost and benefit.

This paper first describes the basic setup of our schemes in Section II. Section III and IV present the locality of reference for both intra and inter-video access and the proposed algo- rithms to reduce seek and jump delay. Section V demonstrates the performance results. We conclude our paper in Section VI.

This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE Globecom 2010 proceedings.



II. BASIC SETUP OF THE P2P VOD SYSTEM  We implement a P2P VoD system in NS2 [9] for per- formance evaluation. DHT is used for content location in the system. However, applying the proposed methods to other distributed content location P2P VoD systems is quite straightforward. The Kademlia [10] protocol is implemented to construct a DHT network. The original Kademlia design is slightly modified to provide lookup service in P2P VoD system. The protocol mainly consists of three operations: FIND NODE to locate the closest nodes to a key, PUBLISH to insert an entry to the DHT network and FIND HOLDERS to find the peers that stores a data chunk. An entry indicates which peers hold a specific chunk and is stored on ? peers whose IDs are the closest to the hash of that chunk.

Videos are broken into blocks for transmission. However, DHT does not provide block level lookup service since meta data at this granularity will incur a high overhead traffic.

Instead, a set of continuous blocks are grouped into a chunk.

In our simulation, a block is of size 16 Kbytes and a chunk consists of 128 pieces as per the setting used in PPLive [3].

If a peer stores a chunk, it invokes PUBLISH periodically to insert an entry to the DHT network, so that other peers can locate the chunk by FIND HOLDERS.



III. SUPPORTING SEEKS WITHIN A VIDEO A. Exploring locality of reference  As aforementioned, when a peer starts to download a chunk, it will retrieve the blocks in the chunk. During downloading, the blocks cannot be shared with other peers until the whole chunk is finished. Given a peer with download bandwidth of 1Mbps, it takes 0.125 seconds to download a block and 16 seconds to finish an entire chunk, which means that, after the first block in a chunk is downloaded, the peer has to wait at least for 16 ? 0.125 = 15.875 seconds to notify the DHT network. This is obviously a waste of resource. More importantly, requiring a full copy of a chunk to share also weakens the relations among peers, that is, the locality of reference which we will discuss in the rest part of this section.

For this reason, we first give a relaxed definition of chunk holder as follows: Definition 1. If peer r stores at least one block of a chunk i, then peer r is called a holder of chunk i. If the entire chunk is available on r?s local storage, then r is a complete holder; otherwise r is a partial holder.

With Definition 1, we state the intra-video locality of reference as follows: Theorem 1. When a peer is downloading data from a set of neighbor peers, then among these neighbors, it is likely that there are holders of the data chunks which the peer will request in the near future when watching the same video. Given a space consists of all peers, this phenomenon can be considered as spatial locality.

The locality of reference presented in Theorem 1 can be proven by theoretical analysis. To understand the locality of reference in P2P VoD, we first analyze user behavior when viewing a video. In a P2P VoD system with seek operation  support, a user may seek forward or backward during viewing.

For simplification, we only consider seek forward here. A peer watches a video and seeks forward when the content is boring.

The viewing continues till the end of the video. The lengths of the watched and skipped parts are denoted by seek duration and seek distance respectively. We let bi, i = 0, 1, ? ? ? , Nb ? 1 denote the blocks in the video, where Nb is the total number of blocks and each block is of equal length. A chunk consists of s blocks, thus there are Nc = Nb/s chunks in a video, denoted by ci, i = 0, 1, ? ? ? , Nc ? 1. Here we study the watch probability (WP) of each block. The watch probability is the probability that a block is visited by a peer during a viewing process. Then we have the following proposition: Proposition 1. If the seek duration is exponentially distributed and the seek distance follows a Pareto distribution, there exists an integer H ? Nb so that for all i > H , the watch probability of bi during a viewing process is independent of i.

The proof of Proposition 1 is omitted here due to page limit.

Proposition 1 shows that, if we ignore the first H blocks, then each block is accessed by users with equal probability, denoted by pw. The first few blocks usually have higher value of pw as users often start from the beginning. This also conforms to the results observed by PPLive [3]. Obviously, a peer has to download a block before watching it. Therefore, if a peer has watched bi, it also stores bi. Here we do not consider data replacement due to limited local cache and neither do we consider a system with proactive caching, in which a peer may fetch some data only for replication instead of for viewing.

In P2P VoD system, a peer usually connects to a set of neighbor peers to exchange data availability information and retrieve data. We further identify a subset of neighbor peers as beneficial neighbors as follows: Definition 2. For a peer i and its neighbor peer j, if peer i is watching a video v and peer j has at least one block of data of v, then peer j is peer i?s beneficial neighbor.

Clearly, a peer watching a video has at least one beneficial neighbor, from which it downloaded the previously watched data. The following lemma derived from Proposition 1 de- scribes the probability of finding holders of chunks and blocks among beneficial neighbors.

Lemma 1. If a peer has nb beneficial neighbors, the prob- ability that there is at least one holder of chunk ci, either complete or partial, among its beneficial neighbors is:  ph = 1 ? (1 ? pw)s?nb (1) The probability that there is at least one holder of block bi  among its beneficial neighbors is: p?h = 1 ? (1 ? pw)nb (2)  Theoretically, p?h < ? can be achieved for any value of ? by using different values of nb. If ? is small enough, the probability of finding the requested block among its neighbors is nearly one when a peer seeks within a video. This seems to be good news as once the block is located on the neighbors, it can be downloaded without invoking additional search schemes. However, only ensuring p?h ? 1 is not practical for   This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE Globecom 2010 proceedings.

P2P VoD systems: firstly, for a cold video, that is, a video with low pw, nb would be very large to achieve p?h ? 1, which increases the maintenance overhead linearly; secondly, with only one available source for a block is not flexible for transmission algorithm design. A good transmission algorithm may need several source candidates to choose so as to improve the aggregate throughput.

Nevertheless, with the definition of partial holder, we can conclude ph < ? is a common case in P2P VoD systems for small ?. Given a chunk size s = 128, we can see that even for a video with pw = 0.05 and nb = 1, phi is nearly 1. This proves the locality of reference stated in Theorem 1. In the next section, we will show how locality of reference helps to build shortcut and reduce the DHT search delay.

B. Cached and Aggressive Publish The locality of reference is highly dependent on Definition  1. Unfortunately, existing DHT networks do not support partial holders. In order to take advantage of the locality of reference, we propose an aggressive publish scheme for partial holder indexing. Each holder, either partial or complete, will insert an entry to the DHT network. In other words, when a peer starts to request a chunk, a PUBLISH message will be sent once a block in the chunk is finished. A peer that wants to download a block can get a set of holders, including both complete and partial holders, through the DHT network. It first tries to request data blocks from complete holders. If it fails, a gossip protocol is employed to locate blocks on partial holders and then the requested data is downloaded. By using aggressive publish, any downloaded blocks can be located and shared with other peers. The implementation of aggressive publish is elaborated as follows:  1) When a peer receives a block of a new chunk, it sends a PUBLISH message with a flag partial holder set to true.

The peer is considered as a partial holder of the chunk.

2) When a peer has completed a chunk, it sends a PUBLISH message without the partial holder flag. The peer is now a complete holder of the chunk.

3) When a peer wants to download a block, it first gets a bunch of chunk holders via DHT. If there are complete holders available, a request is sent to one of them; Meanwhile, it connects to some partial holders and asks for buffer map of the requested chunk; If retrieving data from complete holders has failed, send request to a partial holder who currently has the block.

Aggressive publish not only improves the data availability in the DHT network, but also increases the spatial locality of reference as discussed in Section III-A. We therefore provide a cached publish scheme to reduce the lookup delay after seeking. Recall that a holder of a chunk periodically publishes its ownership information to ? nodes which are responsible for that. Thus if peer a holds a chunk m, a will know the ? peers whose IDs are the closest to the hash of chunk m. When a lookup request for chunk m arrives at a, the request can be forwarded to the destination directly according to the published history instead of through the routing table.

In this case, the lookup hopcount can be reduced by using a shortcut. To this end, we modify the routing algorithm to let peers cache the recent published history. When a peer receives a FIND HOLDER message, it first checks the cached published history. If a shortcut exists, the message is then directly forwarded to the destination. Otherwise the normal routing algorithm will be invoked.

Fig. 1. DHT routing v.s. Shortcut routing  Fig. 1 illustrates the DHT routing through routing table and shortcut routing. In Fig. 1(a), a lookup is resolved in three hops. The initiator contacts 3 intermediate nodes iteratively and the lookup delay is 6 times end-to-end delay. When a shortcut is discovered, as shown in Fig. 1(b), the number of intermediate nodes is 2 and lookup delay is reduced to 3 times end-to-end delay. In addition, note that the first hop over the shortcut is between the initiator and its neighbor and this path has already been connected for data transmission, it is less likely to fail than contacting a normal peer in the routing table.

Lastly, according to Theorem 1, the probability of finding a shortcut is very high. Hence cached publish can reduce the lookup delay to a constant and improve the reliability in most cases.

Apparently, aggressive publish may incur additional delay as peers have to ask for buffer map from partial holders.

This impression, however, is false. Partial holders are only tried when downloading from complete holders have failed. In traditional design, where aggressive publish is not applied, the user will experience a service disruption. Aggressive publish actually increases the chance that a request would be fulfilled.

In addition, downloading data from partial holders is usually not slower than from complete holders. The requests for buffer map from partial holders are sent at the same time when trying the complete holders, thus the interaction delay is eliminated.



IV. SUPPORTING JUMPS AMONG VIDEOS In this section, we discover the locality of reference in  inter-video access patterns by association rule learning. A combination of search and content prefetch is proposed to reduce jump delay with acceptable cost.

A. Locality of reference in inter-video access patterns  In data mining, association rule learning is a popular technique for discovering relations between sets of items in large databases [1]. The definition of association rule learning involves two sets: item set I = {i1, i2, ? ? ? , in} and transaction set T = {t1, t2, ? ? ? , tm}, where each transaction contains a subset of items in I . A rule is defined as an implication of the form X ? Y |c, where X,Y ? I and 0 ? c ? 1 is the confidence factor denoting the strength of the implication.

An additional support constraint is introduced to specify the   This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE Globecom 2010 proceedings.

statistical significance of a rule. There are two support defini- tions: the absolute support denotes the number of transactions in T that support a rule and relative support is the value of absolute support normalized by total number of transactions in T . Usually the latter is used as it represents the statistical significance of a rule over the whole database.

Here we consider the jump behaviors in VoD. When a peer jumps to a different video, the locality of reference described in Theorem 1 is not applicable as no beneficial neighbors connected. If we are able to predict ?the next video? in advance, then the holder information and even the content data can be prefetched to reduce the waiting time before watching a video. Although the videos watched by different users vary a lot, it is obvious that the viewing sequence of a user is not a pure random process but user interest dependent.

For example, a user who is watching ?Transformers? may probably watch ?Transformers: The Revenge of the Fallen? or the ?Terminator? series. Such relations between videos can be represented as association rules. If 50% of users who have watched video v1 will also watch v2 after v1, then the relation is denoted by v1 ? v2|0.5, where 0.5 is the jump confidence.

The relations between videos indicate the spatial locality of reference in inter-video access patterns. Consider a space consisting of all videos and the distance between two videos vi and vj is defined by the reverse of the confidence of rule vi ? vj , if a video is played by a user, then it is likely that the user will play the nearby videos in the near future.

This locality of reference implies that, it is possible to design efficient prefetch algorithm if the relations can be discovered.

B. Fast association rule learning  The locality of reference can be inferred by association rule learning from user viewing history. A peer?s viewing history, that is, the videos it has watched, forms a record.

For example, if a peer i has played videos v1, v2 and v3, then its record is denoted by ri = {v1, v2, v3}. Traditionally, a server is deployed to collect all records and compute the rules.

However, the collecting and learning tasks are both bandwidth and CPU intensive considering a P2P network with millions of users. Y. He et al. [7] designed a gossip protocol to gather intra-video watching history, but for inter-video records, the number of records is so large that it would incur huge amount of traffic to transmit them via gossip information exchange. In addition, it is also impossible for a peer to store all the records locally and mine rules out of such a large database.

To solve this problem, we propose a fast association rule learning algorithm according to the following facts. Firstly, we only need to predict the next video, so for a rule X ? Y , we use |Y | = 1. To further simplify the problem, we assume the inter-video jumping pattern is a Markov process, hence |X| = 1 because the next state is dependent only on current state.

Secondly, a peer watching vi is only interested in those records which also contain vi. Thus it is unnecessary to exchange all records among peers. Thirdly, the computation of relative support requires full knowledge of all peers? viewing history, which is extremely hard in large scale P2P systems. In fact, we can only care about the number of records containing vi in  lieu of the total number of records. We therefore use absolute support to decide whether a rule is worth consideration. In our algorithm, only the rules learned from a data set containing more than Tsp records are considered as valid, where Tsp is the support threshold. In other words, at least Tsp records must be collected to produce rules for a video.

As there is no centralized server, records must be stored by peers. Each peer employs a RecordCache to cache its own record and other peers? records collected recently. There- fore, for a video vi, those peers that have watched or is watching vi definitely have one record containing vi, that is, their own watch history. Moreover, probably they may store more records as they also want to discover, or have already discovered the association rules of vi. When a peer is watching video vi and wants to find the association rules, it first asks beneficial neighbors to request records. If the records from beneficial neighbors cannot satisfy the support threshold, then it will contact other holders of vi for more records, which can be learnt from the DHT network. The requested peer will scan through its RecordCache and return the records containing vi.

This record collecting process involves two important pa- rameters to reduce traffic overhead. First, a max no is carried by each record request to specify the maximum number of records to be returned. Typically max no is always set to Tsp, hence a peer may receive at most 2 ? Tsp records. Second, as the videos in a record are kept in chronological order according to watched time, the closer a video is to vi in the record, the stronger is the relation between them. Those videos that are far away from vi have little connection to vi and can be ignored. Therefore, during the record collection, only the video sequence within a learning window, which is of size learning window size, is extracted and returned.

Consider a record ri = {v0, v1, v2, v3, v4, v5, v6, v7, v8, v9}, let vi = v5 and learning window size = 4, the sub- record {v3, v4, v5, v6, v7} will be extracted. Other items are abandoned to save bandwidth.

As soon as more than Tsp records are collected, the mine association rules algorithm will work.

mine association rules distinguishes two kinds of videos: order-sensitive and order-insensitive. For most videos, like movies, the relations among them are order-insensitive.

However, for some videos like TV dramas and movie series, which are usually watched one by one sequentially, the viewing order is important. This ?order? property is predefined by the system administrator and can be retrieved from the content server when starting a video. Two sub-procedures: mine rules order sensitive and mine rules order insensitive, are designed for order-sensitive and -insensitive videos respectively. Both procedures take two arguments: vi denoting the current video and vrecords storing the collected records.

Here for a specific vi, a rule vi ? vj |confidence is simply represented by a combination of {vj , confidence}. Algorithm 1 shows the pseudo code of mine rules order insensitive.

The number of occurrences of each video in vrecords is accumulated and then normalized by the length of vrecords to compute the confidence. Only the rules with confidence   This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE Globecom 2010 proceedings.

greater than a threshold Tconf are kept and returned, sorted by confidence in descending order. mine rules order sensitive is similar to Algorithm 1 except that it only takes the videos next to vi in vrecords into account.

Algorithm 1 mine rules order insensitive( vi, vrecords ) rules is a map from a video to its confidence. For each item rule in rules, rule.video stores the video and rule.conf stores the confidence for all r in vrecords do  for all vj in r do if vj ! = v AND vj is not in rules then  conf ? number of occurrences of vj in vrecords conf ? conf/vrecords.length if conf > Tconf then  rules[vj ] = conf end if  end if end for  end for rules.sort by confidence() return rules  The relations among videos may change. Association rule learning algorithm must be adaptive to the relation dynamics and reflect up-to-date user behaviors. In fact, our algorithm is naturally self-adjusting to changes: as user interest changes, the history record will be updated and change accordingly.

Thus the rules will be adjusted to fit the current situation with time. As the old viewing history remaining in the records will slow down the self-adjustment process, a time stamp is attached to each item in a record, denoting when the video is watched. A peer periodically checks its RecordCache and removes the items that are older than a threshold Trt. By using this simple timeout scheme, viewing history is kept up-to-date and our association rule learning algorithm can adapt to new user behavior patterns quickly.

C. Content prefetch and search prefetch The association rules define the distance between two videos  over the whole video space. For example, a rule vi ? vj |conf defines the distance between vi and vj is (vi, vj) = 1conf . The closer the two videos are in the space, the more likely the users will jump from one to another in the near future. With the locality of reference, a prefetch scheme will definitely help to reduce the jump delay. However, even the users with similar interest may have a wide range of videos to choose, so it is impossible to predict which video will be the next with high probability in most cases. For this reason, prefetching content for every predicted video is not feasible, which may waste a large amount of bandwidth.

To reduce the jump delay with acceptable overhead, we combine two kinds of prefetch: content prefetch and search prefetch. Given a rule vi ? vj |conf , if conf is greater than a threshold Tcp, content prefetch is invoked to download the data of vj . The value of Tcp should be large enough such that the prediction will succeed with high probability. This happens mostly when users are watching TV dramas, movie series or other videos with strong connections. If confidence < Tcp, search prefetch is called to find the peers that store the first few  chunks of vj via DHT network. By doing so, if vj is played in the near future, then no DHT operation is needed and the peer can connect to holders to download data. Moreover, the search overhead is far less than the content traffic, thus search prefetch can be applied to several rules at the same time, which increase the prefetch hit probability.



V. PERFORMANCE EVALUATION  A set of simulations are conducted in NS2 to evaluate the performance. Kademlia routing bucket keeps 8 nodes and is refreshed every 360 seconds. In cached publish, each peer caches the destination peers of the last two PUBLISH operations. We have tried different settings and got similar results. A simple topology with average end-to-end delay of 1 second is constructed. The upload/download bandwidth of each peer is set to 512kbps. The intra-video access pattern is the same as described in Section III.

A. Seeks within a video We evaluate the performance of cached publish in both  static and dynamic environments. First, we assume there is no peer churn. All peers join the system at the beginning of the simulation and lookup delay is collected after the DHT overlay is stable. Fig. 2 shows that, when the network size grows from 1000 to 10000, the lookup delay in DHT increases from about 4.5 to 5.8 s. Since cached publish is able to find shortcut with high probability, most lookup can be solved with 3 hops. Thus the lookup delay of cached publish remains quite stable with different number of peers.

During the simulation, peers join the system with exponen- tially distributed inter-arrival time Ti = 9/? and user online time also follows a exponential distribution with mean value of To = 7200/?. Thus the average number of online peer is To/Ti = 800. We use ? to tune the churn rate: the larger ? is, the more frequent peers join and leave the system. Fig.

3 plots the fraction of failed lookups with different values of ?. Generally, the fraction of failures increases with ?.

However, cached publish can reduce the failures by about 50%.

The reason is two-fold: firstly, cached publish reduces lookup hops, which in turn reduces the probability of encountering an unreachable intermediate node; secondly, the first hop along a shortcut goes to a connected neighbor peer, which is reachable with high probability.

B. Jumps among videos A synthetic video database is built to simulate inter-video  user behaviors. The database includes two kinds of videos: TV dramas and movies. A drama is defined as vd = {e1, e2, ? ? ? , em} where ei is an episode of vd. When a peer is watching ei, it will watch ei+1 after ei with probability pjd, or choose a random video in the database with probability 1 ? pjd. Since user inter-video jump behavior is interest dependent, movies are divided into interest groups, denoted by vg = {m1,m2, ? ? ? ,mn}. A peer watching a movie mi will choose to watch another movie in the same interest group with probability pjg , or jump to a random video with probability 1?pjg . As mentioned, drama videos are considered as order-sensitive and other movies are order-insensitive. In   This full text paper was peer reviewed at the direction of IEEE Communications Society subject matter experts for publication in the IEEE Globecom 2010 proceedings.

3.5   4.5   5.5   1000 2000 3000 4000 5000 6000 7000 8000 9000 10000  Lo ok  up d  ela y  NO. of peers  DHT cached publish  Fig. 2. Lookup delay in static environment   0.02  0.04  0.06  0.08  0.1  0.12  0.14  0.16  1  2  3  4  5  6  7  8  Fr ac  tio n  of fa  ile d  loo ku  ps  ?  DHT cached publish  Fig. 3. Fraction of failed lookups during peer churn   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9   0  5  10  15  20  Pr ed  ict ion  h itr  at e  Time (hour)  Order-sensitive Order-insensitive  Fig. 4. Prediction hitrate of dramas (order-sensitive) and movies (order- insensitive)   0.2  0.4  0.6  0.8   0  10  20  30  40  50  Ra te  Time (10 minutes)  Prediction hitrate Group change  Fig. 5. Prediction hitrate with group dynamics.

our simulation, the database defines 4 dramas and 10 interest groups. Each drama consists of 10 episodes and pjd = 0.9.

Similarly, each interest group has 5 movies and pjg = 0.8.

Other settings are: Tsp = 20, Tconf = 0.2, Tcp = 0.8. Peer inter-arrival and online time are exponentially distributed. The prediction hitrate is plotted in Fig. 4 for order-sensitive and insensitive respectively. In both cases, the prediction hitrate is very close to the predefined pjd and pjg . The implication of Fig. 4 is that, although only partial information of peer watching history is collected, the rules produced by fast asso- ciation rule learning algorithm can reflect the actual relations underlying user behaviors.

To evaluate the performance of fast association rule learning algorithm in dynamic environment, we collect the ?most pop- ular? videos from youtube.com. These ?most popular? videos are generated according to user behaviors and keep changing all the time. It is reasonable to assume that a user may have the interest to watch these videos with high probability. Thus we consider the youtube ?most popular? videos as an interest group with pjd = 1. Hence the prediction hitrate should always be 1 if the group never changes. Data is collected every 10 minutes. The group change rate is defined as the number of different videos between two adjacently trawled groups normalized by the size of the latter group. Fig. 5 shows the fluctuation in prediction hitrate against the group change rate during the simulation. When only one or two videos are changed, the hitrate remains higher than 0.8. When there is a major change, for example, more than half of the videos are changed, the hitrate drops significantly but recovers very fast.



VI. CONCLUSION  In this paper, we study the locality of reference in user access patterns in P2P VoD systems and aim to provide better user interactivity support. The main contribution of this paper is: i) with a relaxed definition of chunk holder, we discover that  it is likely for a peer seeking within a video to find a holder of the requested chunk among its neighbors. An aggressive cached publish scheme is proposed by utilizing this property to reduce the lookup delay. ii) we propose a fast association rule learning algorithm to infer the locality of reference in inter- video access pattern. With the association rules, search and content prefech are incorporated to reduce inter-video jump delay with minimal overhead. Simulation results demonstrate that the proposed schemes can reduce the lookup delay for seeking within a video and provide an efficient prediction- based prefetch scheme for inter-video access.

