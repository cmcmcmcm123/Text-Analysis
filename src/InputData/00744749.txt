Incremental Update on Sequential Patterns in Large Data bases

Abstract Mining of sequential patterns in a transactional database  is time-consuming due to its complexity. Maintaining  present patterns is a non-trivial task after database update,  since appended data sequences may invalidate old  patterns and create new ones. In contrast to re-mining, the  key to improve mining performance in the proposed  incremental update algorithm is to eflectively utilize the  discovered knowledge. By counting over appended data  sequences instead of the entire updated database in most  cases, fust filtering of patterns found in last mining and  successive reductions in candidate sequences together  make ef3cient update on sequential patterns possible.

I  1. Introduction  As computerized applications facilitate automatic collection of large amount of data into databases, new challenges to extract practical knowledge from large databases arise. Data Mining and Knowledge Discovery in Databases O D  j thus has been recognized as a promising field of AI, statistics and database researches [ 11.

Mining of sequential patterns was first introduced in [2]. The purpose is to dwover sequential patterns in a database of customer transactions, consisting of records having customer id, transaction time, and transaction items.

A sequential pattern indicates a sequence of transactions  that usually occurred serially in time. For example, in a transactional database, one might purchase a PC and then purchase a printer at some later time. After a period of time, helshe could possibly buy some printing software and a scanner, If there exists a sufficient number of customers in the database who have a purchasing sequence of PC, printer, printing software and scanner, then such a sequence is a sequential pattern. Note that items in a sequential pattern need not be simple items, and that transactions need not be consecutive. As pointed out in [ 111, this problem was motivated by retailing applications, but the results can be applied to many business and scientific domains.

In general, the process for sequential pattern mining is comprised of several passes. Before mining process starts, the user specifies the minimum support, where the support is the percentage of data sequences that contam the pattern Note that the support in association rules is transaction- based, while in sequential patterns, the support is based on data sequences. The counting of support is different.

Suppose that a customer has two transactions that bought the same item. In the discovery of association rules, the customer contributes to the support count of that item by two, whereas it is counted only once for the support count in sequential pattern mining 121.

The transaction database is sorted by customer id into customer sequences, or data sequences. The mining process makes several passes over these data sequences.

Various candidate sequences, which are potential sequential patterns, are generated in individual passes. In each pass, all data sequences, or trimmed data sequences, are scanned to increment the supports of candidate sequences. Candidate sequences having minimm support become frequent sequences. They are then used for the creation of longer candidate sequences for next pass. The  0-7803-5214-9/98/$10.00 0 1998 IEEE. 24    algorithm stops when there is no candidate sequence any more. The performance of mining depends heavily on the number of candidate sequences and the number of data sequences in a pass.

The issue of maintaining sequential patterns becomes essential because database transactions may be updated over time. Due to new transactions, some existing sequential pattems would become invalid after database update since they might no longer have sufticient supports, while some new sequential patterns might appear.

However, there is not much work on incremental updating of sequential patterns. In order to ascertain sequential patterns up to date for the updated database, re-execution of mining algorithm on the updated database is required.

Nevertheless, because of appended database msactions, re-execution of mining algorithm demands more time than previous mining. Moreover, the effort of mining last time is wasted if all discovered sequential patterns in the original database were ignored.

There are many excellent algorithms that deal with the mining of association rules [I ,  4, IO, 121 and several algorithms were developed for the mining of sequential patterns [Z, 11, 131. Algorithms to discover frequent episodes in a single long sequence and its generalization can be found in [S, 91. There is no efficient algorithin designed for the maintenance of sequential patterns in large databases. As mentioned earlier, they call for the need of re-mining the whole database. Incremental updating techniques for the maintenance of association rules were proposed in [S, 7, 121. However, previous work dealing with the incremental updating of sequential patterns cannot be found. Besides, appended transactions induce more complicated problems in sequential pattem mining than in association rule mining. The problem of finding association mules concems with intra-wanwtidn patterns whereas tlm of sequential pattern mining concerns with inter-transaclion palterns [2]. Appended transactions bear no relation to original database for the fortncr problem, while for the latter problem, different transactions with same customer id in both databases must be sorted into one data sequence.

In this paper, we propose a new algorithm that can utilize information about discovered sequential patterns, and efficiently reduce canddate sequences for mining in updated database. The objective of this work is to solve the update problem of sequential patterns after a nontrivial number of new transactions have been appended to original database. Assuming that minimum support keeps the same, existing frequent sequences and their supports in original database could be utilized for the mining of updated database. Through effective reuse of previous derived knowledge in each pass, the number of candidate sequences is substantially reduced. Instead of counting all  candidate sequences for full updated database, counting reduced candidate sequences for original database and for increment database, could achieve better performance. For transactions that have same customer id in both origmal database and increment database, we extract old transactions from original database and merge into increment database. Since the size of increment database is smaller than original database in general, better performance thus could be retained.

The remaining paper is organized as follows. Section 2 describes the problems of sequential pattem mining and incremental update. In Section 3, we propose our new algorithm for the maintenance of sequential patterns.

Section 4 concludes our study,  2. Problem Formulation  2.1 Sequential pattern mining  Let database D be a set of transactions, where each Wansaction T consists of transaction-time (nd), customer-id (cid), and a set of items. The quantities of items arc not considered here. For siniplici& we assume that no Customer has more than one transaction at same transaction time.

An itemset I ,  denoted by (x,, x2,. . ., xm), is a nonempty set of items, where each item xk is represented by an integer. A sequence s, denoted by <ala *...an>>. is an ordered set of itemsets. Each U, is an ?itemset, which is called an element of the sequence, An item can occur only once in an element of a sequence, but can occur multiple times in different elements of a sequence. A k-sequence consists of k items. For example, <(8)(Z)(l)> and <(3)(5,9)> arc both 3-sequences.

A sequence <a,~1~, ,  ,an? is a subsequencc of another sequence d ~ , b , .  , , b,,,> if there exist integers i,izz< . . . G, such that a,  E b,,, az G biz,, , a, L b,. For cxample, <(2) (5,9) (X)> is a subsequence of ~ ( 6 )  (2) (1) (5,9) (331, since (2) 5 (2), (5, 9) E ( 5 ,  9) and (8) G (3, 8). However, i ( 3 )  (S)> is not a subsequence of c(3,8)>, and vice versa.

All transactions from the same customer in the database can be grouped together, and then sorted by transaction time in increasing order into a customer sequence, or called data sequence. The support for a sequence s is defined as the fraction of total data sequences that contain s. A data sequence contains a sequence s i f s  is a subsequence of the data sequence. A sequence is a frequent sequence if its support is greater than the user- specified minimum support, denoted min-sup.

problem of sequential pattern mining is to find all frequent sequences. Concerning association rules, the discovery of sequential patterns can be thought of as association  Given a database of customer transactions, the     discovery over a temporal database  2.2 Incremental update on discovered sequential patterns  Let IDBI be the number of data sequences in the original database DB and min-sup be the minimum support. M e r  some update of the database, a few transactions are appended to DB. These transactions can be sorted by cid into jdbfbl data sequences in the increment database db. UD is the updated database combining all data sequences from DB and db, UD = DB U db. Let there be Ib( customers appearing both in DB and db. If all customers in db are new customers with respect to DR, that is, all cjds in db are different from those in DB, jbj is zero.

Let ,Sung be Lhe set of all frequent k-sequences in LIB, S2D be the set of all frequent k-sequences in LJD, and the set of all sequential patterns in DB and UD be .PB and SuD respectively.

Assume that ?or each sequential pattern s in DB, its support count, denoted by ScountDB, is available. With respect to the same minimum support min-sup, a sequence s is a frequent sequence in the updated database UD, if its support count is greater than min-supx (totd data sequences in UD). That is, Sco,,,,:D is no less than min-supx (jDBl+ldbI-161). XcO,,,,tDB, X,,,,,,:b and are support ~ ~ u n t s  of a sequence X in DB, db and UD. If there is no sane cid in DB and db, XcOun~D = XcounFB + XGo,,,,:b. A sequential pattern s in might not be in SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSD because of database update. On the other hand, a sequence s7 that is not in PB might turn out to be in S"'.

Consequently, the problem of incremental update on sequential patterns is to find the new set SuD of frequent sequences in UD. As shown in Fig. 1, In order to find SuD, previous approaches take all data sequences to compute sequential patterns and their supports. With discovered ,pB and support counts, the incremental algorithm updates supports of sequential patterns in SuD by scanning data sequences in db only, if they were frequent in DB. New candidate sequences, which might not exist in DB, are generated in the same scan. Some new candidate sequences are pruned, if they do not have sufficient supports relative to db. before the scan of DB starts. The complexity of mining process is reduced due to the employment of previous knowledge and the increment database.

Updated database, UD = DB + db data sequence 1 data sequence 2  Sequential pattem mining minimum support, min-mp ' p?

data sequence db [data sequence (a) re-execution mining algorithm on UD  Original database, DB  data sequence 1 Sequential pattem mining P B data sequence 2 minimum support, m~n~sup' 1  frequent sequences & support counts /  I + /  data sequencelDb' %l"MDQ,  Incremefit d&t&base, db \ .

data sequenoe 1  data sequence ldbl  (b) incremental updating  P!

Figure 1 : Incremental update versus re-mining  2.3 Example of sequential patterns after database updated  Consider a database with transactions sorted by customel id into 6 data sequences as shown in Fig. 2, Assume minimum support is set to 33%, i.e., minimum support count of data sequences being 2. The sequential patterns are c(l)>, c(2)>,  <(3)>, ~ ( 4 ) > ,  ~ ( 5 ) > ,  <(8)>,  <(5)(3)>, and <(3)( 1)>.

<(UP, <(8>(2)>., c(8)(1)>., <(?NW, %WP, <(5)(1P3  Customer Id Data Se uence < 8  2 1 > < 1 2  8 7 ,  < 5  3 1 >  Fiaure 2: The oriainal database DB with 6 data sequences  M e r  some update activities, assume the transactions appended to the database ai1 come from new customers.

The increment database, sorted by cid into data sequences, is shown in Fig. 3. With same minimum support, it requires 3 data sequences to be a frequent sequence now.

Previous sequential patterns <(3)>, <(8)(2)>, <(2)( 1)>, <(2)(8)>, <(5)(1)>, <(5)(3)>, and <(3)(1)> are no longer     frequent due to this update, While <(7)> and <{8){7)> become nev sequential patterns because they have minimum supports now,  I Customer Id IData Sequence I \  Figure 3: Data sequences in the increment database db  In cases of update when the customer id of new transactions appears in the original database, these transacbons must be appended to the same customer to f o m  hisher data sequence. For example, assume the customers, whose cids are 1 and 4, bought item 7 at later time and the data sequences for cid=l and cr&4 now are <(8)(2)(1)(7)> and <(1)(4)(7)> respectively. Fig. 4 shows an example of data sequences, which come from both old and new cus tw" ,  in the increment database The data sequences for mning in updated database (Iff is shown in F1&, 5 ,  Mter invalidating sequences q ( 5 p  and i {8) ( lp i ,  Me resulting sequentid patterns in this database are <(I)>, '(2)>, ~ ( 4 } > ,  <{7 )~ ,  c(8)~-,  <(1,2p and q8](7p, for the given mimmum support 33%,  Figure 4: Data sequences in db with cids occurring in DB  Figure 5: Merged data sequences in UD  3. Fast Sequential Pattern Update Algorithm (FASTUP)  3.1 Previous algorithms versus FASTUP algorithm  Apriorz algorithm was designed to discover association rules [ 11, while Apt-ioriAII algorithm introduced in 121 was the first algorithm that deals with the problem of sequential patterns mining. In subsequent work 1111, the same authors proposed GSP (Generalized Sequential Pattern) algorithm that outperforms ApriortAll An algorithm called ,S*PADE (Sequential PAttern Discovery using Equivalence classes) was designed that uses simple join operations to find sequential patterns [13]. However, vertical database layout was used, instead of horizonial database layout used in eadier approaches 12, 111.

Therefore, the GSP algorithm is briefly reviewed here.

GSP algorithm makes multiple passes over the database. In the first pass, frequent l-sequences with their supports are determined by counting the support of 1- itemsets. In the subsequent passes, candidate k-sequences are generated from frequent (k-I)-sequences obtained in pass-(k-1). Then the supports for these candidates are computed and those with minimum support become frequenl sequences, This process is iterated until n6 more candidate sequences are formed, In each pass, every data sequence is checked to increment the suppon count of candidates contained in this data sequence. Hence, therc are two essential sub-processes in this algorithm: 1, Candidate generation; Let L, denote the set of all frequent k-sequences, and C, denote the set of candidate k- sequences, Given Id,-,, C, is generated by selectively join L,-, with L,, itself. If therc exist any {k-l)-subsequence of a candidate which is not in Lk-,? the candidate is pruned from C,. Candidates are inserted into a hash trcc to enable fast counting, Please refer to [lll ?or the detailed join operation and the hash tree mechanism, 2. Support counting:: Every item and its following items in the checking data sequence is hashed to reach leaf buckets in the candidate hash tree. The support of each candidate in the buckets, if the candidate is cnntained in the data sequence, is incremented.

Note that as the name GSP suggests, it not otlly solves problems ?ormulared in previous section, but it also solves problems generalized with constraints on pattern hierarchy and transaction-tirnc [I I ] .  The algorithm described hefe is to solve the fundamental problem bf sequentid patterns without constraints.

The basic construct of our algorithm FASTUP is  generation and support counting. FASTUP algorithm has several arguments similar to the incremental association update algorithm FUP [ 5 ] .  Nevertheless, the effect of  similar to that of GSP, with improvements on candidatc     candidate reduction is more dramatic in sequence mining.

Moreover, we have to consider whether appended data sequences are required to merge with old data sequences.

Features that distinguish FASTUP from GSP are listed as ?allows.

1. During pass-k, for each XES:', The support count of X is updated against db, without re-scan DB. Old frequent sequences that do not satisfr new support count are filtered out.

2, During pass-k, if XES,.,"~ and XgSk.,"", prune every candidate C t C, such that X i s  a subsequence of C. With this feature FASTUP has greater capability in candidate reduction by a simple check in db before counting starts in DB, 3, During pass-k, a k-sequence X, where XgS,"", with XCu,,,,,,, , is added to Ct if Xcoun?z minpsupxldbl. For each KEG. The suppon count of X is updated against DB. The generation of candidate sequence X requires less data sequences checking in db than in DB or in IJD. Only the supports of "new" candidates, instead of all candidates, need to be checked in DB,  These features altogether enable FASTlJP to have better performance than re-execution GSP on updated database, Previous frequent sequences and candidate sequences in DB that do not belong to UP are pruned away by siinple checks on db, Without missing any potential new frequent sequences in UD, fewer new candidates are generated from db for checking against D3.

rlb  3.2 for sequential pattern mining  Merge data seqvences of the same customer  For the given data sequences in DB and db, the sequential patiems in UD can be found by re-execution of GSP. Transactions that come from the sane customer, either in DB or in db, are parts of the unique data sequence for that customer in UD. Data sequences with same customer id in both databases must be merged into one data sequence before GSP starts. Likewise, FASTUP algorithm merges data sequences when necessary but relays practical information about discovered sequential pattems.

In order to retain as much information as possible, and to keep smaller number of data sequences for subsequent mining processes, we extract data sequences from DB and merge them to db. The merging is accomplished as follows.

1. With given data sequences, sorted by cid, in db and DB, we check cids in db against DB to find any existence of that cid.

2. For the found data sequence ds in DB, the support counts of all frequent sequences contained in ds are decremented by one.

3. The ds i s  merged into that data sequence ds' with same cid in db, with ds followed by ds '.

Apparently, with sorted data sequence, searching cid could be done in very short time. With known sequences for checking, decrement operations add slightly overhead in merging process. After extraction and merging, there is no data sequence in DB and db with same customer id.

FASTUP algorithm then could proceed to next stage.

3.3 FASTUP algorithm  Pass-1: find frequent 1-sequences in updated database, 1. Scan db for all 1-sequence X to get XFountb.

to the failed set, otherwise add X t o  SIUD.

3 .  In the same scan, if X~SlD6/vy,,,~b< min supxldb(, X  could not be frequent; otherwise, add X to C,.

4. Scan U13 for each XEC', to get XGounpB. If XGo,,,,iDB  +X,,,,~% min supx(lDBl+ldbl) at the end of pass-1, add  In comparison with GYP, FASTUP discovers previous frequent 1 -sequences that is still frequent, filters Out those that arc invalid now, and generates potential candidate 1- sequences within a scan on increment database. Every new canbdate in the set of new candidate 1-sequences is then checked against the original database to see if it is frequent.

Contrast to GSP, GSP takes every item as a cadidate and counts over the whole database. FASTUP is obviously faster than GSP in this pass.

Pass-k: find frequent k-sequences in updated database.

1. Generate C, from ,Sk-,"" a5 GSP described 1111. C, is  characterized into two subsets. Let ck,= CpSkDB, c &= C,-C;, . C,, consists of candidates that are also frequent k-sequence in DB, m l e  C,, consists of remaining candidates that are "newly" generated.

2. A previous frequent k-sequence X in DB, which XE(&""-C,,), is not contained in C,. SuchX, though in ,YkDB, need not be checked against db.

3. Scan db for each X in C, to get XconnPb, For each X in Ckl, since XCOlVltDR is available wiihout checking DB, Xis added to S,"" if it has minimum support.

4. In the same scan of db, for each X in c k 2 ,  if Xco,?< minpsupxldbl, X could not be frequent. Such X is removed from (Ik2. This step reduces the number of candidates to be checked against DB.

5 .  Scan DB for each XE&, compute XcountDB. X is added to S>D if Xco,,,,pB +Xcoo,tb2 minsupx(lDBl+ldbl) at the end of pass-k.

The above process is iterated until no more candidates are generated. At each pass, FASTUP updates supports of frequent sequences in DB which are still frequent in UD, and generates most likely frequent candidates within one scan over small increment db. Candidate sequences, which  1. IfXcS,D~d,,,DB +XG,,p< min supx(pB~+ldbl), put A-  X to S , " D     do not have sufficient supports relative to db, are pruned before they are verified by DB. The set of candidates that FASTUP generated for further checking with DB is smaller than GSl? Consequently, FASTUP could be much faster than previous algorithms of sequential pattern mining.

Complete FASTUP algorithm.

Algorithm Merge-Data-Sequences.

I* Let current data sequence be dsdb *I I* Let cid of current data sequence be cid *I For-all data sequences in db do  If cid is found in data sequence ds,, in DB then Forall  frequent sequences contained in  End-for Replace dsdb by ds,, merged with dsdb, where  do Decrement support count of this sequence by 1  transactions in ds,, followed by transactions in dsdb End-if  End-for Algorithm-Fast-Update-Sequential-Patterns.

I* Initialize aU~,,,,db to zero,Xis 1-sequence, i.e., 1- itemsets. */ For-all data sequences in db do  /* PASS-1 *I  Increment XGomp by 1 if current data sequence contains X  End-for Forall  1-sequence X do  IfX is frequent in DB, then EXcoun? +Xcomtdb> min-supx()DBl+ldbl) then  Endjf IfXis not frequent in DB, then  If Xco,,,,tb> min-supx Idb I then  End-if  add X to S,UD  addXto (I,  End-for For-allXin c, do End-for Forall  data sequences in DB do  InitialIzeYco,,DB to zero  Foral lXin c, do contains X  Increment Xco,,,,tDB by 1 if current data sequence  End-for End-for For-all X in C,do  IfX;,,? + X,,,pb2 min-supx()DBl+ldbl) then add X to S  End-for J* All frequent 1-sequences & their counts accumulated*/ I* Pass-2 and beyond *I k = 2 Generate Ckfrom Sk.1 UD  While Ckis not empty do /* Initialize all x,,,,"~ to zero, x i s  k-sequence. in ck *I  Increment Xco,,,,pb by 1 if current data sequence For-all data sequences in db do  contains X End-for For-all k-sequence X in C, do  If X is frequent in DB, then IfX,,,,,,,"" +Xco,,,,:b2 mm-supx((DB(+(dbl) then  End-if If X is not frequent in DB, then  IfXc,,:b> mm-supxldb( then  End-if End-for For-all X in C,..do  End-for For-all data sequences in DB do  add X to S,""  addXto (i2  Initialize Xco,,,,YB to zero  For-all X in Ck2do Increment X,o,,"B by 1 if current data sequence  contains X End-for  End-for For-all X in Ck, do  IfXco,,,,tDB +Xcom:b> mzn-supx(lDBl+ldbl) then  End-if add X to &TkuD  End-for I* All frequent k-sequences and their counts accumulated */ k = k + l Generate C,from &.IuD  Endwhile  3.4 Examples on merging and FASTUP algorithm  Example 1. Given a original database DB which combines sequences in Fig. 2 and Fig. 3, with total 9 data sequences.

If an increment database db in Fig. 4 with total 5 sequences is appended, the sequences of cid=l and ci&4 would be extracted from DB and merged into db. Now DB has 7 and db has 5 data sequences. The count for <(8)>, <(2)>, <(l)>, and <(8)(1)> is decremented by 1 due to the extraction of data sequence with czd=l. Likewise, extraction of data sequence with cid=4 would cause support of <(I)> and <(4)> decreasing. After extraction and merging, FASTIJP can be applied correctly since no cid appears in both DB and db.

Example 2. Given a database DB, and an increment database db, such that after data sequences are merged, IDB(=lOOO and ldb1=125. For min-sup=S%, in last     discovery, after extraction and merging, found sequential patterns are listed in Table 1.

Let us consider sequential patterns related to items 1, 2, 3, 4, 5. In order to find frequent 1-sequences in UD, a scan on db is made at first. Table 2 shows the result of the scan. Now <(1)> and <(3)> remain frequent with counts updated to 120 and 95, both counts > 8%x(1000+125), i.e.

90. <(2)> is no longer frequent since its count is only 85.

<(5)> cannot be frequent because its count in db, being 9, is less than 8%x125. A scan on DB for new candidate <(4)> is then conducted. Suppose <(4)>"PB =70, <(4)> is a new frequent 1-sequence with count 94. Before proceeding to 2-sequence counting, <( 1,2)>, <( 1)(2)> and <(3)(2)> are eliminated from counting in db for having subsequence <(2)>, which is not frequent in UD. In fact, candidate 2-sequences now consists of old frequent 2- sequences <(1,3)> and <(1)(3)>, new can&date 2- sequences <( 1,4)>, <( 1)(4)>, <(4)( 1)>, <(3,4)>, <(3)(4)>, <(4)(3)>, and <(3)(1)>. Note that the support count for <(3)(1)> is not available since it failed to be frequent in DB and its count was not kept. After a scan on db for these candidates, the result is shown in Table 3. Now <(1)(3)> remains frequent with count=93. Another counting on DB is only required for <(1)(4)> and <(3)(4)> to check if they have minimum support. It is not necessary to check <(3)(1)> since its count in db is less than minimum required. The discovery continues until no more candidate sequences are generated.

Frequent sequences Sequence Support Count <(I)> <( 1)> 100  S*DB <(1,3)> <(1,3)>c0,~B=81 <( 1)(2)> <( 1)(2)> coun~B-83  Table 1. Sequential patterns and their counts in DB after merging and extraction  <(1)(3)> <(3)(2)>  Table 2. 1 -sequences and their counts in db  <(1)(3)> co,,,,~B=86 <(3)(2)> co,~B=Sl  Table 3. Candidate 2-sequences and their counts in db  4. Conclusion and Future Works  Due to the nature of sequence permutation, the problem of sequential pattern mining is more complicated than the discovery of association rules. Without maintenance, valid@ of discovered patterns may change after update on database. We propose FASTUP algorithm that efficiently solves the problem by incremental updating without re-mining the whole updated database from scratch. Using frequent sequences and support counts discovered from original database, FASTUP rapidly updates frequent sequences and their counts by scanning over increment database instead of whole updated database.

Fewer but more promising candidates are generated by just checking counts in increment database.

The simulation of our algorithm on synthetic data is underway. Given the analysis on sequential pattern mining, the performance of the algorithm could be much faster than previous algorithms for the maintenance of sequential patterns. Further researches could be extended to problems of various minimum supports and problems of generalized sequential patterns such as patterns with is-a herarchy.

