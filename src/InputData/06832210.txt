AMD based Service Agent Collaboration and Specification

Abstract? With the emergence of Big Data in Internet, composing existing web services for satisfying new require- ments,such as data quality enhancing, effective data choos- ing,knowledge discovering etc, has gained daily expanding at- tentions and interests. Many efforts have been pursued for sup- porting the essential activities in service composition. However, the existing techniques only focus on passive services which are waiting there for being discovered and invoked. We argue that it might be more attractive when Web services become active entities (Service Agent) distributed in Internet which can recognize the newly emergent requirements and compete with others for realize (part of) the requirements. Retreating or refinement of Big data will hardly be accomplished by one or two data handling center, Service Agent collaboration would be a competitive method for the big data handling problem. Mostly more than one service agents have to collaborate to satisfy requirements in current internet environment especially with social networks. That could be called as the requirement driven agent collaboration. Research on such collaboration might be useful for the previous problem. We have given a preliminary model for the requirement driven agent collaboration based on a function ontology and the automated mechanism design in the earlier work.This paper extended the Function Ontology, and enhanced the AMD model. That makes the interactions in MAS generated by agent collaboration can be described.A negotiation frame for the evaluation and choice of collaboration solutions is also given in this paper. It helps the requester evaluate the possible MAS systems, and helps the service agents make decisions to choose a good enough solution by negotiation.

According to the dependencies provided in Function Ontology, a specification is given to describe the execution process of the chosen MAS. And also a method is given to translate the specification to BPEL which is more standard, acceptable, and easier to understood.

Keywords-Multi-Agent;Collaboration; Mechanism design

I. INTRODUCTION  A multi-agent system (MAS) is a loosely coupled network of problem-solver entities that work together to find answers to problems that are beyond the individual capabilities or knowledge of each entity [5]. Currently, agent-based systems technology is particular attractive for creating software that operates in environments that are distributed and open, such as the internet. At present, there are already many MASs, e.g. those registered in the agentcities [2]. However, there are mainly two kinds of computing mechanisms for these systems. The first one is centralized and centered by a system manager or a coordinator, e.g. the description  database with the kernels in MACE [8]. In which, the manager allocates tasks and chooses strategies and the other agents behave according to the commands issued by the manager. FIPA [3] gives a standard for this kind of MASs.

The second is decentralized and includes those multi-agent systems based on game theory. In such systems, agents form coalitions, make solutions by negotiation, and work under some manually given rules which are designed for particular purposes [7] [12].

Currently, service-oriented architecture, connecting Web services, has been paid lots of attentions for distributed computing and communication on loose coupling and het- erogeneous platforms [14]. In this architecture, Service Agency is responsible for managing and discovering ser- vices; Obviously, it is a centralized model. When considering the Web services as the Service Agents, this mechanism of service-oriented computing may appeal a decentralized computing mechanism for MASs. This computing mech- anism can be demonstrated by the following scenario.

A requestor publishes a task request onto the Web. The available Service Agents on the Web detect the newly emergent requirements, recognize those (sub-)tasks which they can accomplish, and compete for being a member of the candidate agents for the request. After all the candidate Service Agents gather together, the technique of mechanism design is used to generate the protocols to make these service agents collaborating to fulfill the task request. We call this kind of computing mechanism the requirement driven agent collaboration [16] [17].

Figure 1 demonstrates the scenario of the requirement driven agent collaboration in distributed and open Web en- vironment. In this figure, the larger ellipses are the requests submitted by requestors which are usually represented by some kind of task specification. The smaller circles are available service agents. For an ellipse, there are some circles around it. That means those service agents have rec- ognized that they are able to make contribution to the request satisfaction and are willing to compete with others for some of the sub-requests. In this sense, the requirement driven agent collaboration means the process of agent congregation for completing an emergent requirements. In this process, each request seems like a magnet which can make the service agents moving towards it. That is the reason we use the term  on Embedded and Ubiquitous Computing  DOI 10.1109/HPCC.and.EUC.2013.327   on Embedded and Ubiquitous Computing  DOI 10.1109/HPCC.and.EUC.2013.327     of ?magnet effect? for capturing the relationship between the requirements and the service agents.

Request  Service Agent  Figure 1. Magnet effect between requests and agents  We have proposed a framework for the requirement driven agent collaboration [16]. It gives a computing mechanism for multi-agent systems which we believe will help to realize the vision for the next Web revolution. A Functional On- tology(FO) [15] was constructed for supporting the service agents to understand the specification of the request. This ontology provides the terminology for describing both the requested tasks and the service agents? capability. So, with this ontology, service agents can understand the require- ments and decide if they need to be engaged for fulfilling the requirements. For making the service agents automatically collaborating, the model of Automated Mechanism Design (AMD) [13] was extended by introducing the task require- ments and the process of generating the outcomes from the task requirements.Figure 2 depicts the extended AMD.

R  Outcomes AM D  M  Appropriate  Agent Group  A request  The Outcomes  from the Requirement  The Mechanisms  Created by AMD  Figure 2. Extended AMD  With a mechanism, the candidate agents can choose functions and solutions to satisfy the request. When all the agents decide which function or functions they will do, a MAS would be established. For a given requirement, there might be many possible MASs which could be offered by the aggregated agents. Evaluating these possible systems effectively is necessary for the customer. In this paper, a kind of agent named requester does the customer?s job . The requester can evaluate single candidate agent and possible coalitions the agents may form according to the quality of service. Based on the evaluation, a negotiation framework is given. In this framework, the requester and  all the service agents will negotiate to choose a good enough coalition and collaboration solution which means a executable MAS system. The chosen solution would satisfy the requirement both in function and quality and satisfy the service agents in their payoffs. When the coalition and the collaboration solution is decided, a specification which describes the agent collaboration process should be given.

In this paper we extend the function ontology. Dependencies are defined for behaviors and functions to describe the possible relations between behaviors or functions. Based on the extended function ontology, we give a specification for the MAS established by the agents. And the specification can be translated to BPEL [4]which is a process describing language widely used in describing the composition of web services.

This paper is organized as follows. Section 2 gives the extended Functional Ontology. Section 3 gives the extended definitions in AMD model and introduces the agent col- laboration model based on AMD brie?y which has been described in detail in our earlier work [15]. Section 4 gives the evaluation method for service agents and agent coalitions. The negotiation frame between agents is also discussed in this section. Section 5 gives the specification of the chosen MAS system and the translation to BPEL language. Section 6 gives the conclusions and some future research work.



II. EXTENDED FUNCTION ONTOLOGY  For enabling the requirements driven agent collaboration, agent have to understand the specification of requirement.

A Functional Ontology is constructed for this purpose. This ontology gives the the same terminology for describing the capability of agents and requests.

The Functional Ontology is represented in a hierarchy of controllable resources together with the effects on them[6].

In the Functional Ontology, each individual resource has attributes. These attributes are dived into two groups: the static attributes, i.e. their values are fixed once the attributes are instantiated, and the dynamic attributes, i.e. their values are changeable along different situations. We call the static attributes with their values the ? information? of the resource and call the dynamic attributes with their values the ? states? of the resource. Any set of state changes of a resource is called an effect on this resource. In the following paragraphs, we give the definitions of some important basic concepts and the extending in the functional ontology and discuss the characteristics of them.

Resource. Anything that can be identified and can be op- erated by software agents is a kind of resource at a particular domain. e.g., information (value, date, etc.), physical entities (hardware, people, etc.), software systems and so on. All of these resources are defined by a set of attributes, each of which features some aspect of the resources. The attributes of a resource are classified into static ones and dynamic     ones. A static attribute is irrespective of time and keeps its value all the lifecycle. A dynamic attribute might change its value when external conditions change.

Definition 2.1: (Resource)Resource is described as a 6- tuple  Res :=< SAttr, DAttr, SARan, DARan, V alFuncofSAttr,  V alFuncofDAttr >  in which, ? SAttr = {a1, ? ? ? , an}, n ? N is a finite set of static  attributes of the resource; ? DAttr = {da1, ? ? ? , dan}, n ? N is a finite set of  dynamic attributes of the resource; ? SARan = {v1, ? ? ? , vm}, m ? Nis a finite set of static  attribute values of the resource; ? DARan = {dv1, ? ? ? , dvm}, m ? Nis a finite set of  dynamic attribute values of the resource; ? V alFuncofSAttr : SAttr ? SARan is a value  function of static attributes; and ? V alFuncofDattr : DAttr ? P(DARan) is a  value function of dynamic attributes. P(DARan) is the power set of DARan.

For the convenience of narration, several symbols about the resource are listed here.

? @ is a general separator, means ? of?; ? sa@res means a static attribute sa of resource res; ? da@res means a dynamic attribute da of resource res; State. The state of a resource characterizes the value of  the dynamic attribute. As the situations change, the values of dynamic attributes may change too, which result in the transitions of the resource states. So we also called dynamic attributes as state attributes.

Definition 2.2: (State) Let res be a resource and da1, ..., dan be n dynamic attributes of it. A state of res is st@res = (val1, ..., valn),vali = V alFuncofDAttr(dai), i = 1, ..., n.

Behavior. The behaviors can be defined as the state transitions of the resources. As state transitions could be viewed as the basic effects imposed on resources, that means we model behavior as possible primitive operation on resource. In this sense, we give the following definition.

Definition 2.3: (Behavior) A behavior is defined as a triple:Beh :=< res, s0, s1 >, res is the resource operated by Beh. s0 is the state of res before the operation. s1 is the state of res after the operation.

Definition 2.4: (Sequential Behaviors) If we have beh1 =< res, s0, s1 >,beh2 =< res, s1, s2 >, we say beh1 and beh2 are sequential. beh1 is the direct precedent of beh2. beh2 is a successor of beh1  Function. The functions are conceptual classes of con- crete functional models. Generally a function description includes two parts: a capability description and some con- straints. The capability of a function can be represented by  a set of behaviors. Constraints are limitations of functions.

Most constraints are domain-related. Generally they can be represented as some logic expressions of the resource state.

So we give the following definition.

Definition 2.5: (Function) Function is described as a 7- tuple  Func :=< Beh, Res, Cond, CondFuncofBeh, Prop,  PropFuncofBeh, Dependency >  in which,  ? Res is the operable resources set; ? Beh is a set of all behaviors of the function; ? Cond is a logic expression set of resource state; ? CondFuncofBeh : Beh ? P(Cond) is a condition  function which gives the execution conditions for each behavior;  ? Prop is a payoff distribution proportion set of the behaviors and  ? pi?Prop pi = 1;  ? PropFuncofBeh : Beh ? Prop is the proportion function of behaviors.

? Dependency :=< DirecBehDepen, CondBehDepen > in which,  ? DirecBehDepen is a relation set, for any relation (behi, behj) ? Beh?Beh, (behi, behj) ? DirecBehDepen iff behj is a successor of behi and CondFuncofBeh(behj) = ?. We call such relations direct behavior depen- dency;  ? CondBehDepen is a relation set,for any relation (behi, behj) ? Beh?Beh, (behi, behj) ? CondBehDepen iff behj is a successor of behi and CondFuncofBeh(behj) ?= ?.We call such relations conditional behavior de- pendency.

Function Decomposition Mode. A function decomposi- tion mode is a description which describes how to decom- pose a function into sub-functions.

Definition 2.6: (Function Decomposition Mode) Let func be a function. A function decomposition mode for func is a 7-tuple  FuncDecMod(func) :=< SubFuncs, Cond, CondFuncofSubFuncs  Prop, PropFuncofSubFuncs, Dependency >  , in which  ? SubFuncs = func1, ..., funcn is a set of functions,funci(1 ? i ? n) is a sub-function of func;  ? Cond is a logic expression set of resource state, and the resources are in the resource set of func.

? CondFuncofSubFuncs : SubFuncs? P(cond) is a condition function which gives the execution conditions for each subfunction of func.

? Prop is a payoff distribution proportion set of the subfunctions, and  ? pi?Prop pi = 1;  ? PropFuncofSubFuncs : SubFuncs ? Prop is a proportion function of the sub-functions.

? Dependency :=< DirecFuncDepen, CondFuncDepen > in which,  ? DirecFuncDepen is a relation set, for any rela- tion (funci, funcj) ? SubFuncs? SubFuncs, (funci, funcj) ? DirecFuncDepen iff funcj is the direct successor of funci in the subfunction execution sequence and CondFuncofBeh(funcj) = ?. We call such relations direct behavior dependency;  ? CondFuncDepen is a relation set,for any relation (funci, funcj) ? SubFuncs? SubFuncs, (funci, funcj) ? CondFuncDepen iff funcj is the direct successor of funci in the subfunction execution sequence and CondFuncofBeh(funcj) ?= ?. We call such relations direct behavior dependency.

With the same terminology, we represent an agent with a four-part-structure, i.e. a set of behaviors, a set of resources which it operates on, a set of state transitions that it enables, and a function from the behavior set to the transition set.

Then the process for an agent to recognize a given request includes the following steps:  1) Find its operatable resources in the request?s resource vector. If there is no matched resource, the request is not suitable for it, else record all the matched resources.

2) Get the beginning state and the ending state of each matched resource from the requirement.

3) Computing state transition pathes from the starting state to its corresponding end state for each matched resource according to FO.

4) Check whether it has a behavior which can enable one of the effective state transitions.

5) If it has no matched behaviors, the request is not suitable for it, else it becomes one of the candidates of the request.

Any appropriate agent group has a time limitation for waiting its candidate agents. This time limit is different for each request which is decided by the request provider base on his/her experiences. After the waiting time, a local environment composed of a request and its candidate agents will be constructed. This environment is called a requirement domain. The candidate agent set in a requirement domain is also called an appropriate agent group of the requirement.

These agents in the appropriate agent group will collaborate to complete the request.



III. AGENT COLLABORATION BASED ON AMD  The agent collaboration in a requirement domain can be finished with the helping of AMD. In our earlier work, the collaboration process includes two steps.The first is the  process of automated mechanism design. That would give optimal outcomes for different agent groups. The second step is the agent negotiation process for given outcomes.

That would produce effective agent behavior sequence for a given outcome. In this paper, we give a new AMD model, which can provide collaboration solutions directly for the appropriate agents. The model of automated mechanism design includes the preconditions for AMD, the mechanism definitions, and the constraints definitions.

AMD is an approach, where the mechanism is computa- tionally created for the specific problem instance at hand. In Automated Mechanism Design, we need:  ? a finite set of outcomes O; ? a finite set of N agents; ? for each agent i,  ? a finite set of types ?i, ? a probability distribution ?i over ?i(in the case of  correlated types, there is a single joint distribution ? over ?1 ? . . .??N ),  ? a untility function ui : ?i ?O ? R; ? an objective function whose expectation the designer  wishes to maximize.

Here, let N Agents be N Service Agents. In order to apply AMD in our work to fulfill the goal of Service Agents aggregation, we should define the outcome set and each Service Agents? type set. In this paper, they are defined below.

Definition 3.1: (Type Set)The type set of a Service Agent is defined as a vector set whose elements are all the permuta- tions of nodes that, written in the form of vector, the Service Agent could match on the Requirement Decomposition Tree.

Definition 3.2: (Outcome Set)The outcome set of a Top-Level function(F 11 ,F  2 ,? ? ?,F 1n1 ) is  defined as a vector set whose elements are vector (FDM1i1 , FDM  i2  , . . . , FDMsis), s ? N satisfying the following two conditions:  ? Every heft of the vector is FDM node of Requirement Decomposition Tree, and the order is from the top to bottom of the tree.

? Every Vector denotes one unique path to accomplish a top-level function  With above definitions, Automated Mechanism Design is applied so that the Service Agent would participate the aggregation without manipulation.

In our AMD mode, mechanisms are deterministic. A deterministic mechanism without payments consists of an outcome selection function o : ?1? ...??N ? O. A deter- ministic mechanism with payments consists of an outcome selection function o : ?1? ...??N ? O and for each agent i, a payment selection function ?i : ?1 ? ... ? ?N ? R.

The payment is for the request provider.

Two types of constraints are used in our AMD pro- cess, IR(individual rationality constraints) and IC(incentive     compatibility constraints). IR constraints ensure every agent participator would gain its lower limit of payment at least.

IC constraints is to ensure the agents will never misreport their type. For example the definition of an ex interim IR constraint is: for any agent i, and any type ?i ? ?i, we have  E(?1,...,?i?1,?i+1,...,?N)|?i[ui(?i, o(?1, ..., ?N ))? ?i(?1, ..., ?N )? ?] ? 0  in which ? ? R is the lower limit of agent i?s payment, ?i : ?1? ...??N ? R is a payment selection function for the requirement provider.

AMD finds all the mechanisms which can satisfy all the constraints. The mechanisms provide all the possible func- tion choices for the candidate agents to satisfy the request.

And it also provide the efficient collaboration solution by the outcome for different agent type set. Therefore, with a mechanism, the candidate agents can choose functions and solutions to satisfy the request. When all the agents decide which function or functions they will do in the solutions, a MAS would be established.



IV. MAS EVALUATION AND THE NEGOTIATION FRAMEWORK  A MAS system is an agent coalition with a certain collab- oration solution. According to the Function Ontology and the mechanisms provided by AMD, agents choose functions in different function decomposition mode. A different choice they made means a different MAS system. And for there may be many agents with a same type, there might be many possible agent coalitions for a given collaboration solution.

Therefore there are many possible MAS systems after the process of AMD. All the service agents in the requirement domain must negotiate to choose a final coalition and the collaboration solution. In our papers earlier, a group decision making model? barycenter model was given. Based on the model, agents negotiate to choose a final solution.

In this paper, we prefer to let the requester do the work of evaluation and negotiating with the service agents to choose the most appropriate MAS system.

Maximellien gave a QoS Ontology [11] for web services, which includes most of the familiar quality evaluation items, such as responding time,throughput,latency, LoadBalancing, and etc. This Ontology can also be used to evaluate service agent. By referring the QoS Ontology, the requester can eval- uate the candidate service agent in each quality item. In this sense, we give a quality evaluation function for an arbitrary service agent agenti when it was doing a function Funci.

Assume the evaluation is carrying on in n quality item, and a unique evaluation interval [0, MAXE], MAXE ? R is used, the function is as follows.

Qua(Agenti, Funci) = n  n?  i=1  ?i?i  in which, ?i ? [0, MAXE] is the evaluation value for the ith quality item, ?i is a preference value for the ith quality item of the requester.

Based on the above definition, we give the evaluation of a MAS system. Suppose the request needs N functions, Func1, ..., FuncN , and solutioni is one of the possi- ble collaboration solutions. Agenti will execute Funci in solutioni. Assume the preference to Funci of the requester is pi, then the evaluation function of solutioni is  Squa(solutioni) = N  N?  i=1  piQua(Agenti, Funci)  According to the evaluation value, the requester will give a payoff value to the given solution. Commonly, higher evaluation value means higher solution payoff. Because requesters would pay more for a more qualifiable solution.

Hence, the payoff function of a solution must have a positive correlation with the solution evaluation function. We give a solution payoff function which is positive correlated with the evaluation function as follows.

Payoff(solutionj) = Squa(solutionj)  MAXE MaxiPay  in which, MaxiPay is the maximum expected disbursement of the requester.

With the solution payment given by requester, service agents can calculate the payoffs they can get according to the functions they will do in the solution. Some agents may get satisfiable payoffs and they will support the current solution.

On the contrary, some other agents may be not satisfied by the payoff they got, and they will reject the solution. So agents must negotiate to find a solution which is satisfiable for all of them. However the solution which is good to all the service agents may be not good enough to the requester.

A negotiation among the requester and all the service agents is required. We give a negotiation frame for this problem.

The negotiation process can be represented by a small scenario. In the scenario, there are three agents. One re- quester and two service agents: Agenti and Agentj . The requirement is a implementation of three functions: Func1, Func2 ,Func3. p1, p2, p3 are the preference value for the three functions of the requester. Minpayi is the minimum expected payoff of Agenti. Minpayj is the minimum expected payoff of Agentj . If an agent could not get a payment more than its minimum expected payoff, it will not participate the collaboration. The functions Agenti can do include Func1 and Func2. The functions Agentj can do include Func2 and Func3. The negotiation process is as follows.

? Step1. Agenti proposes a most profitable solution of itself? solution1:let Agenti do Func1 and Func2 and let Agentj do Func3.

? Step2. The requester evaluates solution1. Let k = MaxiPay MAXE , then the payoff of solution1 is  Payoff(solution1) = k  (p1Qua(Agenti, Func1)+  p2Qua(Agenti, Func2) + p3Qua(Agentj, Func3))  ? Step3. Assume the agents distribute payoff according to the functions they do. Agenti will get  payAi = k  (p1Qua(Agenti, Func1)+p2Qua(Agenti, Func 2))  Agentj will get  payAj = k  (p1Qua(Agentj, Func3))  If payAi ? Minpayi and payAj ? MinPayj, then Agenti and Agentj will make an agreement, and solution1 will be chosen. If payAi < Minipayi, that means the most profitable solution of Agenti cannot reach its minimum expected payoff, Agenti will quit and the collaboration will fail. If payAj < Minipayj, that means the solution Agenti proposed is not good enough for Agentj , Agentj will reject solution1 and propose a new solution in the next step.

? Step4. Agentj rejects solution1, and propose the most profitable solution for itself? solution2: let Agenti do Func1, and let Agentj do Func2 and Func3.

? Step5. Same with step2, the requester evaluate solution2. Agenti and Agentj will get new payAi and payAj . Similarly, if payAi ? Minpayi and payAj ? MinPayj , then Agenti and Agentj will make an agreement, and solution2 will be chosen. If payAi < Minipayi, that means the solution Agentj proposed is not good enough for Agenti, Agenti will reject solution2 and propose a new solution. For the most profitable solution of Agenti,solution1, has been rejected by Agentj , Agenti will propose a suboptimum solution of itself. If payAj < Minipayj, that means the most profitable solution of Agentj cannot reach its minimum expected payoff, Agentj will quit and the collaboration will fail.

? Step6. Repeat the above steps until the agreement is made or the collaboration fails.

Figure 3 represents the negotiation process in the small scenario. In this figure, the three ellipses is the three agents, requester, Agenti and Agentj . The arrows represent the negotiation behaviors of the agents. These behaviors include: propose,evaluate,reject,and accept. The objects of the behaviors are solutions. The rectangles in the figure represent the solutions. solution1 is the most profitable solution of Agenti, and similarly solution2 is the most profitable solution of Agentj . solution3 is the suboptimum solution of Agenti which is not mentioned in the above steps. In figure 3,Agentj accepted solution3, that leads the  Figure 3. Negotiation process in a small scenario  final solution of the negotiation will be solution3, and it is represented by a nested rectangle. The label number in a circle represents the behavior sequence of the three agents.

The candidate agent coalition and the final chosen solu- tion will make a executable MAS system. And this MAS system is generated by the agents themselves including the requester and all the service agents.



V. SPECIFICATION OF THE MAS  When the service agent coalition and the collaboration solution are chosen, a specification of the final MAS system must be available. Based on the dependencies between behaviors and functions, we can draw and describe the interaction process of the agents in a MAS and give a specification like figure 4 by following concepts and ex- pressions.

? process{} is a block which includes a group of inter- actions of agents, it can also include sub-processes.

? Block parallel{}includes paralleled interaction se- quences.

? Block sequence{}includes a group of agent behaviors, any adjacent two behaviors have direct behavior depen- dency.

? link{} is a block defined in parallel block, it describes the relationship between two behaviors which are in paralleled sequences.

? The expression condition? A:B means when the condi- tion is true behavior A will be executed, otherwise B will be executed.

This specification language is expressed in ABNF(the augmented BackusCNaur form) [1]which extended the Backus-Naur form. For the convenience of representation, in our expression the rules are all included in a pair of ?<>? as the form of rules in BNF. The ABNF expression of our specification language is as follows.

? < process >= ?process{? ? (< parallel > / < sequence > / < process >)?}?  ? < parallel >= ?parallel{??link{? < linkstatement > ?}?2? < process > ?}?     Process{  Parallel{  Link{link1;}  Sequence{  A1.b1;  A2.b1(source,link1);  }  Sequence{  A3.b1;  A2.b2(target,link1);  cond?A3.b1:A3.b2;  }  Sequence{  A4.b1;  Parallel{  Sequence{A5.b1;}  Sequence{A6.b1;}  }  }  }  }  Figure 4. A specification of MAS  ? < sequence >= ?sequence{?? < behaviors > /? < conditionstatement > ?}?  ? < linkname >= 1 ? V CHAR ? < linkstatement >=< linkname > ?; ? ? < behaviors >= 1 ?  V CHAR[?(??source?/?targe??, ? < linkname > ?)?]  ? < conditionstatement >= ?cond???? < behaviors > ? : ? < behaviors > ?; ?  Some symbols used in our expression should be explained here. In ABNF, a rule may be defined by listing a sequence of rule names. That means a blank connects two rules. A rule may be defined by a list of alternative rules separated by a solidus (?/?). To indicate repetition of an element the form < a > ? < b >element is used. The optional < a > gives the minimum number of elements to be included with the default of 0. The optional < b > gives the maximum number of elements to be included with the default of infinity.[Rule] means the rule is optional. VCHAR is one of a core rules in ABNF which means visible (printing) characters. The core rules are defined in the ABNF standard.

This specification describes all the possible collaboration relations in the generated MAS system. The sequence block includes the sequence of agent behaviors, e.g. A1.b1; in figure 4. A1.b1 is a behavior b1 which is owned by an agent A1. The symbol ?;? separates two sequential behaviors. The condition expression is used to describe the choice relation with conditions among agent behaviors. The parallel block includes paralleled behavior sequences. But two behaviors may be sequential even when one of them is in a paralleled sequence. The link block is used to describe this kind of relation between two behavior. The sequence relation is drew  from the direct behavior dependency in Function Ontology, and the switch choice relation is drew from the conditional behavior dependency.

Business Process Execution Language (BPEL) [4] is a business process modeling language that is executable. The origins of BPEL can be traced to WSFL and XLANG.It is serialized in XML and aims to enable programming in the large. Programming in the large generally refers to the high-level state transition interactions of a process?BPEL refers to this concept as an Abstract Process. A BPEL Abstract Process represents a set of publicly observable be- haviors in a standardized fashion. It includes all the possible interaction structures,such as sequence, switch case, loop, and parallel. However an Abstract Process also includes information such as when to wait for messages, when to send messages, when to compensate for failed transactions, etc. These information are not needed for an MAS composed of autonomous and active agents. Agents do what they want to do. Our specification just tells customer or people what the agents would do and how they collaborate. That is the main deference between our specification and the traditional BPEL. Though BPEL is not suitable for MAS in some aspect, it is more standard and easier to be accepted and understood by customers. Therefore we give a algorithm to translate our specification to the Abstract Process of BEPL by the following algorithm. With the algorithm 5,  Figure 5. Algorithm for translating MSL to BPEL  the specification in figure 4 can be translated into a BPEL Abstract Process like figure ??.

For the differences between service agents and the clas- sical web service, the above BPEL abstract process cannot be used to deploy web services. But for a new request, if there exists MAS specification for it, the candidate service agents can using this specification or BPEL abstract pro- cess directly to instruct a MAS system. That means the mechanism design and the negotiation process are reused.

Another useful point of the specification is in the MAS evaluation. In this paper, the coalition evaluation is based on the evaluation of single agent behavior, and the MAS structure or the collaboration relation is not used in evalua- tion. But two MAS system composed of same agent group with different structure may have different quality in treating a same request. However, the specification includes all the collaboration relations. It may bring big help for the future evaluation work which should consider the structure.



VI. CONCLUSIONS  Base on the requirement driven agent collaboration the- ory [18], [9], [10], this paper extended the Function On- tology, and modified the definition of agent type set and outcome set in AMD. The extending of Function Ontology makes the interactions in MAS generated by agent collab- oration can be described. The modification of AMD makes the generating of collaboration solution easier. A negotia- tion frame for the evaluation and choice of collaboration solutions is also given in this paper. It helps the requester evaluate the possible MAS systems, and helps the service agents make decisions to choose a good enough solution by negotiation. According to the dependencies provided in Function Ontology, a specification is given to describe the execution process of the generated MAS system by negotiation. And also a method is given to translate the specification to BPEL which is more standard, acceptable, and easier to understood. Based on the above work, the process of big data handling with service agent collaboration will be our central work in future.



