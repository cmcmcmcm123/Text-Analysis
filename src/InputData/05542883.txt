Considering RFM-Values of Frequent Patterns in  Transactional Databases

Abstract?Market basket analysis is an important data mining application for finding correlations between purchasing items in transactional databases. Previous works show that considering constraints which users may concerned with into the mining process can effectively reduce the number of patterns and get more promising information. In this study, we extend the RFM analysis into the mining process to measure the importance of frequent patterns. In RFM analysis, a customer to be recognized as valuable if his/her purchasing records are recent, frequent, and having high amount of money. Follow the same concept of RFM analysis, we first define the RFM-patterns. The RFM- patterns we discovered are not only frequently occurred but also recently bought and having a higher percentage of revenue. After that, we propose a tree structure, named RFMP-tree, to compress and store entire transactional database, and a pattern growth- based algorithm, called RFMP-growth, is developed to discover all RFM-patterns from RFMP-tree. In experimental evaluation, the results show that the algorithm can both significantly reduce the number of discovered patterns and efficiently find the RFM- patterns.

Keywords: market basket analysis, frequent pattern mining, RFM analysis, constraint-based mining.



I. INTRODUCTION Association rule mining is one of the most prominent  research topics in data mining. It can be used in discovering relationships among items or events in various application domains. By given a user-specified threshold, also known as minimum support, the mining of association rules can discover the complete set of frequent patterns. That is, once the minimum support is given, the complete set of frequent patterns is determined. In order to retrieve more correlations among items, users may specify a relatively lower minimum support. Such a lower support often generates a huge amount of frequent patterns; but most of the patterns are already known or not interested to users. It is a tedious task for users to filter out these valueless patterns.

Previous works [1-2] showed that pushing constraints which users concerned with into the mining algorithm can effectively reduce the number of patterns and get more promising information. Furthermore, instead of filtering patterns after the completion of the mining process, pushing additional constraints directly into the mining procedure can allow more efficient algorithm. For example, users may want such patterns that occur only in a specific period of time,  contained specific itemsets, or follow some regular expressions [2]. Such constraints may meet the users? need and provide an effective and efficient way to gain more meaningful information.

In this study, we consider constraints developed from the RFM analysis to examine the interestingness of frequent patterns into the mining algorithm. RFM (Recency, Frequency and Monetary) analysis [3] is a well-known and powerful tool in database marketing and is widely used in measuring the values of customers according to their prior purchasing history.

Valuable customers can be defined as those whose purchasing behaviors occur frequently and recently and whose purchasing records show high consumption ability, i.e. high total transaction amount. The same concepts can be used to evaluate the value of frequent patterns. That is, a frequent pattern is treated as valuable if it occurs frequently in both the whole database and the recent period, and the pattern can provide higher revenue for business. According to the description above, we develop a scoring-based method from RFM to evaluate the interestingness of patterns. Recency score denotes the number of a pattern?s occurrences in recent period. The more recent occurrences of a pattern does, the higher recency score it will get. Frequency score denotes the support count of the pattern. Monetary score denotes the amount of money that all customers spent on this pattern. A pattern with high recency and frequency scores implies that the pattern is important recently and over the long periods of time, while a pattern with high monetary score is important since it contributes higher revenue to business.

Follow the concepts of scoring method described above, we call a pattern is a RFM-pattern if its recency score, frequency score, and monetary score satisfies user-specified minimum recency, frequency, and monetary thresholds in this paper, respectively. Then, we design a compact tree structure, called RFMP-tree (RFM-pattern tree), which compresses and stores the necessary information of the entire transaction database within it. Based on the tree, we developed a pattern growth algorithm, called RFMP-growth, to discover complete set of RFM-patterns.

The rest of our study is organized as follows: Section 2 shows the literatures relevant to this paper. Section 3 gives the definitions and notations used in the study. Section 4 describes the algorithm and gives some examples to illustrate it. The     experiment result is shown in section 5, and Section 6 concludes the study.



II. RELATED WORK There are some studies dealing with the concept of recency  or monetary in frequent pattern mining. For example, Wu et al.

[4] discussed the recency problem about the change of data distribution between the past data and the new data. Emerging patterns, introduced by Dong and Li [5], discover the significant change in the same dataset but with different time periods. For another example, the utility mining [6-7] is a type of data mining considering the monetary that measure the importance of frequent pattern according to their monetary value (i.e. profit).

Although several existing researches [8-9] use concepts similar to RFM in measuring the importance of frequent patterns, they still fail to fully reflect the requirement of RFM in the mining process. For example, RFM-Apriori [9] defined recency constraint that the occurring time of the last transaction of a pattern should satisfy the recency threshold. Similarly to recency, monetary is defined as that the total amount of money spent by all customers in a pattern should fall into the range between the maximum and minimum monetary thresholds. The paper in [9] proposed an algorithm for mining patterns satisfying RFM constraints; they used a fixed time gap that every occurrence of patterns within the given recent time period will have the same influence regardless of the occurring time. However, their approach cannot reflect the different length of stripes of recency in measuring the importance of transactions. To the best of our knowledge, there exist no comprehensive studies concerning all the three concepts of RFM analysis on frequent pattern mining simultaneously. In this study, the proposed scoring-based method not only gives a more reasonable approach, but also performs the complete concept of RFM on measuring the importance of patterns.



III. PROBLEM DEFINITION In traditional association rule mining, a customer  transaction only contains a set of items. With the information, frequent patterns can be got. For a set I of items in a database, to measure the scores of RFM of itemsets, the database should contain the more information of a transaction X, like <tx, ( 1a , 1aq ) ( 2a , 2aq )?( ma , maq )>, where tx stands for the transaction time when transaction X occurs, the m pairs, (ai,  ia q ), where 1 i m and ai?I, denotes that there are m different items are purchased in the transaction and for item ai, the purchased quantity is  ia q .

Given an itemset Y (Y?I), Y is said to be contained in X if all items in Y also occur in X.

Definition 1. Assume that an itemset Y is contained in transaction X. Y?s transaction recency score gained from X, denoted by trscore(Y, X), is defined as: trscore(Y, X) = (1- ?)tcurrent-tx, where ? is a user-specified decay speed (??[0, 1]), tcurrent denotes the current timestamp.

Decay speed is a parameter used to control the output of the transaction recency score. A larger decay speed represents that the recency of transaction X shrinks fast as tx decrease and will lead to a smaller trscore. On the contrary, a smaller decay speed will result in a higher trscore. Given two transactions Xi and Xj containing itemset Y, the relationship trscore(Y, Xi) trscore(Y, Xj) will always hold when ti tj (0<?<1).

Definition 2. Following Definition 1, the recency score of itemset Y, denoted by Rscore(Y), is defined as the sum of transaction recency score gained from all of the transactions containing it:  ? ?  ? DBX  sDB s  XYtrscoreYRscore ),()( ??????????????????????	?  Given a user-specified recency minimum support ?, an itemset Y is called a R-pattern if Rscore(Y) ?.

Example 1. Consider the transaction database DB shown in Fig. 1(a). Assume that the current time stamp tcurrent = 115 and let the decay speed ? = 0.01. Given an itemset {CE}, its transaction recency score in X5 (e.g. trscore({CE}, X5)) is equal to (1-0.1)115-45 0.495. Moreover, {CE}?s recency score RscoreDB({CE})) trscore({CE}, X1)+trscore({CE}, X2)+?+ trscore({CE}, X1)=1.273. If ?=1 is set, we call an itemset {CE} is a R-pattern.

The concept of frequency is completely the same as the definition in traditional frequent pattern mining. We simply give the following definition.

Definition 3. The frequency score of itemset Y in DB, denoted by Fscore(y), is the number of transactions containing itemset Y.

FscoreDB(Y)=|{Xs | Xs ? DB Y is contained in Xs }| (2)  Given a user-specified minimum frequency support ?, an itemset Y is called a RF-pattern if (1) itemset Y is an R-pattern; and (2) FscoreDB(Y  |DB| ?.

Example 2. Following Example 1, itemset {CE} is a R- pattern. And the Fscore of itemset {CE} is equal to 2 since it is contained in transaction 5 and 7. If ? 10% is set, then {CE} is called a RF-pattern because FscoreDB({CE}) ? 10?10% 1.

TID transaction 1 <0, (A, 1)(B, 2)(F, 1)> 2 <18, (A, 1)(B, 1)(F, 2)> 3 <22, (A, 2)(C, 1)> 4 <39, (A, 2)(B, 1)(E, 3)> 5 <45, (C, 1)(E, 7)> 6 <68, (A, 1)(E, 5)> 7 <90, (C, 2)(D, 1)(E, 10)> 8 <100, (A, 1)(C, 1)(F, 5)> 9 <109, (A, 2)(E, 8)(F, 1)(G, 1)>  10 <115, (A, 2)(D, 1)(E, 10)> (a) Transactional database  Item Price A 10 B 150 C 25 D 45 E 7 F 2 G 80  (b) Item unit price list  Figure 1. An example of transactional database and item unit price list     Monetary stands for the value (amount of money) a specific itemset can provide from historical transactions. In this study, the definitions related to the monetary is similar to those in the mining of high utility patterns [6-7].

Definition 4. Let p(ai) denotes the unit price of item ai.

Assume that an itemset Y is contained in transaction X. An itemset Y?s transaction monetary score gained from X, denoted by tmscore(Y, X), is defined as:  ? i  i  a Ya  i qapXYtmscore ?? ? ?  )(),( ????????????????????????	?  Definition 5. Following Definition 4, the monetary score of itemset Y in DB, denoted by MscoreDB(Y), is the sum of monetary score gained from transactions containing itemset y.

? ? ?  ? DBX  sDB s  XYtmscoreyMscore ),()( ????????????????????	?  Given a user-specified minimum monetary threshold ?, an itemset Y is called a RFM-pattern if (1) Y is a RF-pattern; and (2) MscoreDB(Y) ? ?.

Example 3. Following Example 2, itemset {CE} is a RF- pattern. Consider the item unit price list shown in Fig. 1(b), for items C and E, their unit price is 25 and 7 respectively. Then {CE}?s transaction monetary score from X5 is tmscore({CE}, X5) 1?25 10?7 95. Moreover, the monetary score of {CE} gained from all transactions in DB is MscoreDB({CE}) tmscore({CE}, X1)+ tmscore({CE}, X2)+?+ tmscore({CE}, X15) = 194. If ? 100 is set, then we call {CE} is a RFM- pattern since MscoreDB({CE}) ? 100 and it is also a RF-pattern.

In summary, given a transaction database and user- specified minimum thresholds ?, ?, and ?, the goal of this study is to determine all RFM-patterns which the user interests in.

Although the concept of RFM-pattern is simple, to simultaneously consider all three constraints into the mining process is not straightforward. The main problem is that monetary score doesn?t hold the downward closure property, i.e. a subset of a RFM-pattern may not be a RFM-pattern.

Follow the parameter settings in Example 3, MscoreDB({F}) = 18 doesn?t satisfy ? and {F} will never be a RFM-pattern. But its superset {BF} could be a RFM-pattern since MscoreDB({BF}) = 456 ? ?. In other words, the Mscore of an itemset?s superset is possible to be higher than that of an itemset itself. To effectively prune the search space, we adopt the concepts proposed in [6] to give the following definitions.

Definition 5. Following the Definition 4, the transaction amount for transaction X, denoted by ta(X), is the sum of all items? monetary score in transaction Xs.

i  i  a Xa  i qapXta ?? ? ?  )()( ????????????????????????????????	?  Definition 6. Based on definition 5, the total transaction amount of an itemset Y, denoted by Tta(Y), is defined as:  )()( ? ? ?  ? ss XYDBX  sXtaYTta ????????????????????????????????	?  Given a user-specified minimum monetary threshold ?, an itemset Y is called a RFT-pattern if (1) Y is a RF-pattern; and (2) TtaDB(Y) ? ?.

Example 4. Following Example 3, itemset {CE} is a RF- pattern and is contained in transaction 5 and 7. Then its total transaction amount is Tta({CE}) ta(5)+ ta(7)=239. We call {CE} is a RFT-pattern since {CE} is a RF-pattern and Tta({CE}) ? ?=100.



IV. RFMP-TREE AND RFMP-GROWTH ALGORITHM In this section, we introduce the RFMP-tree structure and  the RFMP-growth algorithm, which are modified from the well-known FP-tree structure and FP-growth algorithm [10].

A. RFMP-tree construction A complete RFMP-tree contains a list, called RFM-header,  and a RFMP-tree. A RFM-header is a list containing all the 1- RFT-patterns (i.e. a RFT-pattern containing one item only), which are sorted according to their Fscore in descending order.

Each entry in RFM-header consists five fields: item-name, Rscore, Fscore, Tta, and head of node-link, where item-name registers which item this entry presents, Rscore, Fscore, and Tta record the recency score, frequency score, and total transaction amount of this item, respectively, and head of node- link points to the first node in RFMP-tree carrying the same item-name.

Each node in RFMP-tree consists of five fields: item-name, Rscore, Fscore, Tta, parent-link, child-link, and sibling-link, where item-name registers which item this node represents, Rscore, Fscore, and Tta register the recency score, frequency score, and total transaction amount from all the transactions that have the corresponding patterns represented at this node, and parent-link, child-link, and sibling-link register the addresses of the parent node, child nodes, and the next node carrying the same item-name in the RFMP-tree, respectively.

While constructing RFMP-tree, we need two database scans (briefly called DB scan in the following sections) to build the complete tree. We first collect information to compact the tree size, and then build the complete RFMP-tree, as shown in Fig. 2. In the first DB scan, we collect all items? Rscore, Fscore, and Tta to get all 1-RFT-patterns and store them in the RFM- header. After that, we sort all 1-RFT-patterns in RFM-header according to their Fscore in descending order. In the second DB scan, we create the root node of the tree and label it as null.

For each transaction, we prune items not contained in RFM- header, i.e. non-1-RFT-patterns, and sort the remaining items according to the order of items in RFM-header. The sorted items are then inserted one by one into the RFMP-tree. Each transaction in this case leads to be a branch in RFMP-tree.

rootroot  AA  FF  BB  (0.315, 1, 312)  (0.315, 1, 312)  (0.315, 1, 312)  rootroot  AA  FF  BB  (0.692, 2, 476)  (0.692, 2, 476)  (0.692, 2, 476)  rootroot  AA  FF  BB  (1.085, 3, 521)  (0.692, 2, 476)  (0.692, 2, 476)  CC (0.393, 1, 45)  (a)                       (b)                                       (c)  rootroot  AA EE  FF CC EE CC  BB FF DD DDBB FF  30021.778D  66731.158B  67942.494F  32942.525C  76864.304E  105984.976A  linkTtaFscoreRscoreitem  30021.778D  66731.158B  67942.494F  32942.525C  76864.304E  105984.976A  linkTtaFscoreRscoreitem  Figure 2. RFMP-tree construction algorithm    While inserting each transaction into RFMP-tree, two possible cases may occur. If there already exists a branch representing the transaction, we simply update all scores related to the transaction into the corresponding nodes. On the contrary, if there exists no corresponding branch, one may have to create all necessary node(s) and calculate initial scores for it/them. Once a new node is created, all the links related to this node have to be built up, including parent-link and node-links.

The procedure insert_node, as shown in Fig. 3, is used to perform the functions describe above.

Since the basic concept of the RFMP-tree construction is the same as the FP-tree, we only use examples to illustrate dissimilar parts as follows. Consider the transaction database DB and item unit price list shown in Fig. 1, let ? 1, ? 10%, ? 100, ? 0.01, and the current time stamp tcurrent=115. After the first DB scan, the RFM-header retain all 1-RFT-patterns and their Rscore, Fscore, and Tta in Fig. 4. All items are already sorted in Fscore descending order. Below, we give the steps of inserting transaction 1, 2, and 3 into the RFMP-tree while the second DB scan performs. We first sort transaction 1 follow the order of items in RFM-header to form <0, (A, 1)(F, 1)(B, 2)>. The three nodes with item-name equal to A, F, and B are created respectively, as shown in Fig. 5(a). Notice that while creating each new node, all of its scores and node-links have to be built up immediately. For nodes A, F, and B, transaction 1?s Rscore=0.315, Fscore=1, and Tta=10?1+150?2 +2?1=312 are stored in the nodes. For the next ordered transaction <18, (A, 1)(F, 2)(B, 1)>, it shares the same prefix (A)(F)(B) with the existing branch. So, we update node A?s, node F?s, and node B?s information based on transaction 2.

After calculation, its Rscore=0.377, Fscore=1, and Tta=10?1+150?1+2?2=164 is accumulated into the nodes, as shown in Fig. 5(b). For the third ordered transaction <22, (A, 2)(C, 1)>, we first update node A?s information, Rscore=0.393, Fscore=1, and Tta=10?2+25? 1=45, in the same way since it shares the same prefix (A). For the remaining 1 item, we insert a new node C as a child of node A, and transaction 3?s Rscore,  Procedure insert_node ([p|P], T, Xs.Rscore, Xs.Tta){ if T has a child node N such that N.item-name=p.item-name then  update N?s Rscore, Fscore, and Tta.

else  create a new node N with N.Fscore=1, N.Rscore = Xs.Rscore,and N.Tta= Xs.Tta  let N?s parent-link be linked to T let N?s node-link be linked to the nodes with the same item-name via the  node-link structure if P is nonempty then call insert_node(P, N, Xs.Rscore, Xs.Tta) }  Figure 3. Procedure insert_node()  Figure 4. The complete RFMP-tree  Figure 5. An example of inserting transactions into RFMP-tree  Fscore, and Tta is then stored in the nodes, as shown in Fig.

5(c). Follow the same steps in the remaining transactions in DB, at last, the complete RFMP-tree is shown in Fig. 4.

B. RFMP-growth algorithm The RFMP- growth algorithm can be divided into two steps.

In the first step we perform the pattern growth recursively and find all RFT-patterns from the RFMP-tree, as shown in Fig. 7.

The second step scans database once to compute the Mscore of all RFT-patterns and finally discover all RFM-patterns.

In the pattern growth procedure, we search the RFM-header and traverse the RFMP-tree from the item?s node-link in RFM- header. The item?s Rscore, Fscore, and Tta value can be collected by traversing nodes with the same item-name through the node-link structure. The item then will be outputted as a RFT-pattern if it satisfies the thresholds. After that, a conditional pattern base is generated for the following procedure. The conditional pattern base is a sub dataset which each pattern in it contains the item we just traversed from RFM-header. It can be generated by the RFMP-tree?s branches which are from the root node to the traversed nodes. After acquiring the complete conditional pattern base, the conditional  Algorithm: RFMP-tree Construction Input: a set of all transactions in DB, min_rscore ?, min_fscore ?, min_mscore ?, decay speed ? Output: RFMP-tree Method: Initial the header table RFM-header; foreach transaction Xs in DB do  foreach item ai?Xs do if ai is not in RFM-header then add a new entry with item-name ai in  RFM-header; update ai?s Rscore, Frscore, and Tta value in RFM-header;  remove items not satisfying minimum thresholds ?, ?, or ? in RFM-header; sort items in RFM-header by their Fscore in descending order; Create the root node of a RFMP-tree T, label it as ?null? ; foreach transaction Xs in DB do  remove items not exist in RFM-header; calculate and record Xs?s Rscore and Tta; sort the remaining items in the order of items in RFM-header; let the sorted items in Xs be [p|P], where p is the first element and P is the  remaining list.

call insert_node( [p|P], T, Xs.Rscore, Xs.tta) ;     Input: RFMP-tree RT, ?, ?, ? Output: a complete set of RFM-patterns Method: Call RFMP-growth(RFMP-tree, null) Procedure RFMP-growth(RT) {  call tree-growth(RT, null) and get all RFT-patterns; scan DB once to get Mscores of RFT-patterns; output all RFM-patterns with their Mscores satisfying ?;  }  Procedure tree-growth(RT, ?) { foreach item ai in RFM-header do  let ai?s node-link is bi; if bi ? null then  get bi?s Rscore, Fscore, and Tta by bi?s node-link structure; if bi.Rscore ? , bi.Fscore ?, and bi.Tta ? then output bi; generate pattern ? ai ??, where ?.Rscore, ?.Fscore, and ?.Tta are  equal to ai?s Rscore, Frscore, and Tta recorded in RFM-header, respectively;  construct ??s conditional pattern base and ??s conditional RFMP-tree RT?;  if RT?? ? then call tree-growth(RT?, ?); }  Figure 6. The RFMP-growth algorithm  RFMP-tree can be constructed using the same steps of constructing RFMP-tree. We can perform the mining procedure recursively with the conditional RFMP-tree and get all of the RFT-patterns.

Here we give an example to show the tree growth procedure with considering only patterns with item D. Initially, the input itemset ? is null that we can traverse the RFMP-tree and generate all of the 1-patterns, including pattern {D}. By traversing the node-link structure, we can collect all the information of pattern {D}, and pattern {D} will be outputted since it satisfies the thresholds. The conditional pattern base of each 1-pattern is then constructed recursively. In this example, we only show item D?s conditional pattern base in Fig. 7.

While the complete pattern base of item D is constructed, we then construct D?s conditional RFMP-tree based on its conditional pattern base, as shown in Fig. 8(a). In the conditional tree construction step, item B and C will be removed from conditional RFMP-tree since they do not satisfy the thresholds, as shown in Fig. 8(b). After the tree growth complete, we can have all RFT-patterns which contain item D.

The RFT-patterns outputted from D?s conditional RFMP-tree are {D}, {DE}, {AD}, and {ADE}.

To find out all of the RFM-patterns from RFT-patterns, we use the hash-tree structure, which is a widely used tree structure in Apriori-based algorithms, to store the RFT-patterns.

After inserting all RFT-patterns in the hash-tree, we scan the database and traverse the hash-tree for each transaction to check if the RFT-pattern is contained in the transaction. Each RFT-pattern?s Mscore value will be collected after the scan  item conditional pattern base Conditional RFMP-tree  D  {(A: 0.456, 1, 236)(E: 0.456, 1, 236)(B: 0.456, 1, 236)}, {(E: 0.778, 1, 165)(C: 0.778, 1, 165)}, {(A: 1, 1, 135)(E: 1, 1, 135)}  {(E: 0.778, 1, 165)}|D, {(E: 1, 1, 135 )(A: 1, 1, 135)}|D  Figure 7. Item D?s conditional pattern base and conditional RFMP-tree   (a)                                         (b)  Figure 8. Item D?s conditional RFMP-tree  completes. For item D?s RFT-patterns as example, pattern {D} and {AD} will be pruned since MscoreD=90 ?, MscoreAD=65  ?. Therefore, the RFM-patterns containing item D are {DE} and {ADE}.



V. EXPERIMENTAL EVALUATION In this section, we perform a simulation study to  empirically compare the proposed algorithm with traditional association rule method (FP-growth). All the algorithms are implemented in Java language and tested on a DualCore Pentium E2180-2.0 GHz Windows XP system with 2 gigabyte of main memory. The three synthetic datasets are generated by IBM Quest Data Generator. Table I lists the parameters used in the data generation algorithm and Table II shows the parameter settings in our experiments. Since the synthetic datasets does not contain purchase quantity, item price, and transaction time, we generate all necessary information in the following way.

The quantity of each item in the transaction is randomly generated from 1 to 10. Each item?s price is randomly generated in log-normal distribution, ranging from 1 to 50,000.

The transaction time interval is drawn from a uniform distribution raging from 1 to 24, i.e. each transaction time will be later than that of prior transaction at most 24 time units.

We also investigate a real-life dataset in our experiments.

This real-life dataset contained all sales data of a supermarket in Taiwan from 2002/7/31 to 2002/11/28. Each row in this dataset records item ID, item quantity, and item price. After we perform all necessary data preprocessing tasks, the dataset contains 108,162 transactions and 9,943 items.

As shown in table III, we have designed three threshold settings. The decay speed ? is set to be 0.001 in all tests.

Besides, since tcurrent can significantly influence the Rscore of each pattern, we set tcurrent to be the same as the latest transaction time to enhance the influence of recency constraint.

Moreover, since the FP-growth considers frequency constraint only, the recency and monetary thresholds will be discarded.

TABLE I. PARAMETERS  |D| Number of transactions |T| Average size of the transactions |I| Average size of the maximal potentially large itemsets N Number of items Np Number of patterns Lp Average length of maximal pattern C Correlation between patterns     TABLE II. PARAMETER SETTINGS OF SYNTHETIC DATASETS  Name |D| |T| |I| N Np Lp C SYN-1 100K 25 20 1K 10K 4 0.25 SYN-2 150K 25 20 1K 10K 4 0.25 SYN-3 150K 25 20 4K 10K 4 0.25  TABLE III. PARAMETER SETTINGS OF THRESHOLDS  ? ? ? S1 3.5 3% 100K S2 4 3.5% 120K S3 4.5 4% 150K  The first test we compare the total execution time with FP- growth. For each threshold setting, the proposed algorithm spends 1.42 times more than FP-growth on average. This is a reasonable result since we need three database scans whereas FP-growth needs only two database scans to find complete set of patterns.

Next, we compare the number of patterns generated from RFMP-growth and FP-growth. All three threshold settings are considered here. As shown in table IV, we find that the number of patterns significantly decrease when three constraints are added. On average, our method prunes more than 55 percent of patterns. We further examine the revenues both two kinds of patterns can represent, and the result is promising. Although RFM-patterns retain less than 45 percent of patterns, the proportion of the revenue of RFM-patterns to that of traditional patterns is more than 64 percents. Moreover, we conduct the same test using real-life dataset. In Table V, the result show that our method outputs only 7 percent of traditional patterns but the revenue of these patterns is over 12 percents. In  TABLE IV. THE PROPORTION OF THE REVENUE OF RFM-PATTERNS TO THAT OF TRADITIONAL PATTERNS. (SYNTHETIC DATASETS)  patterns al traditionof # patternsRFM of # ?  patterns) aditionalRevenue(tr patterns)MRevenue(RF ?  S1 S2 S3 S1 S2 S3 SYN-1 47.21% 42.96% 39.34% 74.99% 71.31% 64.62% SYN-2 55.13% 55.33% 52.23% 77.42% 80.46% 77.21% SYN-3 35.16% 35.90% 32.91% 62.12% 43.52% 28.93%  TABLE V. THE PROPORTION OF THE REVENUE OF RFM-PATTERNS TO THAT OF TRADITIONAL PATTERNS. (REAL-LIFE DATASETS)  patterns al traditionof # patternsRFM of # ?  patterns) aditionalRevenue(tr patterns)MRevenue(RF ?  R0.05-F1%-M10k 6.90% 14.68% R0.05-F0.5%-M10k 6.69% 10.26% R0.005-F0.5%-M10k 7.62% 11.49% R0.005-F0.6%-M12k 6.98% 11.39%  summary, through setting recency, frequency, and monetary thresholds simultaneously, we can get more compact, representative and useful patterns.



VI. CONCLUSION In this study, we consider the concept of RFM analysis into  frequent pattern mining. To truly reflect the spirit of RFM in the mining process, we first define RFM-patterns, which can dynamically give recency score to each transaction, and perform the concept of monetary similar to utility mining. To efficiently discover RFM-patterns, we propose a tree structure (RFMP-tree) as well as the pattern growth method (RFMP- growth) to discover complete set of RFM-patterns.

Three synthetic datasets and a real-life dataset are used in experimental evaluation. The experimental results show that the proposed method can not only significantly reduce the size of outputted patterns, but also retain more meaningful results to users.

