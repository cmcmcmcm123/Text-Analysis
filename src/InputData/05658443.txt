Research of An Association Rule Mining

Abstract- Based on analyzing an association rule mining  algorithm called FP tree. a new association rule mining  algorithm called QFP was presented. Through scanning the  database only once, the QFP algorithm can convert a transaction  database into a QFP tree after data preprocessing, and then do  the association rule mining of the tree. The QFP algorithm is  more integrity than the FP ?rowth algorithm, and retain the  complete information for mining frequent patterns; it will not  destroy the long pattern of any transaction, and significantly  reduce the non-relevant information. Experiments show that the  QFP algorithm is more efficient if the aspect of time than the  FP ?rowth algorithm.

Keywords- Association rule mining; Frequent Pattern(FP};  FP Jrowth algorithm; QFP algorithm

I. THE OUTLINE OF FP-TREE ALGORITHM  In 2000, Han etc. proposed the FP _tree algorithm[l ],  the algorithm is used in mining the frequent pattern of the  Boolean rule from transaction database. Its entire excavation  process is quite complex, but may be simply divided into two  basic steps: First step, it constructs a FP tree using data in  transaction database; Second step, it mines all frequent patterns  from the FP tree, and establishes conveniently the association  rule according to the frequent pattern and the profession  background knowledge.

Table 1. The transaction database D  TID Item Frequent 1 item set after sorting  TOOl f,a,c,g,i,m,p f,c,a,m,p  TOO2 a,b,c,f,l f,c,a,b  TOO3 b,f,h,m,p f,b,m,p  T004 b,c,k,m,o c,b,m  TOO5 a,f,c,e,n,p f,c,a,p    Ming De-ting  Computer and Information Engineering Institute  Jiangxi Agricultural University  Nanchang, China  Email: jxau_mdt@163.com  The following is an example which shows that the FP _tree  algorithm carries on the association rule excavation[2]. The  database excavated is shown in Table 1, and it is supposed that  the smallest support is min_sup=3. TID in table 1 lists the  identifier of the transaction records.

At first, the FP _tree algorithm scans the database, and  obtains the support counting value of each item (the number  which each item appears in database). The scanning result is  f: 4, c: 4, a: 3, b: 3, m: 3, p: 3. The left side of the  colon is the item's identifier; the right side of the colon is the  support counting value of this item. Then delete the item whose  support counting value is smaller than the min _sup from the  scan result, and arrange various items which decreases  progressively in order according to the item's support counting  value, record the results in the table L, L=[ f: 4, c: 4, a:  3, b: 3, m: 3, p: 3], the frequent 1 item set is shown  as the 3rd row of Table 1 after the reorganization.

Second step, construct the FP tree. It creates the root node  whose symbol was null, and then scans the database once more,  reads each transaction record in tum. If all items In a  transaction appear in the table L, then rearrange them  according to the order in the table L, and establish the  corresponding branch in FP tree. The first record in Table 1 is  TOOl, because its five items appear in the table L, therefore  rearrange according to the order in the table L: {f,c,a,m,p} ,  and constructs a five node branch in FP tree <f: l .... c: l .... a: 1 ....

m: l .... p: l>, fis connected to the root node, c is connected toJ,  and a is to connected to a. Then read the second transaction  record T002. Similarly, { a, b, c, f} in T002 appears in the table  L, the arrangement according to the order in the table L is: f, c,  a, b, then establish the corresponding branch in FP tree.

Because the nodes f, c, a under the root node already  existed, therefore only the node b was connected to the node a ,  and added the support counting values 1 on three nodes f, c, a.

Thus, after scanning the entire database, constructed the FP  tree which it corresponded. For the convenience of traversal  the FP tree, a frequent item header table was created. The order  of the element in the table was the same as that of the table L ,  each element of which had an indicator, aiming at the node  which corresponded in FP tree. Finally the FP tree was formed  in Figure 1.

Third step, the FP _growth algorithm carries the excavation  on the constructed FP tree. Regarding the FP tree shown in  Figure 1, begin from the final element p in table L, found all  the nodes whose symbol is p in FP _tree through its indicator,  which appear in 3 branches. The nodes above the node p in  these 3 branches constitute the condition pattern base of the  node p, labeled by {(facm: l},(fca:l),(cbm: I)}, the value in  right flank of the colon corresponds to the support counting  value of the node p separately in three branches. The condition  FP _tree of the node p is obtained from the condition pattern  base of the node p, labeled by < c:3 >. That the node fhas not  appeared in the condition FP _tree of the node p is because its  support counting value is smaller than min_sup in the condition  pattern base of the node p. Finally the node p combines with  the node c which appears in the condition FP _tree, thus the  frequent pattern is obtained: <cp: 3>, and other elements'  frequent pattern from this table L may be obtained. The  excavation result on FP tree was shown in Table 2.

Frequent item header table  Item Support counting value Head  f 4 ?  c 4 -  a 3 ...

b 3 ...

m 3 \ \  P 3 \  \ \  Figure 1. The FP tree corresponds to the database   TABLE 2. THE DEMONSTRATION OF EXCAVATING THE FP TREE  condition Frequent Item the condition pauem base  FP-tree paUem  p {(facm:l },(fca:l),(cbm:1) } <c:3 > cp:3  rn {(fca:l),(fb:l),(cb:l) } th th  b {(fca:l),(f:l),(c:l) } th m  a { (fc:3) } <fc:3 fa:3,ca:3, fc  c { f:3 } <f:3 fc:3  f th th m  Although excavation efficiency of the association rule on  the FP _growth algorithm is higher than that of the Aprioi  algorithm[3], it still needs to scan twice transaction databases.

The table L is obtained through the first scanning transaction  database; the FP tree is constructed through the second  scanning transaction database. Because the expense of  scanning actual transaction database is very big, if the  excavation algorithm can again reduce the number of times of  scanning the transaction database on this foundation, then it  can further effectively enhance the excavation efficiency of the  association rule [4]. Therefore, we designed a fast association  rule excavation algorithm called QFP. The QFP algorithm has  two basic steps: first, scan the transaction database, the  transaction database is transformed to the tree similar with the  FP tree in the scarming process (which is called the QFP tree),  and keep all related information between items in the database' ,  second, mining the QFP tree to find all possible association  rules. Compared with the FP _growth algorithm, the QFP  algorithm only needs to scan the transaction database once, so  it can increase the time efficiency of mining association rules.



II. RAPID ASSOCIA nON RULE MINING ALGORITHM ( QFP)  A. Related definitions  Definition I: Transaction database D, It's a database for  storing transaction records. Every transaction record in the  database has a unique identifier. A transaction record includes  the order of all items involving the transaction. A simplified  transaction database D is shown Table 3, where TOOl is the  identifier of the first record in the database D, the transaction    that TOO] corresponds to includes the items a, c, f, m, p, which  are arranged in accordance with the order of the identifier.

TABLE 3. TRANSACTION DATABASE D  TID Original item set  TOOl a,c,f,m,p  TOO2 a,b,c,f,  TOO3 b,f"m,p  TOO4 b,c,m  TOO5 a, c, f ,p  Definition 2: The QFP tree is composed of an root node  labeled null and several tree nodes, each of which node can  form a sub-tree with n nodes(n=O, l, 2, ' .. ). When n is  equal to 0, the node is called the leaf node. As the QFP tree  represents the transaction database, the tree nodes are  represented by the identifier of items in the database. Except  the root node, each node Ii is composed of two fields, Ii.count  and Ii.pointer, among which Ii.count is the number of the same  items appearing on the node, and is labeled in the parentheses  of the right side of the node's identifier Ii; Ii.pointer is the  pointer pointing to its parent node.

Definition 3:The path combining node C. It is an arbitrary  combination of all nodes( excluding the root node) on the path  from the leaf node to the root node null for the QFP tree. The  value in the parentheses of the right side of the node identifier  is the value count of the combination, and the value count is  equal to Ii. count of the leaf node.

Definition 4: Table TL is a pointer queue[5], each element  in which points to the leaf node of the QFP tree, a pointer  corresponds to the leaf node.

Definition 5: Candidate set of frequent pattern CF[6].The  element in the collection is C.

B. The theory of the QFP algorithm  The QFP algorithm is divided into constructing QFP tree  and mining the QFP tree.

]) Construct QFP tree  First of all, create the tree's root node null of the QFP tree,  then take the first record in the database D, and insert it into the  QFP tree. The insertion process is: take the first item of the  record, if the identifier of the root node is the same with that of   the child node in the QFP tree, then add 1 to the value count  (count field) of the child node, Otherwise, create a new child  node under the root node, and assign the identifier of the item  as the identifier of the new child node; then take the inserted  node as the root of the sub-tree, and insert the next item into  the sub-tree by the above steps ; repeat until all items of the  record have been inserted into the QFP tree, and complete a  record insertion process. Then take a record from the database  D, repeat the above record insertion process until all records in  the database are inserted into the QFP tree. Thus, the  transaction database D is transformed into the QFP tree after a  scanning, and a path from the leaf node to the root node  corresponds to one or more records, and retains the association  information between items of the original records. In order to  facilitate future mining association rules, in the process of  building the tree, make the pointer of the table TL point to the  leaf node in the QFP tree, one pointer corresponds to the leaf  node. The database D shown in table 3 can be transformed into  the QFP tree shown in figure 2 by the above processes, the  value in parentheses of the right side of the node is hcount.

Table TL       ,  ,  ... ' I' , ,  "'"  -  .....

,  .... ; ------  .... - _ ... "  I I  Figure 2. Convert the database D into the QFP tree  2) Mine the QFP tree  Take the first element in the table TL, and obtain the leaf  node which the element points to, and the path is formed from  the leaf node to the root node null. Combine all nodes in the  path (except the root node null), by definition 3, assign the  identifier and the count of the combination. Then put all  combination into the candidate frequent pattern set CF, If  there already exists the same combination in the CF (i.e. the    same identifier of the combination), then merge them. The  operation of merging is: the identifier of the combination  remains the same, and the value count is the sum of the two.

After all the combinations on the path becoming the candidate  frequent pattern set CF, amend the nodes on the path. The  amendment process is: subtract the value count of the leaf node  from the value count of all the nodes on the path. After that, if  the leaf node on the path has the parent node which hasn't the  other child node and the parent node is not a root node, let the  pointer point to the parent node of the leaf node, and make it as  a leaf node; do the same operation on a new path. Otherwise,  delete the pointer from the table TL.

Since then, take the next element in the table TL, repeat  this process until all the elements in the table have been  removed, and complete the processing of all leaf nodes in QFP  tree. Finally, remove the combination whose value count is less  than min_sup(the minimum support) in CF. In this way, the  frequent patterns stay in CF, and construct out all the candidate  association rules, and filter out the required association rules by  the given value min_conf(minimum confidence).

Here is the process of mining on the QFP tree(Figure 2).

Find the leaf node p whose pointer points to the first  element in the table TL, and obtain the path: p-m-c-a?  fa Combine on these five nodes to be {p, m} ( I ) , { p  ,  c} (I) , {p,  a} (I) , {p,  f}(I) , {m, c} (I) , {m, a} (I) ,  {m, f}(1) , {c,  a} (I) , {c,  f}(I) , {a,  f}(1) , {p,  m,  c } (I), {p, c, a} (I), {p, c, f}(I), {p, a, f}(1), {p,  m, f}(I), {p, m, a} (I), {m, c, a} (I), {m, c, f}(I),  {c, a, f}(I), {m, a, f}(1), {p, c, a, m} (I), {p, c,  a, f}(1) , { p, m, a, f}(1) , {m, c, a, f}(I) , {m, c,  a, p} (I), {p, c, a, m, f}(I).CF is empty at this time, thus  26 combinations enter directly into the CF. Then amend the  nodes on the path by subtracting I from the value count of p,  m, c, a, f. As the values count of the two nodes p, m is 0, while  the value count of the parent node f of the node m is not 0, so  delete the element in the table TL. So then, take the next  element in table TL, repeat the process until left the last  element in the table TL. The last pointer in table TL points to  the leaf node p, and obtain various combinations on the four  nodes p, c, f, a .Put the combinations into CF, and amend the  nodes on the path . At this time because the values count of the  four nodes p, f, a, c is 0, remove the pointer in the table TL.

Finally, remove the combinations whose count is less than  min_sup (in this case min_sup = 3) from CF. Figure 2 shows  the CF mining on the QFP tree:  CF={ {c, a} (3) , {c, f}(3), {a, f}(3), {a, c, f } (3) }

III. THE QFP ALGORITHM  A. The theory of the QFP algorithm  The pseudo code of QFP algorithm is as follows:  Input: the transaction database D, min_sup  Output: Frequent pattern set CF  Steps: (1) Construct QFP tree  Create the root node null;  Open the database D;  while(not EOF)  {R= the current record;  Call insert_tree(R, null);  The pointer of the record pushed backward I;  Procedure insert_tree(record, root_node)  {while(record<> ?)  {first= the first item of the record;  Remove the item from the record;  if( existing the child node a in the root node whose identifier is  first)  a.count=a.count+ I:  else  { Create the node a whose identifier is first;  a.count=I;  a.pointer points to the root node;  }  if(record= ? )  { Remove the pointer which points to the other node on the  path in the table TL;  Create the pointer which points to the node a in the table TL; }  }  (2)Mining QFP tree(tree, TL)  while(TL<> ?)  { Take the first element in the table TL which points to the leaf  node a;  Combine the node a to the path whose root node is null ,the    path is Cl' C2? "', Cm;  for(i=l ;  i<=m; i++)  { Cj.count=a.count;  The symbol Cj is assigned as the order arrangement of the  nodes in this combination;  if(CjECF)  CF.Cj.count=CF.Cj.count+Cj.count;  else  Put Cj into the frequent pattern CF; }  The value count of other nodes on this path subtracts the  value count of the leaf node;  if (the father node of the node a does not have other child nodes  and also is not a root node)  Modify the pointer which points to the node a in the table TL,  it points to the parent node of the node a;  else  Remove the pointer which points to the node a in the table  TL; }  Remove the combination whose value count is less than  min_sup in CF;  B. Experimental result of the QFP algorithm  To test the actual effect of the QFP algorithm, at the same  software and hardware environment (P4 3GHz CPU, 2GMB  RAM ,  250GB hardware, windows XP OS), we tested the  QFP algorithm and FP _growth algorithm for mining  association rules on a transaction database. The database has  about 18,000 records, and the number of items set involving is  about 200. Repeated tests showed that: the two algorithms  mined out the same candidate frequent sets, and the mining  speed of the QFP algorithm is improved by about 20%. The  principle of the QFP algorithm is: as the transaction database  increases, the time efficiency of the QFP algorithm will be  further enhanced.

When the transaction database is so large that the computer  memory is difficult to save a QFP tree corresponding to the  whole database, the database can be divided into several  sub-databases according to the given conditions, and then the  FP tree for each sub-database is constructed. Their respective  path nodes of the QFP tree can be combined into a candidate  general pattern. Finally process the candidate pattern again, and  obtain all frequent patterns. Therefore, the QFP algorithm is   suitable specially to mine association rules on the large-scale  business database.



IV. CONCLUSION  Because the excavated business database is very big, the  algorithm's operating efficiency of mining association rules  appears especially important. We have conducted the thorough  research on the FP _growth algorithm, and have designed the  association rule excavation algorithm called QFP. After the  pretreatment of the data, without need to sort the items in  business database according to the frequency descending  sequence, this algorithm can transform the database into the  QFP tree, and then carries on the excavation to the QFP tree.

The experiment indicated that, the time efficiency of the QFP  algorithm is higher than that of the FP _growth algorithm. As  the input of the QFP algorithm is the same as that of the  FP ?owth algorithm or the Apriori algorithm, therefore, the  QFP algorithm may apply to any situation which is suitable for  the FP _growth algorithm or the Apriori algorithm.

